<!--
SPDX-FileCopyrightText: © 2024-2025 Phala Network <dstack@phala.network>
SPDX-License-Identifier: Apache-2.0
-->
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>{{TITLE}}</title>
  <style>
/* SPDX-FileCopyrightText: © 2025 Phala Network <dstack@phala.network>
   SPDX-License-Identifier: Apache-2.0 */

:root {
  --color-primary: #2563eb;
  --color-primary-hover: #1d4ed8;
  --color-success: #16a34a;
  --color-warning: #ea580c;
  --color-danger: #dc2626;
  --color-text-primary: #0f172a;
  --color-text-secondary: #475569;
  --color-text-tertiary: #94a3b8;
  --color-bg-primary: #ffffff;
  --color-bg-secondary: #f8fafc;
  --color-bg-tertiary: #f1f5f9;
  --color-border: #e2e8f0;
  --color-border-light: #f1f5f9;
  --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
  --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1);
  --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1);
  --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1);
  --radius-sm: 6px;
  --radius-md: 8px;
  --radius-lg: 12px;
  color-scheme: light;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
}

* {
  box-sizing: border-box;
}

body {
  margin: 0;
  padding: 0;
  background: var(--color-bg-secondary);
  color: var(--color-text-primary);
  line-height: 1.6;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

h1, h2, h3, h4, h5, h6 {
  margin: 0;
  font-weight: 600;
  color: var(--color-text-primary);
}

.console-root {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

.app-header {
  background: var(--color-bg-primary);
  border-bottom: 1px solid var(--color-border);
  box-shadow: var(--shadow-sm);
  position: sticky;
  top: 0;
  z-index: 100;
}

.header-content {
  max-width: 1400px;
  margin: 0 auto;
  padding: 16px 24px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 24px;
}

.header-left {
  display: flex;
  align-items: center;
  gap: 12px;
}

.app-title {
  font-size: 20px;
  font-weight: 700;
  color: var(--color-text-primary);
}

.version-badge {
  background: var(--color-bg-tertiary);
  color: var(--color-text-secondary);
  padding: 4px 10px;
  border-radius: 12px;
  font-size: 12px;
  font-weight: 600;
}

.header-right {
  display: flex;
  align-items: center;
  gap: 12px;
}

.btn-primary {
  background: var(--color-primary);
  color: white;
  border: none;
  padding: 10px 20px;
  border-radius: var(--radius-md);
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  gap: 8px;
  transition: all 0.2s ease;
  box-shadow: var(--shadow-sm);
}

.btn-primary:hover {
  background: var(--color-primary-hover);
  box-shadow: var(--shadow-md);
  transform: translateY(-1px);
}

.btn-primary:active {
  transform: translateY(0);
}

.btn-secondary {
  background: var(--color-bg-primary);
  color: var(--color-text-secondary);
  border: 1px solid var(--color-border);
  padding: 8px 16px;
  border-radius: var(--radius-md);
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  gap: 6px;
  transition: all 0.2s ease;
}

.btn-secondary:hover {
  background: var(--color-bg-tertiary);
  border-color: var(--color-text-tertiary);
}

.btn-secondary:active {
  transform: scale(0.98);
}

.toolbar {
  max-width: 1400px;
  margin: 24px auto;
  padding: 0 24px;
  display: flex;
  flex-wrap: wrap;
  gap: 16px;
  justify-content: space-between;
  align-items: center;
}

.toolbar-section {
  display: flex;
  align-items: center;
  gap: 16px;
  flex-wrap: wrap;
}

.search-box {
  position: relative;
  display: flex;
  align-items: center;
  background: var(--color-bg-primary);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  padding: 0 12px;
  gap: 8px;
  min-width: 320px;
  box-shadow: var(--shadow-sm);
}

.search-icon {
  color: var(--color-text-tertiary);
  flex-shrink: 0;
}

.search-box input {
  border: none;
  outline: none;
  padding: 10px 0;
  font-size: 14px;
  background: transparent;
  flex: 1;
  min-width: 0;
  color: var(--color-text-primary);
}

.search-box input::placeholder {
  color: var(--color-text-tertiary);
}

.btn-search {
  background: var(--color-primary);
  color: white;
  border: none;
  padding: 6px 14px;
  border-radius: var(--radius-sm);
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  white-space: nowrap;
  transition: background 0.2s ease;
}

.btn-search:hover {
  background: var(--color-primary-hover);
}

.vm-count {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px 16px;
  background: var(--color-bg-primary);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  box-shadow: var(--shadow-sm);
}

.count-label {
  color: var(--color-text-secondary);
  font-size: 13px;
  font-weight: 500;
}

.count-value {
  color: var(--color-primary);
  font-size: 15px;
  font-weight: 700;
}

.pagination-controls {
  display: flex;
  align-items: center;
  gap: 8px;
  background: var(--color-bg-primary);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  padding: 6px;
  box-shadow: var(--shadow-sm);
}

.btn-pagination {
  background: transparent;
  border: none;
  padding: 6px 8px;
  border-radius: var(--radius-sm);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--color-text-secondary);
  transition: all 0.2s ease;
}

.btn-pagination:hover:not(:disabled) {
  background: var(--color-bg-tertiary);
  color: var(--color-text-primary);
}

.btn-pagination:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.page-display {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 0 8px;
}

.page-input {
  width: 50px;
  padding: 4px 8px;
  border: 1px solid var(--color-border);
  border-radius: var(--radius-sm);
  font-size: 14px;
  text-align: center;
  outline: none;
}

.page-input:focus {
  border-color: var(--color-primary);
}

.page-separator {
  color: var(--color-text-tertiary);
  font-weight: 500;
}

.page-total {
  color: var(--color-text-secondary);
  font-weight: 600;
  min-width: 24px;
  text-align: center;
}

.page-size-select {
  border: 1px solid var(--color-border);
  border-radius: var(--radius-sm);
  padding: 6px 10px;
  font-size: 13px;
  outline: none;
  cursor: pointer;
  background: var(--color-bg-primary);
  color: var(--color-text-secondary);
  font-weight: 500;
}

.page-size-select:hover {
  border-color: var(--color-text-tertiary);
}

.vm-table {
  max-width: 900px;
  width: 900px;
  margin: 0 auto 24px;
  padding: 0 24px;
}

.vm-table-header {
  display: grid;
  grid-template-columns: 24px 2fr 100px 120px 180px 60px;
  gap: 16px;
  padding: 12px 16px;
  background: var(--color-bg-primary);
  border-bottom: 2px solid var(--color-border);
  font-weight: 600;
  font-size: 13px;
  color: var(--color-text-secondary);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.vm-row {
  background: var(--color-bg-primary);
  border-bottom: 1px solid var(--color-border-light);
  transition: background 0.15s ease;
}

.vm-row:hover {
  background: var(--color-bg-secondary);
}

.vm-row-main {
  display: grid;
  grid-template-columns: 24px 2fr 100px 120px 180px 60px;
  gap: 16px;
  padding: 16px;
  align-items: center;
  cursor: pointer;
  transition: background-color 0.15s ease;
}

.vm-col-expand,
.vm-col-name,
.vm-col-status,
.vm-col-uptime,
.vm-col-view,
.vm-col-actions {
  display: flex;
  align-items: center;
}

.vm-col-view,
.vm-col-actions {
  cursor: default;
}

.vm-col-expand {
  justify-content: flex-start;
}

.vm-col-view {
  gap: 12px;
}

.btn-expand {
  width: 24px;
  height: 24px;
  border: 1px solid transparent;
  background: transparent;
  border-radius: var(--radius-sm);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--color-text-tertiary);
  transition: all 0.2s ease;
  opacity: 0.7;
}

.btn-expand:hover {
  background: var(--color-bg-tertiary);
  color: var(--color-text-primary);
  opacity: 1;
}

.btn-expand.expanded {
  background: var(--color-primary);
  color: white;
  opacity: 1;
}

.vm-name {
  font-size: 15px;
  font-weight: 600;
  color: var(--color-text-primary);
}

.view-link {
  color: var(--color-primary);
  text-decoration: none;
  font-size: 14px;
  font-weight: 500;
  transition: color 0.15s ease;
}

.view-link:hover {
  color: var(--color-primary-hover);
  text-decoration: underline;
}

.btn-actions {
  width: 36px;
  height: 36px;
  border: 1px solid var(--color-border);
  background: var(--color-bg-primary);
  border-radius: var(--radius-sm);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--color-text-secondary);
  transition: all 0.2s ease;
}

.btn-actions:hover {
  background: var(--color-bg-tertiary);
  border-color: var(--color-text-tertiary);
  color: var(--color-text-primary);
}

.status-badge {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 6px 12px;
  border-radius: 16px;
  font-size: 13px;
  font-weight: 600;
  text-transform: capitalize;
}

.status-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

.status-running {
  background: #dcfce7;
  color: var(--color-success);
}

.status-running .status-dot {
  background: var(--color-success);
}

.status-stopping,
.status-shutting-down {
  background: #fed7aa;
  color: var(--color-warning);
}

.status-stopping .status-dot,
.status-shutting-down .status-dot {
  background: var(--color-warning);
}

.status-exited {
  background: var(--color-bg-tertiary);
  color: var(--color-text-tertiary);
}

.status-exited .status-dot {
  background: var(--color-text-tertiary);
  animation: none;
}

.status-stopped {
  background: #fee2e2;
  color: var(--color-danger);
}

.status-stopped .status-dot {
  background: var(--color-danger);
  animation: none;
}

.vm-details {
  padding: 24px;
  background: var(--color-bg-secondary);
  border-top: 1px solid var(--color-border);
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.details-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
  gap: 16px;
}

.detail-item {
  display: flex;
  flex-direction: column;
  gap: 6px;
  min-width: 0;
}

.detail-label {
  font-size: 12px;
  font-weight: 600;
  color: var(--color-text-tertiary);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.detail-value {
  font-size: 14px;
  color: var(--color-text-primary);
  font-weight: 500;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  cursor: help;
}

.gpu-chip-list {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
}

.gpu-chip {
  font-size: 12px;
  line-height: 1.4;
  padding: 4px 10px;
  border-radius: 999px;
  border: 1px solid var(--color-border);
  background: var(--color-bg-primary);
  color: var(--color-text-secondary);
  white-space: nowrap;
}

.gpu-chip--all {
  font-weight: 600;
  color: var(--color-text-primary);
  border-style: dashed;
}

.port-mappings {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.port-mappings h4 {
  font-size: 14px;
  font-weight: 600;
  color: var(--color-text-primary);
  margin-bottom: 4px;
}

.port-item {
  padding: 12px 16px;
  background: var(--color-bg-primary);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 14px;
  font-family: 'SF Mono', 'Monaco', 'Cascadia Code', monospace;
}

.features-section {
  margin-top: 24px;
}

.features-section h4 {
  font-size: 14px;
  font-weight: 600;
  color: var(--color-text-primary);
  margin-bottom: 8px;
}

.features-text {
  font-size: 14px;
  color: var(--color-text-secondary);
  font-family: 'SF Mono', 'Monaco', 'Cascadia Code', monospace;
  background: var(--color-bg-primary);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  padding: 12px 16px;
  display: inline-block;
}

.detail-value-with-copy {
  display: flex;
  align-items: center;
  gap: 8px;
  flex: 1;
  min-width: 0;
}

.detail-value-with-copy .detail-value {
  flex: 1;
  min-width: 0;
}

.copy-btn {
  flex-shrink: 0;
  padding: 4px;
  background: transparent;
  border: 1px solid var(--color-border);
  border-radius: 4px;
  cursor: pointer;
  color: var(--color-text-secondary);
  transition: all 0.15s ease;
  display: flex;
  align-items: center;
  justify-content: center;
}

.copy-btn:hover {
  background: var(--color-bg-tertiary);
  border-color: var(--color-primary);
  color: var(--color-primary);
}

.section-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
}

.section-actions {
  display: flex;
  align-items: center;
  gap: 8px;
}

.copy-btn-small {
  background: var(--color-bg-primary);
  border: 1px solid var(--color-border);
  padding: 6px 8px;
  border-radius: var(--radius-sm);
  cursor: pointer;
  color: var(--color-text-secondary);
  transition: all 0.15s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  min-width: 32px;
  height: 32px;
}

.copy-btn-small:hover {
  background: var(--color-bg-tertiary);
  border-color: var(--color-primary);
  color: var(--color-primary);
}

.section-header h4 {
  font-size: 14px;
  font-weight: 600;
  color: var(--color-text-primary);
  margin: 0;
}

.compose-section,
.user-config-section {
  margin-top: 24px;
}

.compose-content {
  width: 100%;
  max-width: 100%;
  overflow-x: auto;
}

.compose-content pre,
.user-config-content {
  background: var(--color-bg-primary);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  padding: 16px;
  font-size: 13px;
  font-family: 'SF Mono', 'Monaco', 'Cascadia Code', monospace;
  line-height: 1.6;
  max-height: 400px;
  overflow-y: auto;
  margin: 0;
  white-space: pre-wrap;
  word-break: break-all;
  color: var(--color-text-primary);
  width: 100%;
  box-sizing: border-box;
}

.network-section {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.section-title {
  font-size: 15px;
  font-weight: 600;
  color: var(--color-text-primary);
  margin: 0;
  display: flex;
  align-items: center;
  gap: 8px;
}

.network-interfaces {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(320px, 360px));
  gap: 12px;
}

.network-interface-card {
  background: var(--color-bg-primary);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  overflow: hidden;
}

.interface-header {
  background: var(--color-bg-tertiary);
  padding: 12px 16px;
  border-bottom: 1px solid var(--color-border);
}

.interface-name {
  display: flex;
  align-items: center;
  gap: 8px;
  font-weight: 600;
  color: var(--color-text-primary);
  font-size: 14px;
}

.interface-name svg {
  color: var(--color-primary);
  flex-shrink: 0;
}

.interface-details {
  padding: 16px;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.interface-detail-row {
  display: flex;
  justify-content: space-between;
  align-items: baseline;
  gap: 12px;
  padding-bottom: 8px;
  border-bottom: 1px solid var(--color-border-light);
}

.interface-detail-row:last-of-type {
  border-bottom: none;
  padding-bottom: 0;
}

.interface-detail-row .detail-label {
  font-size: 12px;
  font-weight: 600;
  color: var(--color-text-tertiary);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  flex-shrink: 0;
}

.interface-detail-row .detail-value {
  font-size: 13px;
  color: var(--color-text-primary);
  font-family: 'SF Mono', 'Monaco', 'Cascadia Code', monospace;
  word-break: break-all;
  text-align: right;
}

.interface-stats {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
  margin-top: 8px;
  padding-top: 12px;
  border-top: 1px solid var(--color-border-light);
}

.stat-item {
  display: flex;
  gap: 10px;
  align-items: flex-start;
}

.stat-icon {
  width: 28px;
  height: 28px;
  border-radius: var(--radius-sm);
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
}

.stat-icon.rx {
  background: #dcfce7;
  color: var(--color-success);
}

.stat-icon.tx {
  background: #dbeafe;
  color: var(--color-primary);
}

.stat-content {
  display: flex;
  flex-direction: column;
  gap: 2px;
  min-width: 0;
}

.stat-label {
  font-size: 11px;
  font-weight: 700;
  color: var(--color-text-tertiary);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.stat-value {
  font-size: 13px;
  font-weight: 600;
  color: var(--color-text-primary);
  font-family: 'SF Mono', 'Monaco', 'Cascadia Code', monospace;
}

.stat-errors {
  font-size: 11px;
  color: var(--color-danger);
  font-weight: 500;
}

.wireguard-section {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.wireguard-info-text {
  background: var(--color-bg-primary);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  padding: 16px;
  font-family: 'SF Mono', 'Monaco', 'Cascadia Code', monospace;
  font-size: 12px;
  overflow-x: auto;
  line-height: 1.6;
  color: var(--color-text-secondary);
  margin: 0;
}

.vm-log-tabs {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
}

.vm-log-button {
  background: var(--color-bg-primary);
  border: 1px solid var(--color-border);
  padding: 8px 16px;
  border-radius: var(--radius-md);
  font-size: 14px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.vm-log-button:hover {
  background: var(--color-bg-tertiary);
  border-color: var(--color-text-tertiary);
}

.dropdown {
  position: relative;
  display: inline-block;
}

.dropdown-content {
  display: none;
  position: absolute;
  right: 0;
  top: calc(100% + 4px);
  z-index: 300;
  min-width: 200px;
  background: var(--color-bg-primary);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  box-shadow: var(--shadow-xl);
  overflow: hidden;
}

.dropdown-content.show {
  display: block;
  animation: fadeIn 0.15s ease;
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(-8px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.dropdown-content button {
  width: 100%;
  padding: 12px 16px;
  border: none;
  background: transparent;
  text-align: left;
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  color: var(--color-text-primary);
  transition: all 0.15s ease;
  display: flex;
  align-items: center;
  gap: 12px;
  border-bottom: 1px solid var(--color-border);
}

.dropdown-content button:last-child {
  border-bottom: none;
}

.dropdown-content button:hover {
  background: var(--color-bg-tertiary);
  padding-left: 20px;
  color: var(--color-primary);
}

.dropdown-content button svg {
  flex-shrink: 0;
  opacity: 0.7;
  transition: opacity 0.15s ease;
}

.dropdown-content button:hover svg {
  opacity: 1;
}

/* System Menu Styles */
.system-menu {
  position: relative;
  display: inline-block;
  margin-right: 12px;
}

.btn-icon {
  background: transparent;
  color: var(--color-text-secondary);
  border: 1px solid var(--color-border);
  padding: 8px;
  border-radius: var(--radius-md);
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s ease;
  min-width: 36px;
  min-height: 36px;
}

.btn-icon:hover {
  background: var(--color-bg-tertiary);
  color: var(--color-primary);
  border-color: var(--color-primary);
  box-shadow: var(--shadow-sm);
  transform: translateY(-1px);
}

.btn-icon:active {
  transform: translateY(0);
}

.system-dropdown {
  display: none;
  position: absolute;
  right: 0;
  top: calc(100% + 8px);
  z-index: 300;
  min-width: 180px;
  background: var(--color-bg-primary);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  box-shadow: var(--shadow-xl);
  animation: fadeIn 0.15s ease;
}

.system-dropdown.show {
  display: block;
}

.dropdown-item {
  width: 100%;
  padding: 12px 16px;
  border: none;
  background: transparent;
  text-align: left;
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  color: var(--color-text-primary);
  transition: all 0.15s ease;
  display: flex;
  align-items: center;
  gap: 12px;
  border-bottom: 1px solid var(--color-border-light);
}

.dropdown-item:last-child {
  border-bottom: none;
}

.dropdown-item:hover {
  background: var(--color-bg-tertiary);
  padding-left: 20px;
  color: var(--color-primary);
}

.dropdown-item svg {
  flex-shrink: 0;
  opacity: 0.7;
  transition: opacity 0.15s ease;
}

.dropdown-item:hover svg {
  opacity: 1;
}

.message-container {
  position: fixed;
  top: 20px;
  right: 20px;
  z-index: 1001;
  display: flex;
  flex-direction: column;
  gap: 8px;
  max-width: 400px;
}

.message {
  position: relative;
  padding: 12px 40px 12px 16px;
  border-radius: var(--radius-md);
  font-size: 13px;
  box-shadow: var(--shadow-lg);
  animation: slideInRight 0.3s ease;
  word-wrap: break-word;
}

@keyframes slideInRight {
  from {
    opacity: 0;
    transform: translateX(20px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

.success-message {
  background: #dcfce7;
  color: #166534;
  border-left: 4px solid var(--color-success);
}

.error-message {
  background: #fee2e2;
  color: #991b1b;
  border-left: 4px solid var(--color-danger);
}

.close-btn {
  position: absolute;
  top: 8px;
  right: 8px;
  border: none;
  background: transparent;
  font-size: 18px;
  cursor: pointer;
  color: inherit;
  opacity: 0.6;
  transition: opacity 0.2s ease;
  width: 20px;
  height: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
}

.close-btn:hover {
  opacity: 1;
  background: rgba(0, 0, 0, 0.1);
}

.dialog-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 24px;
  z-index: 1000;
  backdrop-filter: blur(4px);
}

.dialog {
  background: var(--color-bg-primary);
  border-radius: var(--radius-lg);
  max-width: 960px;
  width: 100%;
  max-height: 90vh;
  overflow-y: auto;
  padding: 32px;
  box-shadow: var(--shadow-xl);
  animation: dialogIn 0.2s ease;
}

@keyframes dialogIn {
  from {
    opacity: 0;
    transform: scale(0.95);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

.dialog h2 {
  margin-bottom: 24px;
  font-size: 24px;
}

.dialog-footer {
  display: flex;
  justify-content: flex-end;
  gap: 12px;
  margin-top: 32px;
  padding-top: 24px;
  border-top: 1px solid var(--color-border);
}

.form-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: 20px;
  margin-bottom: 24px;
}

.form-group {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.form-group.full-width {
  grid-column: 1 / -1;
}

.form-group label {
  font-weight: 600;
  color: var(--color-text-primary);
  font-size: 14px;
}

.form-group input,
.form-group select,
.form-group textarea {
  width: 100%;
  padding: 10px 12px;
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  font-size: 14px;
  outline: none;
  background: var(--color-bg-primary);
  color: var(--color-text-primary);
  transition: all 0.2s ease;
}

.form-group input:focus,
.form-group select:focus,
.form-group textarea:focus {
  border-color: var(--color-primary);
  box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
}

.form-group textarea {
  min-height: 120px;
  resize: vertical;
  font-family: 'SF Mono', 'Monaco', 'Cascadia Code', monospace;
}

.hint {
  color: var(--color-text-tertiary);
  font-size: 13px;
}

.help-icon {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  width: 18px;
  height: 18px;
  font-size: 12px;
  font-weight: 700;
  color: white;
  background: var(--color-text-tertiary);
  border-radius: 50%;
  cursor: help;
}

.action-btn {
  background: var(--color-primary);
  color: white;
  border: none;
  padding: 10px 18px;
  border-radius: var(--radius-md);
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  gap: 8px;
  transition: all 0.2s ease;
}

.action-btn:hover {
  background: var(--color-primary-hover);
  transform: translateY(-1px);
  box-shadow: var(--shadow-md);
}

.action-btn:disabled {
  background: var(--color-text-tertiary);
  cursor: not-allowed;
  transform: none;
  opacity: 0.6;
}

.action-btn.primary {
  background: var(--color-success);
}

.action-btn.primary:hover {
  background: #15803d;
}

.action-btn.danger {
  background: var(--color-danger);
}

.action-btn.danger:hover {
  background: #b91c1c;
}

.inline-field {
  display: flex;
  align-items: center;
  gap: 12px;
}

.file-input-row {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.file-input-actions {
  display: flex;
  align-items: center;
  gap: 12px;
}

.file-input-actions input[type="file"] {
  display: none;
}

.help-text {
  color: var(--color-text-tertiary);
  font-size: 14px;
}

.feature-checkboxes,
.checkbox-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 12px;
  row-gap: 16px;
}

.gpu-checkbox-grid {
  display: grid;
  grid-template-columns: 1fr;
  gap: 12px;
  row-gap: 16px;
}

.feature-checkboxes label,
.checkbox-grid label,
.gpu-checkbox-grid label {
  display: flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
  white-space: nowrap;
}

.feature-checkboxes input[type="checkbox"],
.checkbox-grid input[type="checkbox"],
.gpu-checkbox-grid input[type="checkbox"] {
  flex-shrink: 0;
  cursor: pointer;
  margin: 0;
  width: 16px;
  height: 16px;
}

.encrypted-env-editor,
.port-mapping-editor,
.gpu-config-editor {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.port-mapping-editor > button {
  width: fit-content;
  min-width: 120px;
}

.gpu-section-label {
  font-size: 14px;
  font-weight: 600;
  color: var(--color-text-primary);
  margin-bottom: -8px;
}

.gpu-config-list-header {
  font-size: 13px;
  font-weight: 500;
  color: var(--color-text-secondary);
  margin-bottom: 8px;
}

.gpu-config-hint {
  font-size: 13px;
  color: var(--color-text-secondary);
  padding: 12px 16px;
  background: var(--color-bg-secondary);
  border-radius: var(--radius-md);
  border-left: 3px solid var(--color-primary);
}

.env-editor-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
}

.env-editor-title {
  font-size: 14px;
  font-weight: 600;
  color: var(--color-text-primary);
  margin: 0;
}

.env-mode-toggle {
  display: flex;
  gap: 0;
  border: 1px solid var(--color-border);
  border-radius: var(--radius-sm);
  overflow: hidden;
}

.mode-btn {
  padding: 6px 16px;
  border: none;
  background: var(--color-bg-primary);
  color: var(--color-text-secondary);
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  border-right: 1px solid var(--color-border);
}

.mode-btn:last-child {
  border-right: none;
}

.mode-btn:hover {
  background: var(--color-bg-tertiary);
}

.mode-btn.active {
  background: var(--color-primary);
  color: white;
}

.env-form-mode {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.env-text-mode {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.env-text-mode textarea {
  width: 100%;
  padding: 12px;
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  font-size: 14px;
  font-family: 'SF Mono', 'Monaco', 'Cascadia Code', monospace;
  resize: vertical;
  line-height: 1.5;
}

.env-text-mode textarea:focus {
  outline: none;
  border-color: var(--color-primary);
  box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
}

.env-editor-empty {
  padding: 16px;
  background: var(--color-bg-tertiary);
  border: 1px dashed var(--color-border);
  border-radius: var(--radius-md);
}

.env-editor-empty .hint {
  margin: 0;
  color: var(--color-text-secondary);
  font-size: 14px;
  line-height: 1.5;
}

.encrypted-env-row,
.port-row {
  display: grid;
  gap: 12px;
  align-items: center;
}

.encrypted-env-row {
  grid-template-columns: 200px 1fr auto;
}

.encrypted-env-actions {
  display: flex;
  align-items: center;
  gap: 12px;
}

.encrypted-env-actions input[type="file"] {
  display: none;
}

.port-row {
  grid-template-columns: 90px 100px 120px 120px 100px;
}

.gpu-config-items {
  max-height: 240px;
  overflow-y: auto;
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  padding: 16px;
  background: var(--color-bg-secondary);
}

.gpu-checkbox-grid label {
  font-size: 14px;
}

.warning-text {
  color: var(--color-danger);
  font-weight: 600;
}

.app-id-preview {
  font-family: 'SF Mono', 'Monaco', 'Cascadia Code', monospace;
  font-size: 13px;
  color: var(--color-text-secondary);
  background: var(--color-bg-tertiary);
  padding: 8px 12px;
  border-radius: var(--radius-sm);
}

</style>
</head>

<body>
  <div id="app"></div>
  <script src="https://unpkg.com/vue@3.4.21/dist/vue.global.prod.js"></script>
  <script>
(function(){
  const modules = {
'build/ts/main.js': { factory: function(module, exports, require) {
// SPDX-FileCopyrightText: © 2025 Phala Network <dstack@phala.network>
// SPDX-License-Identifier: Apache-2.0
const { createApp } = Vue;
const App = require('./App');
createApp(App).mount('#app');

}, map: {"./App":"build/ts/App.js"} },
'build/ts/App.js': { factory: function(module, exports, require) {
"use strict";
// SPDX-FileCopyrightText: © 2025 Phala Network <dstack@phala.network>
// SPDX-License-Identifier: Apache-2.0
const EncryptedEnvEditor = require('./components/EncryptedEnvEditor');
const PortMappingEditor = require('./components/PortMappingEditor');
const GpuConfigEditor = require('./components/GpuConfigEditor');
const CreateVmDialog = require('./components/CreateVmDialog');
const UpdateVmDialog = require('./components/UpdateVmDialog');
const ForkVmDialog = require('./components/ForkVmDialog');
const { useVmManager } = require('./composables/useVmManager');
const template = require('./templates/app.html');
const AppComponent = {
    name: 'DstackConsoleApp',
    components: {
        'encrypted-env-editor': EncryptedEnvEditor,
        'port-mapping-editor': PortMappingEditor,
        'gpu-config-editor': GpuConfigEditor,
        'create-vm-dialog': CreateVmDialog,
        'update-vm-dialog': UpdateVmDialog,
        'fork-vm-dialog': ForkVmDialog,
    },
    setup() {
        return useVmManager();
    },
    template,
};
module.exports = AppComponent;

}, map: {"./components/EncryptedEnvEditor":"build/ts/components/EncryptedEnvEditor.js","./components/PortMappingEditor":"build/ts/components/PortMappingEditor.js","./components/GpuConfigEditor":"build/ts/components/GpuConfigEditor.js","./components/CreateVmDialog":"build/ts/components/CreateVmDialog.js","./components/UpdateVmDialog":"build/ts/components/UpdateVmDialog.js","./components/ForkVmDialog":"build/ts/components/ForkVmDialog.js","./composables/useVmManager":"build/ts/composables/useVmManager.js","./templates/app.html":"build/ts/templates/app.html"} },
'build/ts/components/EncryptedEnvEditor.js': { factory: function(module, exports, require) {
"use strict";
// SPDX-FileCopyrightText: © 2025 Phala Network <dstack@phala.network>
// SPDX-License-Identifier: Apache-2.0
const EncryptedEnvEditorComponent = {
    name: 'EncryptedEnvEditor',
    props: {
        envVars: {
            type: Array,
            required: true,
        },
    },
    data() {
        return {
            editMode: 'form',
            textContent: '',
        };
    },
    template: /* html */ `
    <div class="encrypted-env-editor">
      <div class="env-editor-header">
        <h4 class="env-editor-title">Encrypted Environment Variables</h4>
        <div class="env-mode-toggle">
          <button
            type="button"
            class="mode-btn"
            :class="{ active: editMode === 'form' }"
            @click="switchToForm">
            Form
          </button>
          <button
            type="button"
            class="mode-btn"
            :class="{ active: editMode === 'text' }"
            @click="switchToText">
            Text
          </button>
        </div>
      </div>

      <div v-if="editMode === 'form'" class="env-form-mode">
        <div v-if="envVars.length === 0" class="env-editor-empty">
          <p class="hint">No environment variables yet. Click "Add" to create one.</p>
        </div>
        <div v-for="(env, index) in envVars" :key="index" class="encrypted-env-row">
          <input type="text" v-model="env.key" placeholder="Variable name" required>
          <input type="password" v-model="env.value" placeholder="Value" required>
          <button type="button" class="action-btn danger" @click="removeEnv(index)">
            Remove
          </button>
        </div>
        <div class="encrypted-env-actions">
          <button type="button" class="action-btn" @click="addEnv">Add</button>
          <input type="file" ref="envFileInput" @change="loadEnvFromFile" accept=".env,.txt">
          <button type="button" class="action-btn" @click="triggerFileInput">Load from file</button>
        </div>
      </div>

      <div v-else class="env-text-mode">
        <textarea
          v-model="textContent"
          @blur="parseTextContent"
          placeholder="Enter environment variables, one per line:&#10;KEY1=value1&#10;KEY2=value2&#10;# Comments start with #"
          rows="8"
        ></textarea>
        <p class="hint">Format: KEY=VALUE (one per line). Lines starting with # are ignored.</p>
      </div>
    </div>
  `,
    methods: {
        addEnv() {
            this.envVars.push({ key: '', value: '' });
        },
        removeEnv(index) {
            this.envVars.splice(index, 1);
        },
        triggerFileInput() {
            var _a;
            (_a = this.$refs.envFileInput) === null || _a === void 0 ? void 0 : _a.click();
        },
        switchToForm() {
            this.parseTextContent();
            this.$data.editMode = 'form';
        },
        switchToText() {
            this.$data.textContent = this.envVars
                .map((env) => `${env.key}=${env.value}`)
                .join('\n');
            this.$data.editMode = 'text';
        },
        parseTextContent() {
            const content = this.$data.textContent;
            if (!content.trim()) {
                return;
            }
            const lines = content.split('\n');
            this.envVars.splice(0, this.envVars.length);
            for (const line of lines) {
                const trimmed = line.trim();
                if (!trimmed || trimmed.startsWith('#')) {
                    continue;
                }
                const equalIndex = trimmed.indexOf('=');
                if (equalIndex === -1) {
                    continue;
                }
                const key = trimmed.substring(0, equalIndex).trim();
                const value = trimmed.substring(equalIndex + 1).trim();
                if (!key) {
                    continue;
                }
                this.envVars.push({ key, value });
            }
        },
        loadEnvFromFile(event) {
            var _a;
            const input = event.target;
            const file = (_a = input === null || input === void 0 ? void 0 : input.files) === null || _a === void 0 ? void 0 : _a[0];
            if (!file) {
                return;
            }
            const reader = new FileReader();
            reader.onload = (e) => {
                const content = e.target.result || '';
                const lines = content.split('\n');
                this.envVars.splice(0, this.envVars.length);
                for (const line of lines) {
                    const trimmed = line.trim();
                    if (!trimmed || trimmed.startsWith('#')) {
                        continue;
                    }
                    const equalIndex = trimmed.indexOf('=');
                    if (equalIndex === -1) {
                        continue;
                    }
                    const key = trimmed.substring(0, equalIndex).trim();
                    const value = trimmed.substring(equalIndex + 1).trim();
                    if (!key) {
                        continue;
                    }
                    this.envVars.push({ key, value });
                }
            };
            reader.readAsText(file);
            if (input) {
                input.value = '';
            }
        },
    },
};
module.exports = EncryptedEnvEditorComponent;

}, map: {} },
'build/ts/components/PortMappingEditor.js': { factory: function(module, exports, require) {
"use strict";
// SPDX-FileCopyrightText: © 2025 Phala Network <dstack@phala.network>
// SPDX-License-Identifier: Apache-2.0
const PortMappingEditorComponent = {
    name: 'PortMappingEditor',
    props: {
        ports: {
            type: Array,
            required: true,
        },
    },
    template: /* html */ `
    <div class="port-mapping-editor">
      <label>Port Mappings</label>
      <div v-for="(port, index) in ports" :key="index" class="port-row">
        <select v-model="port.protocol">
          <option value="tcp">TCP</option>
          <option value="udp">UDP</option>
        </select>
        <select v-model="port.host_address">
          <option value="127.0.0.1">Local</option>
          <option value="0.0.0.0">Public</option>
        </select>
        <input type="number" v-model.number="port.host_port" placeholder="Host Port" required>
        <input type="number" v-model.number="port.vm_port" placeholder="VM Port" required>
        <button type="button" class="action-btn danger" @click="removePort(index)">Remove</button>
      </div>
      <button type="button" class="action-btn" @click="addPort">Add Port</button>
    </div>
  `,
    methods: {
        addPort() {
            this.ports.push({
                protocol: 'tcp',
                host_address: '127.0.0.1',
                host_port: null,
                vm_port: null,
            });
        },
        removePort(index) {
            this.ports.splice(index, 1);
        },
    },
};
module.exports = PortMappingEditorComponent;

}, map: {} },
'build/ts/components/GpuConfigEditor.js': { factory: function(module, exports, require) {
"use strict";
// SPDX-FileCopyrightText: © 2025 Phala Network <dstack@phala.network>
// SPDX-License-Identifier: Apache-2.0
const { computed } = Vue;
const GpuConfigEditorComponent = {
    name: 'GpuConfigEditor',
    props: {
        availableGpus: {
            type: Array,
            required: true,
        },
        gpus: {
            type: Array,
            required: true,
        },
        attachAll: {
            type: Boolean,
            required: true,
        },
        allowAttachAll: {
            type: Boolean,
            required: true,
        },
    },
    emits: ['update:gpus', 'update:attachAll'],
    setup(props, { emit }) {
        const selectedGpus = computed({
            get: () => props.gpus,
            set: (value) => emit('update:gpus', value),
        });
        const attachAllComputed = computed({
            get: () => props.attachAll,
            set: (value) => emit('update:attachAll', value),
        });
        return {
            selectedGpus,
            attachAllComputed,
        };
    },
    template: /* html */ `
    <div class="gpu-config-editor">
      <label class="gpu-section-label">GPU Configuration</label>
      <div v-if="allowAttachAll" class="checkbox-grid">
        <label>
          <input type="checkbox" v-model="attachAllComputed">
          Attach All GPUs and NVSwitches
        </label>
      </div>
      <div v-if="!attachAllComputed" class="gpu-config-list">
        <div class="gpu-config-list-header">
          Select GPUs to attach:
        </div>
        <div class="gpu-config-items">
          <div class="gpu-checkbox-grid">
            <label v-for="gpu in availableGpus" :key="gpu.slot">
              <input type="checkbox" :value="gpu.slot" v-model="selectedGpus">
              <span>{{ gpu.slot }}: {{ gpu.description }} {{ gpu.is_free ? '' : '(in use)' }}</span>
            </label>
          </div>
        </div>
      </div>
      <div v-else class="gpu-config-hint">
        All NVIDIA GPUs and NVSwitches will be attached to the VM
      </div>
    </div>
  `,
};
module.exports = GpuConfigEditorComponent;

}, map: {} },
'build/ts/components/CreateVmDialog.js': { factory: function(module, exports, require) {
"use strict";
// SPDX-FileCopyrightText: © 2025 Phala Network <dstack@phala.network>
// SPDX-License-Identifier: Apache-2.0
const EncryptedEnvEditor = require('./EncryptedEnvEditor');
const PortMappingEditor = require('./PortMappingEditor');
const GpuConfigEditor = require('./GpuConfigEditor');
const CreateVmDialogComponent = {
    name: 'CreateVmDialog',
    components: {
        'encrypted-env-editor': EncryptedEnvEditor,
        'port-mapping-editor': PortMappingEditor,
        'gpu-config-editor': GpuConfigEditor,
    },
    props: {
        visible: { type: Boolean, required: true },
        form: { type: Object, required: true },
        availableImages: { type: Array, required: true },
        availableGpus: { type: Array, required: true },
        allowAttachAllGpus: { type: Boolean, required: true },
        kmsAvailable: { type: Boolean, required: true },
        portMappingEnabled: { type: Boolean, required: true },
    },
    emits: ['close', 'submit', 'load-compose'],
    template: /* html */ `
    <div v-if="visible" class="dialog-overlay" @click.self="$emit('close')">
      <div class="dialog">
        <h2>Deploy a new instance</h2>
        <form @submit.prevent="$emit('submit')" class="create-vm-form">
          <div class="form-grid">
            <div class="form-group">
              <label for="vmName">Name</label>
              <input id="vmName" v-model="form.name" type="text" placeholder="Enter VM name" required>
            </div>

            <div class="form-group">
              <label for="vmImage">Image</label>
              <select id="vmImage" v-model="form.image" required>
                <option value="" disabled>Select an image</option>
                <option v-for="image in availableImages" :key="image.name" :value="image.name">
                  {{ image.name }}
                </option>
              </select>
            </div>

            <div class="form-group">
              <label for="vcpu">Number of vCPUs</label>
              <input id="vcpu" v-model.number="form.vcpu" type="number" placeholder="vCPUs" required>
            </div>

            <div class="form-group">
              <label for="memory">Memory</label>
              <div class="inline-field">
                <input id="memory" v-model.number="form.memoryValue" type="number" placeholder="Memory" required>
                <select v-model="form.memoryUnit">
                  <option value="MB">MB</option>
                  <option value="GB">GB</option>
                </select>
              </div>
            </div>

            <div class="form-group">
              <label for="swapSize">Swap (optional)</label>
              <div class="inline-field">
                <input id="swapSize" v-model.number="form.swapValue" type="number" min="0" step="0.1" placeholder="Swap size">
                <select v-model="form.swapUnit">
                  <option value="MB">MB</option>
                  <option value="GB">GB</option>
                </select>
              </div>
              <small class="hint">Leave as 0 to disable swap.</small>
            </div>

            <div class="form-group">
              <label for="diskSize">Storage (GB)</label>
              <input id="diskSize" v-model.number="form.disk_size" type="number" placeholder="Storage size in GB" required>
            </div>

            <div class="form-group">
              <label for="storageFs">Storage Filesystem
                <span class="help-icon" title="ZFS: strong integrity guarantees. ext4: lower overhead for databases.">?</span>
              </label>
              <select id="storageFs" v-model="form.storage_fs">
                <option value="">Default (ZFS)</option>
                <option value="zfs">ZFS</option>
                <option value="ext4">ext4</option>
              </select>
            </div>

            <div class="form-group full-width">
              <label for="appId">App ID (optional)</label>
              <input id="appId" v-model="form.app_id" type="text" placeholder="Leave empty for automatic generation">
            </div>

            <div class="form-group full-width">
              <label for="dockerComposeFile">Docker Compose File</label>
              <div class="file-input-row">
                <div class="file-input-actions">
                  <button type="button" class="action-btn" @click="$refs.composeFile.click()">Upload File</button>
                  <span class="help-text">or paste below</span>
                  <input ref="composeFile" type="file" accept=".yml,.yaml,.txt" @change="$emit('load-compose', $event)">
                </div>
                <textarea id="dockerComposeFile" v-model="form.dockerComposeFile" placeholder="Paste your docker-compose.yml here" rows="8"></textarea>
              </div>
            </div>

            <div class="form-group full-width">
              <label for="preLaunchScript">Pre-launch Script</label>
              <textarea id="preLaunchScript" v-model="form.preLaunchScript" placeholder="Optional script executed before launch" rows="6"></textarea>
            </div>

            <div class="form-group full-width">
              <label for="userConfig">User Config</label>
              <textarea id="userConfig" v-model="form.user_config" placeholder="Optional user config placed at /dstack/.user-config in the CVM"></textarea>
            </div>

            <div class="form-group full-width" v-if="availableGpus.length > 0">
              <gpu-config-editor
                :available-gpus="availableGpus"
                v-model:gpus="form.selectedGpus"
                v-model:attach-all="form.attachAllGpus"
                :allow-attach-all="allowAttachAllGpus"
              />
            </div>

            <div class="form-group full-width">
              <label>Features</label>
              <div class="feature-checkboxes">
                <label><input type="checkbox" v-model="form.kms_enabled"> Enable KMS</label>
                <label><input type="checkbox" v-model="form.local_key_provider_enabled"> Enable local key provider</label>
                <label><input type="checkbox" v-model="form.gateway_enabled"> Enable dstack-gateway</label>
                <label><input type="checkbox" v-model="form.public_logs"> Public logs</label>
                <label><input type="checkbox" v-model="form.public_sysinfo"> Public sysinfo</label>
                <label><input type="checkbox" v-model="form.public_tcbinfo"> Public TCB info</label>
                <label><input type="checkbox" v-model="form.no_tee"> Disable TDX</label>
                <label><input type="checkbox" v-model="form.pin_numa"> Pin NUMA</label>
                <label><input type="checkbox" v-model="form.hugepages"> Huge pages</label>
              </div>
            </div>

            <div class="form-group full-width" v-if="form.kms_enabled || form.local_key_provider_enabled">
              <label for="keyProviderId">Key Provider ID</label>
              <input id="keyProviderId" v-model="form.key_provider_id" type="text" placeholder="Optional provider ID">
            </div>

            <div class="form-group full-width" v-if="kmsAvailable">
              <encrypted-env-editor :env-vars="form.encryptedEnvs" />
            </div>

            <div class="form-group full-width" v-if="portMappingEnabled">
              <port-mapping-editor :ports="form.ports" />
            </div>
          </div>

          <div class="dialog-footer">
            <button type="submit" class="action-btn primary">Deploy</button>
            <button type="button" class="action-btn" @click="$emit('close')">Cancel</button>
          </div>
        </form>
      </div>
    </div>
  `,
};
module.exports = CreateVmDialogComponent;

}, map: {"./EncryptedEnvEditor":"build/ts/components/EncryptedEnvEditor.js","./PortMappingEditor":"build/ts/components/PortMappingEditor.js","./GpuConfigEditor":"build/ts/components/GpuConfigEditor.js"} },
'build/ts/components/UpdateVmDialog.js': { factory: function(module, exports, require) {
"use strict";
// SPDX-FileCopyrightText: © 2025 Phala Network <dstack@phala.network>
// SPDX-License-Identifier: Apache-2.0
const EncryptedEnvEditor = require('./EncryptedEnvEditor');
const PortMappingEditor = require('./PortMappingEditor');
const GpuConfigEditor = require('./GpuConfigEditor');
const UpdateVmDialogComponent = {
    name: 'UpdateVmDialog',
    components: {
        'encrypted-env-editor': EncryptedEnvEditor,
        'port-mapping-editor': PortMappingEditor,
        'gpu-config-editor': GpuConfigEditor,
    },
    props: {
        visible: { type: Boolean, required: true },
        dialog: { type: Object, required: true },
        availableImages: { type: Array, required: true },
        availableGpus: { type: Array, required: true },
        allowAttachAllGpus: { type: Boolean, required: true },
        portMappingEnabled: { type: Boolean, required: true },
        kmsEnabled: { type: Boolean, required: true },
        composeHashPreview: { type: String, required: true },
    },
    emits: ['close', 'submit', 'load-compose'],
    template: /* html */ `
    <div v-if="visible" class="dialog-overlay" @click.self="$emit('close')">
      <div class="dialog">
        <h3>Update VM Config</h3>

        <div v-if="kmsEnabled">
          <div class="form-group">
            <label for="upgradeVcpu">Number of vCPUs</label>
            <input id="upgradeVcpu" v-model.number="dialog.vcpu" type="number" placeholder="vCPUs" required>
          </div>
          <div class="form-group">
            <label for="upgradeMemory">Memory</label>
            <div class="inline-field">
              <input id="upgradeMemory" v-model.number="dialog.memoryValue" type="number" placeholder="Memory" required>
              <select v-model="dialog.memoryUnit">
                <option value="MB">MB</option>
                <option value="GB">GB</option>
              </select>
            </div>
          </div>
        </div>

        <div v-if="kmsEnabled" class="form-group">
          <label for="upgradeSwap">Swap (optional)</label>
          <div class="inline-field">
            <input id="upgradeSwap" v-model.number="dialog.swapValue" type="number" min="0" step="0.1" placeholder="Swap size" :disabled="!dialog.updateCompose">
            <select v-model="dialog.swapUnit" :disabled="!dialog.updateCompose">
              <option value="MB">MB</option>
              <option value="GB">GB</option>
            </select>
          </div>
          <small class="hint">Enable "Update compose" to change swap size.</small>
        </div>

        <div class="form-group">
          <label for="upgradeDiskSize">Disk Size (GB)</label>
          <input id="upgradeDiskSize" v-model.number="dialog.disk_size" type="number" placeholder="Disk size in GB" required>
        </div>

        <div v-if="kmsEnabled">
          <div class="form-group">
            <label for="upgradeImage">Image</label>
            <select id="upgradeImage" v-model="dialog.image" required>
              <option value="" disabled>Select an image</option>
              <option v-for="image in availableImages" :key="image.name" :value="image.name">
                {{ image.name }}
              </option>
            </select>
          </div>

          <div class="checkbox-grid">
            <label><input type="checkbox" v-model="dialog.updateCompose"> Update App Compose</label>
          </div>

          <div v-if="dialog.updateCompose" class="compose-update">
            <div class="form-group">
              <label for="upgradeCompose">Docker Compose File</label>
              <div class="file-input-row">
                <div class="file-input-actions">
                  <button type="button" class="action-btn" @click="$refs.composeFile.click()">Upload File</button>
                  <span class="help-text">or paste below</span>
                  <input ref="composeFile" type="file" accept=".yml,.yaml,.txt" @change="$emit('load-compose', $event)">
                </div>
                <textarea id="upgradeCompose" v-model="dialog.dockerComposeFile" placeholder="Paste your new docker-compose.yml here" rows="8" required></textarea>
              </div>
            </div>
            <div class="form-group">
              <label for="upgradePrelauncher">Pre-launch Script</label>
              <textarea id="upgradePrelauncher" v-model="dialog.preLaunchScript" placeholder="Optional: Bash script to run before starting containers"></textarea>
            </div>
            <div class="app-id-preview">
              Compose Hash: 0x{{ composeHashPreview }}
            </div>
          </div>

          <div class="checkbox-grid">
            <label><input type="checkbox" v-model="dialog.resetSecrets"> Reset secrets</label>
          </div>
          <div v-if="dialog.resetSecrets" class="reset-secrets">
            <div class="form-group full-width">
              <encrypted-env-editor :env-vars="dialog.encryptedEnvs" />
            </div>
          </div>
        </div>

        <div class="form-group" v-if="availableGpus.length > 0">
          <div class="checkbox-grid">
            <label><input type="checkbox" v-model="dialog.updateGpuConfig"> Update GPU configuration</label>
          </div>
          <div v-if="dialog.updateGpuConfig">
            <gpu-config-editor
              :available-gpus="availableGpus"
              :allow-attach-all="allowAttachAllGpus"
              v-model:gpus="dialog.selectedGpus"
              v-model:attach-all="dialog.attachAllGpus"
            />
          </div>
        </div>

        <div class="form-group full-width" v-if="portMappingEnabled">
          <port-mapping-editor :ports="dialog.ports" />
        </div>

        <div class="form-group">
          <label for="upgradeUserConfig">User Config</label>
          <textarea id="upgradeUserConfig" v-model="dialog.user_config" placeholder="Optional: User config to be put at /dstack/.user-config in the CVM"></textarea>
        </div>

        <div class="dialog-footer">
          <button class="action-btn primary" @click="$emit('submit')">Update</button>
          <button class="action-btn" @click="$emit('close')">Cancel</button>
        </div>
      </div>
    </div>
  `,
};
module.exports = UpdateVmDialogComponent;

}, map: {"./EncryptedEnvEditor":"build/ts/components/EncryptedEnvEditor.js","./PortMappingEditor":"build/ts/components/PortMappingEditor.js","./GpuConfigEditor":"build/ts/components/GpuConfigEditor.js"} },
'build/ts/components/ForkVmDialog.js': { factory: function(module, exports, require) {
"use strict";
// SPDX-FileCopyrightText: © 2025 Phala Network <dstack@phala.network>
// SPDX-License-Identifier: Apache-2.0
const ForkVmDialogComponent = {
    name: 'ForkVmDialog',
    props: {
        visible: { type: Boolean, required: true },
        dialog: { type: Object, required: true },
        availableImages: { type: Array, required: true },
    },
    emits: ['close', 'submit'],
    template: /* html */ `
    <div v-if="visible" class="dialog-overlay" @click.self="$emit('close')">
      <div class="dialog">
        <h3>Derive VM</h3>
        <p class="warning-text">
          This will create a new VM instance with the same app id, but the disk state will NOT migrate to the new instance.
        </p>

        <div class="form-group">
          <label for="forkImage">Image</label>
          <select id="forkImage" v-model="dialog.image" required>
            <option value="" disabled>Select an image</option>
            <option v-for="image in availableImages" :key="image.name" :value="image.name">
              {{ image.name }}
            </option>
          </select>
        </div>

        <div class="form-group">
          <label for="forkVcpu">Number of vCPUs</label>
          <input id="forkVcpu" v-model.number="dialog.vcpu" type="number" placeholder="vCPUs" required>
        </div>

        <div class="form-group">
          <label for="forkMemory">Memory (MB)</label>
          <input id="forkMemory" v-model.number="dialog.memory" type="number" placeholder="Memory in MB" required>
        </div>

        <div class="form-group">
          <label for="forkDiskSize">Disk Size (GB)</label>
          <input id="forkDiskSize" v-model.number="dialog.disk_size" type="number" placeholder="Disk size in GB" required>
        </div>

        <div class="dialog-footer">
          <button class="action-btn primary" @click="$emit('submit')">Derive</button>
          <button class="action-btn" @click="$emit('close')">Cancel</button>
        </div>
      </div>
    </div>
  `,
};
module.exports = ForkVmDialogComponent;

}, map: {} },
'build/ts/composables/useVmManager.js': { factory: function(module, exports, require) {
"use strict";
// SPDX-FileCopyrightText: © 2025 Phala Network <dstack@phala.network>
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.useVmManager = useVmManager;
const { ref, computed, watch, onMounted } = Vue;
const x25519 = require('../lib/x25519.js');
const { getVmmRpcClient } = require('../lib/vmmRpcClient');
const vmmRpc = getVmmRpcClient();
// System menu state
const systemMenu = ref({
    show: false,
});
const devMode = ref(localStorage.getItem('devMode') === 'true');
function createVmFormState(preLaunchScript) {
    return {
        name: '',
        image: '',
        dockerComposeFile: '',
        preLaunchScript,
        vcpu: 1,
        memory: 2048,
        memoryValue: 2,
        memoryUnit: 'GB',
        swap_size: 0,
        swapValue: 0,
        swapUnit: 'GB',
        disk_size: 20,
        selectedGpus: [],
        attachAllGpus: false,
        ports: [],
        encryptedEnvs: [],
        storage_fs: '',
        app_id: null,
        kms_enabled: true,
        local_key_provider_enabled: false,
        key_provider_id: '',
        gateway_enabled: true,
        public_logs: true,
        public_sysinfo: true,
        public_tcbinfo: true,
        no_tee: false,
        pin_numa: false,
        hugepages: false,
        user_config: '',
        kms_urls: [],
        gateway_urls: [],
        stopped: false,
    };
}
function createUpdateDialogState() {
    return {
        show: false,
        vm: null,
        updateCompose: false,
        dockerComposeFile: '',
        preLaunchScript: '',
        encryptedEnvs: [],
        resetSecrets: false,
        vcpu: 0,
        memory: 0,
        memoryValue: 0,
        memoryUnit: 'MB',
        swap_size: 0,
        swapValue: 0,
        swapUnit: 'GB',
        disk_size: 0,
        image: '',
        ports: [],
        attachAllGpus: false,
        selectedGpus: [],
        updateGpuConfig: false,
        user_config: '',
    };
}
function createCloneConfigDialogState() {
    return {
        show: false,
        name: '',
        compose_file: '',
        image: '',
        vcpu: 0,
        memory: 0,
        disk_size: 0,
        ports: [],
        user_config: '',
        gpus: undefined,
        kms_urls: undefined,
        gateway_urls: undefined,
        hugepages: false,
        pin_numa: false,
        no_tee: false,
        encrypted_env: undefined,
        app_id: undefined,
        stopped: false,
    };
}
function useVmManager() {
    const version = ref({ version: '-', commit: '' });
    const vms = ref([]);
    const expandedVMs = ref(new Set());
    const networkInfo = ref({});
    const searchQuery = ref('');
    const currentPage = ref(1);
    const pageInput = ref(1);
    const pageSize = ref(Number.parseInt(localStorage.getItem('pageSize') || '50', 10));
    const totalVMs = ref(0);
    const hasMorePages = ref(false);
    const loadingVMDetails = ref(false);
    const maxPage = computed(() => Math.ceil(totalVMs.value / pageSize.value) || 1);
    const preLaunchScript = `
EXPECTED_TOKEN_HASH=$(jq -j .launch_token_hash app-compose.json)
if [ "$EXPECTED_TOKEN_HASH" == "null" ]; then
    echo "Skipped APP_LAUNCH_TOKEN check"
else
  ACTUAL_TOKEN_HASH=$(echo -n "$APP_LAUNCH_TOKEN" | sha256sum | cut -d' ' -f1)
  if [ "$EXPECTED_TOKEN_HASH" != "$ACTUAL_TOKEN_HASH" ]; then
      echo "Error: Incorrect APP_LAUNCH_TOKEN, please make sure set the correct APP_LAUNCH_TOKEN in env"
      reboot
      exit 1
  else
      echo "APP_LAUNCH_TOKEN checked OK"
  fi
fi
`;
    const vmForm = ref(createVmFormState(preLaunchScript));
    const availableImages = ref([]);
    const availableGpus = ref([]);
    const availableGpuProducts = ref([]);
    const allowAttachAllGpus = ref(false);
    const updateDialog = ref(createUpdateDialogState());
    const updateMessage = ref('');
    const successMessage = ref('');
    const errorMessage = ref('');
    const cloneConfigDialog = ref(createCloneConfigDialogState());
    const showCreateDialog = ref(false);
    const config = ref({ portMappingEnabled: false });
    const composeHashPreview = ref('');
    const updateComposeHashPreview = ref('');
    const BYTES_PER_MB = 1024 * 1024;
    function convertMemoryToMB(value, unit) {
        if (!Number.isFinite(value) || value < 0) {
            return 0;
        }
        if (unit === 'GB') {
            return value * 1024;
        }
        return value;
    }
    function convertSwapToBytes(value, unit) {
        const mb = convertMemoryToMB(value, unit);
        if (!Number.isFinite(mb) || mb <= 0) {
            return 0;
        }
        return Math.max(0, Math.round(mb * BYTES_PER_MB));
    }
    function bytesToMB(bytes) {
        if (!bytes) {
            return 0;
        }
        return bytes / BYTES_PER_MB;
    }
    function hexToBytes(hex) {
        if (!hex) {
            return new Uint8Array();
        }
        const normalized = hex.startsWith('0x') ? hex.slice(2) : hex;
        const length = Math.floor(normalized.length / 2);
        const result = new Uint8Array(length);
        for (let i = 0; i < length; i += 1) {
            const byte = normalized.slice(i * 2, i * 2 + 2);
            result[i] = Number.parseInt(byte, 16);
        }
        return result;
    }
    const clonePortMappings = (ports = []) => ports.map((port) => ({
        protocol: port.protocol || 'tcp',
        host_address: port.host_address || '127.0.0.1',
        host_port: typeof port.host_port === 'number' ? port.host_port : null,
        vm_port: typeof port.vm_port === 'number' ? port.vm_port : null,
    }));
    const normalizePorts = (ports = []) => ports
        .map((port) => {
        const protocol = (port.protocol || '').trim();
        const hostPort = port.host_port === null || port.host_port === undefined ? Number.NaN : Number(port.host_port);
        const vmPort = port.vm_port === null || port.vm_port === undefined ? Number.NaN : Number(port.vm_port);
        return {
            protocol,
            host_address: (port.host_address || '127.0.0.1').trim() || '127.0.0.1',
            host_port: hostPort,
            vm_port: vmPort,
        };
    })
        .filter((port) => port.protocol.length > 0 &&
        Number.isFinite(port.host_port) &&
        Number.isFinite(port.vm_port))
        .map((port) => ({
        protocol: port.protocol,
        host_address: port.host_address,
        host_port: port.host_port,
        vm_port: port.vm_port,
    }));
    function deriveGpuSelection(gpuConfig) {
        if (!gpuConfig) {
            return { attachAll: false, selected: [] };
        }
        if (gpuConfig.attach_mode === 'all') {
            return { attachAll: true, selected: [] };
        }
        return {
            attachAll: false,
            selected: (gpuConfig.gpus || []).map((gpu) => gpu.slot).filter(Boolean),
        };
    }
    function recordError(context, err) {
        console.error(context, err);
        if (err instanceof Error && err.message) {
            errorMessage.value = err.message;
        }
        else {
            errorMessage.value = String(err);
        }
    }
    function configGpu(form) {
        if (form.attachAllGpus) {
            return { attach_mode: 'all' };
        }
        if (form.selectedGpus && form.selectedGpus.length > 0) {
            return {
                attach_mode: 'listed',
                gpus: form.selectedGpus.map((slot) => ({ slot })),
            };
        }
        return undefined;
    }
    function buildCreateVmPayload(source) {
        var _a, _b, _c, _d, _e;
        const normalizedPorts = normalizePorts(source.ports);
        return {
            name: source.name.trim(),
            image: source.image.trim(),
            compose_file: source.compose_file,
            vcpu: Math.max(1, Number(source.vcpu) || 1),
            memory: Math.max(0, Number(source.memory) || 0),
            disk_size: Math.max(0, Number(source.disk_size) || 0),
            ports: normalizedPorts,
            encrypted_env: source.encrypted_env,
            app_id: source.app_id || undefined,
            user_config: source.user_config || '',
            hugepages: !!source.hugepages,
            pin_numa: !!source.pin_numa,
            no_tee: (_a = source.no_tee) !== null && _a !== void 0 ? _a : false,
            gpus: source.gpus,
            kms_urls: (_c = (_b = source.kms_urls) === null || _b === void 0 ? void 0 : _b.filter((url) => url && url.trim().length)) !== null && _c !== void 0 ? _c : [],
            gateway_urls: (_e = (_d = source.gateway_urls) === null || _d === void 0 ? void 0 : _d.filter((url) => url && url.trim().length)) !== null && _e !== void 0 ? _e : [],
            stopped: !!source.stopped,
        };
    }
    const autoMemoryDisplay = (mb) => {
        if (mb >= 1024) {
            return {
                memoryValue: Number((mb / 1024).toFixed(1)),
                memoryUnit: 'GB',
            };
        }
        return {
            memoryValue: mb,
            memoryUnit: 'MB',
        };
    };
    watch([() => vmForm.value.memoryValue, () => vmForm.value.memoryUnit], () => {
        vmForm.value.memory = convertMemoryToMB(vmForm.value.memoryValue, vmForm.value.memoryUnit);
    });
    watch([() => vmForm.value.swapValue, () => vmForm.value.swapUnit], () => {
        vmForm.value.swap_size = convertSwapToBytes(vmForm.value.swapValue, vmForm.value.swapUnit);
    });
    watch([() => updateDialog.value.memoryValue, () => updateDialog.value.memoryUnit], () => {
        updateDialog.value.memory = convertMemoryToMB(updateDialog.value.memoryValue, updateDialog.value.memoryUnit);
    });
    watch([() => updateDialog.value.swapValue, () => updateDialog.value.swapUnit], () => {
        updateDialog.value.swap_size = convertSwapToBytes(updateDialog.value.swapValue, updateDialog.value.swapUnit);
    });
    function makeBaseUrl(pathname) {
        return `${pathname}?json`;
    }
    async function baseRpcCall(pathname, params = {}) {
        const response = await fetch(makeBaseUrl(pathname), {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(params),
        });
        if (!response.ok) {
            const error = await response.text();
            errorMessage.value = error;
            throw new Error(error);
        }
        return response;
    }
    const guestRpcCall = (method, params) => baseRpcCall(`/guest/${method}`, params);
    async function loadVMList() {
        try {
            const request = {
                brief: true,
                keyword: searchQuery.value || undefined,
                page: currentPage.value,
                page_size: pageSize.value,
            };
            const data = await vmmRpc.status(request);
            totalVMs.value = data.total || data.vms.length;
            hasMorePages.value = data.vms.length === pageSize.value && totalVMs.value > currentPage.value * pageSize.value;
            const previousVmMap = new Map(vms.value.map((vmItem) => [vmItem.id, vmItem]));
            vms.value = data.vms.map((vm) => {
                const previousVm = previousVmMap.get(vm.id);
                if (previousVm) {
                    return {
                        ...vm,
                        configuration: previousVm.configuration,
                        appCompose: previousVm.appCompose,
                    };
                }
                return vm;
            });
            config.value = { portMappingEnabled: data.port_mapping_enabled };
            if (expandedVMs.value.size > 0) {
                await refreshExpandedVMs();
            }
        }
        catch (error) {
            recordError('error loading vm list', error);
        }
    }
    async function refreshExpandedVMs() {
        try {
            for (const vmId of Array.from(expandedVMs.value.values())) {
                await loadVMDetails(vmId);
            }
        }
        catch (error) {
            recordError('Error refreshing expanded VMs', error);
        }
    }
    async function loadVMDetails(vmId) {
        loadingVMDetails.value = true;
        try {
            const data = await vmmRpc.status({
                brief: false,
                ids: [vmId],
            });
            if (data.vms && data.vms.length > 0) {
                const detailedVM = data.vms[0];
                const appCompose = (() => {
                    var _a;
                    try {
                        return JSON.parse(((_a = detailedVM.configuration) === null || _a === void 0 ? void 0 : _a.compose_file) || '{}');
                    }
                    catch (err) {
                        console.error('Error parsing app config:', err);
                        return {};
                    }
                })();
                const index = vms.value.findIndex((vmItem) => vmItem.id === vmId);
                if (index !== -1) {
                    vms.value[index] = { ...detailedVM, appCompose };
                }
            }
        }
        catch (error) {
            recordError(`Error loading details for VM ${vmId}`, error);
        }
        finally {
            loadingVMDetails.value = false;
        }
    }
    async function ensureVmDetails(vm) {
        var _a;
        if (((_a = vm.configuration) === null || _a === void 0 ? void 0 : _a.compose_file) && vm.appCompose) {
            return vm;
        }
        await loadVMDetails(vm.id);
        return vms.value.find((item) => item.id === vm.id) || null;
    }
    async function loadImages() {
        try {
            const data = await vmmRpc.listImages({});
            availableImages.value = data.images || [];
        }
        catch (error) {
            recordError('error loading images', error);
        }
    }
    async function loadGpus() {
        try {
            const data = await vmmRpc.listGpus({});
            const gpus = data.gpus || [];
            availableGpus.value = gpus;
            availableGpuProducts.value = [];
            allowAttachAllGpus.value = data.allow_attach_all;
            for (const gpu of gpus) {
                if (!availableGpuProducts.value.find((product) => product.product_id === gpu.product_id)) {
                    availableGpuProducts.value.push(gpu);
                }
            }
        }
        catch (error) {
            recordError('error loading GPUs', error);
        }
    }
    async function loadVersion() {
        const data = await vmmRpc.version({});
        version.value = data;
    }
    const imageVersion = (imageName) => {
        const image = availableImages.value.find((img) => img.name === imageName);
        return image === null || image === void 0 ? void 0 : image.version;
    };
    const verGE = (versionStr, otherVersionStr) => {
        const versionParts = versionStr.split('.').map(Number);
        const otherParts = otherVersionStr.split('.').map(Number);
        return (versionParts[0] > otherParts[0] ||
            (versionParts[0] === otherParts[0] && versionParts[1] > otherParts[1]) ||
            (versionParts[0] === otherParts[0] && versionParts[1] === otherParts[1] && versionParts[2] >= otherParts[2]));
    };
    const imageVersionFeatures = (versionStr) => {
        const features = {
            progress: false,
            graceful_shutdown: false,
            network_info: false,
            compose_version: 1,
        };
        if (!versionStr) {
            return features;
        }
        if (verGE(versionStr, '0.3.3')) {
            features.progress = true;
            features.graceful_shutdown = true;
            features.network_info = true;
            features.compose_version = 2;
        }
        if (verGE(versionStr, '0.4.2')) {
            features.compose_version = 3;
        }
        return features;
    };
    const imageFeatures = (vm) => imageVersionFeatures(vm.image_version);
    const vmStatus = (vm) => {
        const features = imageFeatures(vm);
        if (!features.progress) {
            return vm.status;
        }
        if (vm.status !== 'running') {
            return vm.status;
        }
        if (vm.shutdown_progress) {
            return 'shutting down';
        }
        if (vm.boot_progress === 'running') {
            return 'running';
        }
        if (vm.boot_progress !== 'done') {
            return 'booting';
        }
        return 'running';
    };
    const kmsEnabled = (vm) => { var _a, _b, _c; return ((_a = vm.appCompose) === null || _a === void 0 ? void 0 : _a.kms_enabled) || ((_c = (_b = vm.appCompose) === null || _b === void 0 ? void 0 : _b.features) === null || _c === void 0 ? void 0 : _c.includes('kms')); };
    const gatewayEnabled = (vm) => { var _a, _b, _c, _d; return ((_a = vm.appCompose) === null || _a === void 0 ? void 0 : _a.gateway_enabled) || ((_b = vm.appCompose) === null || _b === void 0 ? void 0 : _b.tproxy_enabled) || ((_d = (_c = vm.appCompose) === null || _c === void 0 ? void 0 : _c.features) === null || _d === void 0 ? void 0 : _d.includes('tproxy-net')); };
    const defaultTrue = (v) => (v === undefined ? true : v);
    function formatMemory(memoryMB) {
        if (!memoryMB) {
            return '0 MB';
        }
        if (memoryMB >= 1024) {
            const gbValue = (memoryMB / 1024).toFixed(1);
            return `${parseFloat(gbValue)} GB`;
        }
        return `${memoryMB} MB`;
    }
    async function calcComposeHash(appCompose) {
        const buffer = new TextEncoder().encode(appCompose);
        const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
        return Array.from(new Uint8Array(hashBuffer))
            .map((b) => b.toString(16).padStart(2, '0'))
            .join('');
    }
    async function makeAppComposeFile() {
        var _a;
        const appCompose = {
            manifest_version: 2,
            name: vmForm.value.name,
            runner: 'docker-compose',
            docker_compose_file: vmForm.value.dockerComposeFile,
            kms_enabled: vmForm.value.kms_enabled,
            gateway_enabled: vmForm.value.gateway_enabled,
            public_logs: vmForm.value.public_logs,
            public_sysinfo: vmForm.value.public_sysinfo,
            public_tcbinfo: vmForm.value.public_tcbinfo,
            local_key_provider_enabled: vmForm.value.local_key_provider_enabled,
            key_provider_id: vmForm.value.key_provider_id,
            allowed_envs: vmForm.value.encryptedEnvs.map((env) => env.key),
            no_instance_id: !vmForm.value.gateway_enabled,
            secure_time: false,
        };
        if (vmForm.value.storage_fs) {
            appCompose.storage_fs = vmForm.value.storage_fs;
        }
        if ((_a = vmForm.value.preLaunchScript) === null || _a === void 0 ? void 0 : _a.trim()) {
            appCompose.pre_launch_script = vmForm.value.preLaunchScript;
        }
        const swapBytes = Math.max(0, Math.round(vmForm.value.swap_size || 0));
        if (swapBytes > 0) {
            appCompose.swap_size = swapBytes;
        }
        const launchToken = vmForm.value.encryptedEnvs.find((env) => env.key === 'APP_LAUNCH_TOKEN');
        if (launchToken) {
            appCompose.launch_token_hash = await calcComposeHash(launchToken.value);
        }
        const imgFeatures = imageVersionFeatures(imageVersion(vmForm.value.image));
        if (imgFeatures.compose_version < 2) {
            const features = [];
            if (vmForm.value.kms_enabled)
                features.push('kms');
            if (vmForm.value.gateway_enabled)
                features.push('tproxy-net');
            appCompose.features = features;
            appCompose.manifest_version = 1;
            appCompose.version = '1.0.0';
        }
        if (imgFeatures.compose_version < 3) {
            appCompose.tproxy_enabled = appCompose.gateway_enabled;
            delete appCompose.gateway_enabled;
        }
        return JSON.stringify(appCompose);
    }
    async function makeUpdateComposeFile() {
        var _a;
        const currentAppCompose = updateDialog.value.vm.appCompose;
        const appCompose = {
            ...currentAppCompose,
            docker_compose_file: updateDialog.value.dockerComposeFile || currentAppCompose.docker_compose_file,
        };
        if (updateDialog.value.resetSecrets) {
            // Update allowed_envs with the new environment variable keys
            appCompose.allowed_envs = updateDialog.value.encryptedEnvs.map(env => env.key);
            const launchToken = updateDialog.value.encryptedEnvs.find((env) => env.key === 'APP_LAUNCH_TOKEN');
            if (launchToken) {
                appCompose.launch_token_hash = await calcComposeHash(launchToken.value);
            }
        }
        appCompose.pre_launch_script = (_a = updateDialog.value.preLaunchScript) === null || _a === void 0 ? void 0 : _a.trim();
        const swapBytes = Math.max(0, Math.round(updateDialog.value.swap_size || 0));
        if (swapBytes > 0) {
            appCompose.swap_size = swapBytes;
        }
        else {
            delete appCompose.swap_size;
        }
        return JSON.stringify(appCompose);
    }
    watch([
        () => vmForm.value.name,
        () => vmForm.value.dockerComposeFile,
        () => vmForm.value.preLaunchScript,
        () => vmForm.value.kms_enabled,
        () => vmForm.value.gateway_enabled,
        () => vmForm.value.public_logs,
        () => vmForm.value.public_sysinfo,
        () => vmForm.value.public_tcbinfo,
        () => vmForm.value.local_key_provider_enabled,
        () => vmForm.value.key_provider_id,
        () => vmForm.value.encryptedEnvs,
        () => vmForm.value.storage_fs,
    ], async () => {
        try {
            const appCompose = await makeAppComposeFile();
            composeHashPreview.value = await calcComposeHash(appCompose);
        }
        catch (error) {
            composeHashPreview.value = 'Error calculating hash';
            console.error('Failed to calculate compose hash', error);
        }
    }, { deep: true });
    watch([
        () => updateDialog.value.dockerComposeFile,
        () => updateDialog.value.preLaunchScript,
        () => updateDialog.value.encryptedEnvs,
    ], async () => {
        if (!updateDialog.value.updateCompose) {
            updateComposeHashPreview.value = '';
            return;
        }
        try {
            const upgradedCompose = await makeUpdateComposeFile();
            updateComposeHashPreview.value = await calcComposeHash(upgradedCompose);
        }
        catch (error) {
            updateComposeHashPreview.value = 'Error calculating hash';
            console.error('Failed to calculate compose hash', error);
        }
    }, { deep: true });
    watch(pageSize, (newValue) => {
        localStorage.setItem('pageSize', String(newValue));
    });
    function showDeployDialog() {
        showCreateDialog.value = true;
        vmForm.value.encryptedEnvs = [];
        vmForm.value.app_id = null;
        vmForm.value.swapValue = 0;
        vmForm.value.swapUnit = 'GB';
        vmForm.value.swap_size = 0;
        loadGpus();
    }
    async function showUpdateDialog(vm) {
        var _a, _b, _c;
        const detailedVm = await ensureVmDetails(vm);
        if (!((_a = detailedVm === null || detailedVm === void 0 ? void 0 : detailedVm.configuration) === null || _a === void 0 ? void 0 : _a.compose_file) || !detailedVm.appCompose) {
            alert('Compose file not available for this VM. Please expand its details first.');
            return;
        }
        const config = detailedVm.configuration;
        const memoryDisplay = autoMemoryDisplay(config.memory || 0);
        const swapDisplay = autoMemoryDisplay(bytesToMB(((_b = detailedVm.appCompose) === null || _b === void 0 ? void 0 : _b.swap_size) || 0));
        const gpuSelection = deriveGpuSelection(config.gpus);
        updateDialog.value = {
            show: true,
            vm: detailedVm,
            updateCompose: false,
            dockerComposeFile: detailedVm.appCompose.docker_compose_file || '',
            preLaunchScript: detailedVm.appCompose.pre_launch_script || '',
            encryptedEnvs: [],
            resetSecrets: false,
            vcpu: config.vcpu || 0,
            memory: config.memory || 0,
            memoryValue: memoryDisplay.memoryValue,
            memoryUnit: memoryDisplay.memoryUnit,
            swap_size: ((_c = detailedVm.appCompose) === null || _c === void 0 ? void 0 : _c.swap_size) || 0,
            swapValue: swapDisplay.memoryValue,
            swapUnit: swapDisplay.memoryUnit,
            disk_size: config.disk_size || 0,
            image: config.image || '',
            ports: clonePortMappings(config.ports || []),
            attachAllGpus: gpuSelection.attachAll,
            selectedGpus: gpuSelection.selected,
            updateGpuConfig: false,
            user_config: config.user_config || '',
        };
    }
    function parseEnvFile(content) {
        const lines = content
            .split('\n')
            .map((line) => line.trim())
            .filter((line) => line && !line.startsWith('#'));
        const envs = {};
        for (const line of lines) {
            const [key, ...parts] = line.split('=');
            if (!key || parts.length === 0) {
                continue;
            }
            envs[key.trim()] = parts.join('=').trim();
        }
        return envs;
    }
    async function calcAppId(compose) {
        const composeHash = await calcComposeHash(compose);
        return composeHash.slice(0, 40);
    }
    async function encryptEnv(envs, kmsEnabled, appId) {
        if (!kmsEnabled || envs.length === 0) {
            return undefined;
        }
        let appIdToUse = appId;
        if (!appIdToUse) {
            const appCompose = await makeAppComposeFile();
            appIdToUse = await calcAppId(appCompose);
        }
        const keyBytes = hexToBytes(appIdToUse);
        const response = await vmmRpc.getAppEnvEncryptPubKey({ app_id: keyBytes });
        return encryptEnvWithKey(envs, response.public_key);
    }
    async function encryptEnvWithKey(envs, publicKeyBytes) {
        const envsJson = JSON.stringify({ env: envs });
        const remotePubkey = publicKeyBytes && publicKeyBytes.length ? publicKeyBytes : new Uint8Array();
        const seed = crypto.getRandomValues(new Uint8Array(32));
        const keyPair = x25519.generateKeyPair(seed);
        const shared = x25519.sharedKey(keyPair.private, remotePubkey);
        const importedShared = await crypto.subtle.importKey('raw', shared, { name: 'AES-GCM', length: 256 }, true, ['encrypt']);
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const encrypted = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, importedShared, new TextEncoder().encode(envsJson));
        const result = new Uint8Array(iv.length + keyPair.public.byteLength + encrypted.byteLength);
        result.set(keyPair.public, 0);
        result.set(iv, keyPair.public.byteLength);
        result.set(new Uint8Array(encrypted), keyPair.public.byteLength + iv.length);
        return result;
    }
    async function createVm() {
        try {
            vmForm.value.memory = convertMemoryToMB(vmForm.value.memoryValue, vmForm.value.memoryUnit);
            const composeFile = await makeAppComposeFile();
            const encryptedEnv = await encryptEnv(vmForm.value.encryptedEnvs, vmForm.value.kms_enabled, vmForm.value.app_id);
            const payload = buildCreateVmPayload({
                name: vmForm.value.name,
                image: vmForm.value.image,
                compose_file: composeFile,
                vcpu: vmForm.value.vcpu,
                memory: vmForm.value.memory,
                disk_size: vmForm.value.disk_size,
                ports: vmForm.value.ports,
                encrypted_env: encryptedEnv || undefined,
                app_id: vmForm.value.app_id || undefined,
                user_config: vmForm.value.user_config,
                hugepages: vmForm.value.hugepages,
                pin_numa: vmForm.value.pin_numa,
                no_tee: vmForm.value.no_tee,
                gpus: configGpu(vmForm.value) || undefined,
                kms_urls: vmForm.value.kms_urls,
                gateway_urls: vmForm.value.gateway_urls,
                stopped: vmForm.value.stopped,
            });
            await vmmRpc.createVm(payload);
            leaveCreateDialog();
            loadVMList();
        }
        catch (error) {
            recordError('Error creating VM', error);
            alert('Failed to create VM');
        }
    }
    function leaveCreateDialog() {
        showCreateDialog.value = false;
    }
    function loadComposeFile(event) {
        var _a;
        const input = event.target;
        const file = (_a = input === null || input === void 0 ? void 0 : input.files) === null || _a === void 0 ? void 0 : _a[0];
        if (!file) {
            return;
        }
        const reader = new FileReader();
        reader.onload = (e) => {
            vmForm.value.dockerComposeFile = e.target.result;
        };
        reader.readAsText(file);
        if (input) {
            input.value = '';
        }
    }
    function loadUpdateFile(event) {
        var _a;
        const input = event.target;
        const file = (_a = input === null || input === void 0 ? void 0 : input.files) === null || _a === void 0 ? void 0 : _a[0];
        if (!file) {
            return;
        }
        const reader = new FileReader();
        reader.onload = (e) => {
            updateDialog.value.dockerComposeFile = e.target.result;
        };
        reader.readAsText(file);
        if (input) {
            input.value = '';
        }
    }
    async function updateVM() {
        try {
            const vm = updateDialog.value.vm;
            const original = vm.configuration;
            const updated = updateDialog.value;
            const body = {
                id: vm.id,
            };
            const fieldsToCompare = ['vcpu', 'memory', 'disk_size', 'image'];
            if (fieldsToCompare.some((field) => updated[field] !== original[field])) {
                body.vcpu = updated.vcpu;
                body.memory = updated.memory;
                body.disk_size = updated.disk_size;
                body.image = updated.image;
            }
            const composeWasExplicitlyUpdated = updateDialog.value.updateCompose;
            let composeNeedsUpdate = composeWasExplicitlyUpdated;
            let encryptedEnvPayload;
            if (updateDialog.value.resetSecrets) {
                const keyResponse = await vmmRpc.getAppEnvEncryptPubKey({ app_id: hexToBytes(vm.app_id || '') });
                encryptedEnvPayload = await encryptEnvWithKey(updateDialog.value.encryptedEnvs, keyResponse.public_key);
                composeNeedsUpdate = true;
            }
            body.compose_file = composeNeedsUpdate ? await makeUpdateComposeFile() : undefined;
            body.encrypted_env = encryptedEnvPayload;
            body.user_config = updated.user_config;
            body.update_ports = true;
            body.ports = normalizePorts(updated.ports);
            body.gpus = updateDialog.value.updateGpuConfig ? configGpu(updated) : undefined;
            await vmmRpc.updateVm(body);
            updateDialog.value.encryptedEnvs = [];
            updateDialog.value.show = false;
            if (composeWasExplicitlyUpdated) {
                updateMessage.value = '✅ Compose file updated!';
            }
            loadVMList();
        }
        catch (error) {
            recordError('error upgrading VM', error);
            alert('failed to upgrade VM');
        }
    }
    async function showCloneConfig(vm) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        const theVm = await ensureVmDetails(vm);
        if (!((_a = theVm === null || theVm === void 0 ? void 0 : theVm.configuration) === null || _a === void 0 ? void 0 : _a.compose_file)) {
            alert('Compose file not available for this VM. Please open its details first.');
            return;
        }
        const config = theVm.configuration;
        // Populate vmForm with current VM data, but clear envs and ports
        vmForm.value = {
            name: `${config.name || vm.name}-cloned`,
            image: config.image || '',
            dockerComposeFile: ((_b = theVm.appCompose) === null || _b === void 0 ? void 0 : _b.docker_compose_file) || '',
            preLaunchScript: ((_c = theVm.appCompose) === null || _c === void 0 ? void 0 : _c.pre_launch_script) || '',
            vcpu: config.vcpu || 1,
            memory: config.memory || 0,
            memoryValue: autoMemoryDisplay(config.memory || 0).memoryValue,
            memoryUnit: autoMemoryDisplay(config.memory || 0).memoryUnit,
            swap_size: ((_d = theVm.appCompose) === null || _d === void 0 ? void 0 : _d.swap_size) || 0,
            swapValue: autoMemoryDisplay(bytesToMB(((_e = theVm.appCompose) === null || _e === void 0 ? void 0 : _e.swap_size) || 0)).memoryValue,
            swapUnit: autoMemoryDisplay(bytesToMB(((_f = theVm.appCompose) === null || _f === void 0 ? void 0 : _f.swap_size) || 0)).memoryUnit,
            disk_size: config.disk_size || 0,
            selectedGpus: [],
            attachAllGpus: false,
            encryptedEnvs: [], // Clear environment variables
            ports: [], // Clear port mappings
            storage_fs: ((_g = theVm.appCompose) === null || _g === void 0 ? void 0 : _g.storage_fs) || 'ext4',
            app_id: config.app_id || '',
            kms_enabled: !!((_h = theVm.appCompose) === null || _h === void 0 ? void 0 : _h.kms_enabled),
            kms_urls: config.kms_urls || [],
            local_key_provider_enabled: !!((_j = theVm.appCompose) === null || _j === void 0 ? void 0 : _j.local_key_provider_enabled),
            key_provider_id: ((_k = theVm.appCompose) === null || _k === void 0 ? void 0 : _k.key_provider_id) || '',
            gateway_enabled: !!((_l = theVm.appCompose) === null || _l === void 0 ? void 0 : _l.gateway_enabled),
            gateway_urls: config.gateway_urls || [],
            public_logs: !!((_m = theVm.appCompose) === null || _m === void 0 ? void 0 : _m.public_logs),
            public_sysinfo: !!((_o = theVm.appCompose) === null || _o === void 0 ? void 0 : _o.public_sysinfo),
            public_tcbinfo: !!((_p = theVm.appCompose) === null || _p === void 0 ? void 0 : _p.public_tcbinfo),
            pin_numa: !!config.pin_numa,
            hugepages: !!config.hugepages,
            no_tee: !!config.no_tee,
            user_config: config.user_config || '',
            stopped: !!config.stopped,
        };
        // Show Create VM dialog instead of Clone Config dialog
        showCreateDialog.value = true;
    }
    async function cloneConfig() {
        try {
            const source = cloneConfigDialog.value;
            if (!source.compose_file) {
                alert('Compose file not available for this VM. Please open its details first.');
                return;
            }
            const payload = buildCreateVmPayload({
                name: source.name,
                image: source.image,
                compose_file: source.compose_file,
                vcpu: source.vcpu,
                memory: source.memory,
                disk_size: source.disk_size,
                ports: source.ports,
                encrypted_env: source.encrypted_env,
                app_id: source.app_id,
                user_config: source.user_config,
                hugepages: source.hugepages,
                pin_numa: source.pin_numa,
                no_tee: source.no_tee,
                gpus: source.gpus,
                kms_urls: source.kms_urls,
                gateway_urls: source.gateway_urls,
                stopped: source.stopped,
            });
            await vmmRpc.createVm(payload);
            cloneConfigDialog.value.show = false;
            loadVMList();
        }
        catch (error) {
            recordError('Error creating VM', error);
            alert('Failed to create VM');
        }
    }
    function toggleDetails(vm) {
        if (expandedVMs.value.has(vm.id)) {
            expandedVMs.value.delete(vm.id);
        }
        else {
            // Close all other expanded VMs
            expandedVMs.value.clear();
            expandedVMs.value.add(vm.id);
            loadVMDetails(vm.id);
            refreshNetworkInfo(vm);
        }
    }
    async function refreshNetworkInfo(vm) {
        if (vm.status !== 'running' || !imageFeatures(vm).network_info) {
            return;
        }
        const response = await guestRpcCall('NetworkInfo', { id: vm.id });
        const data = await response.json();
        networkInfo.value[vm.id] = data;
    }
    function nextPage() {
        if (hasMorePages.value) {
            currentPage.value += 1;
            pageInput.value = currentPage.value;
            loadVMList();
        }
    }
    function prevPage() {
        if (currentPage.value > 1) {
            currentPage.value -= 1;
            pageInput.value = currentPage.value;
            loadVMList();
        }
    }
    function goToPage() {
        let page = Number.parseInt(String(pageInput.value), 10);
        if (Number.isNaN(page) || page < 1) {
            page = 1;
        }
        else if (page > maxPage.value) {
            page = maxPage.value;
        }
        pageInput.value = page;
        currentPage.value = page;
        loadVMList();
    }
    function closeAllDropdowns() {
        document.querySelectorAll('.dropdown-content').forEach((dropdown) => dropdown.classList.remove('show'));
        systemMenu.value.show = false;
        document.removeEventListener('click', closeAllDropdowns);
    }
    function toggleSystemMenu(event) {
        event.stopPropagation();
        systemMenu.value.show = !systemMenu.value.show;
        // Close all other dropdowns
        document.querySelectorAll('.dropdown-content').forEach((dropdown) => {
            dropdown.classList.remove('show');
        });
        if (systemMenu.value.show) {
            document.addEventListener('click', closeAllDropdowns);
        }
        else {
            document.removeEventListener('click', closeAllDropdowns);
        }
    }
    function closeSystemMenu() {
        systemMenu.value.show = false;
    }
    function openApiDocs() {
        closeSystemMenu();
        window.open('/api-docs/docs', '_blank', 'noopener');
    }
    function openLegacyUi() {
        closeSystemMenu();
        window.open('/v0', '_blank', 'noopener');
    }
    function shortUptime(uptime) {
        if (!uptime) {
            return '-';
        }
        const parts = uptime.split(/\s+/).filter(Boolean);
        if (parts.length === 0) {
            return uptime;
        }
        return parts.slice(0, Math.min(2, parts.length)).join(' ');
    }
    function toggleDevMode() {
        devMode.value = !devMode.value;
        localStorage.setItem('devMode', devMode.value ? 'true' : 'false');
        closeSystemMenu();
        successMessage.value = devMode.value ? '✅ Dev mode enabled' : 'Dev mode disabled';
        setTimeout(() => {
            successMessage.value = '';
        }, 2000);
    }
    async function reloadVMs() {
        try {
            errorMessage.value = '';
            successMessage.value = '';
            const response = await vmmRpc.reloadVms({});
            // Show success message with statistics
            if (response.loaded > 0 || response.updated > 0 || response.removed > 0) {
                let message = 'VM reload completed: ';
                const parts = [];
                if (response.loaded > 0)
                    parts.push(`${response.loaded} loaded`);
                if (response.updated > 0)
                    parts.push(`${response.updated} updated`);
                if (response.removed > 0)
                    parts.push(`${response.removed} removed`);
                successMessage.value = message + parts.join(', ');
            }
            else {
                successMessage.value = 'VM reload completed: no changes detected';
            }
            // Reload the VM list to show updated data
            await loadVMList();
            // Hide message after 5 seconds
            setTimeout(() => {
                successMessage.value = '';
            }, 5000);
        }
        catch (error) {
            console.error('Failed to reload VMs:', error);
            errorMessage.value = `Failed to reload VMs: ${error.message || error.toString()}`;
            // Hide error message after 10 seconds
            setTimeout(() => {
                errorMessage.value = '';
            }, 10000);
        }
    }
    function toggleDropdown(event, vm) {
        document.querySelectorAll('.dropdown-content').forEach((dropdown) => {
            if (dropdown.id !== `dropdown-${vm.id}`) {
                dropdown.classList.remove('show');
            }
        });
        const dropdownContent = document.getElementById(`dropdown-${vm.id}`);
        dropdownContent === null || dropdownContent === void 0 ? void 0 : dropdownContent.classList.toggle('show');
        event.stopPropagation();
        document.addEventListener('click', closeAllDropdowns);
    }
    function onPageSizeChange() {
        currentPage.value = 1;
        pageInput.value = 1;
        loadVMList();
    }
    async function startVm(id) {
        try {
            await vmmRpc.startVm({ id });
            loadVMList();
        }
        catch (error) {
            recordError('Failed to start VM', error);
        }
    }
    async function shutdownVm(id) {
        try {
            await vmmRpc.shutdownVm({ id });
            loadVMList();
        }
        catch (error) {
            recordError('Failed to shutdown VM', error);
        }
    }
    const dangerConfirmEnabled = () => !devMode.value;
    async function stopVm(vm) {
        if (dangerConfirmEnabled() &&
            !confirm(`You are killing "${vm.name}". This might cause data corruption.`)) {
            return;
        }
        try {
            await vmmRpc.stopVm({ id: vm.id });
            loadVMList();
        }
        catch (error) {
            recordError(`Failed to stop ${vm.name}`, error);
        }
    }
    async function removeVm(vm) {
        if (dangerConfirmEnabled() &&
            !confirm('Remove VM? This action cannot be undone.')) {
            return;
        }
        try {
            if (devMode.value && vm.status === 'running') {
                try {
                    await vmmRpc.stopVm({ id: vm.id });
                }
                catch (error) {
                    recordError(`Failed to stop ${vm.name} before removal`, error);
                    return;
                }
            }
            await vmmRpc.removeVm({ id: vm.id });
            loadVMList();
        }
        catch (error) {
            recordError(`Failed to remove ${vm.name}`, error);
        }
    }
    function showLogs(id, channel) {
        window.open(`/logs?id=${encodeURIComponent(id)}&follow=true&ansi=false&lines=200&ch=${channel}`, '_blank');
    }
    function showDashboard(vm) {
        if (vm.app_url) {
            window.open(vm.app_url, '_blank');
        }
        else {
            alert('No guest agent dashboard URL');
        }
    }
    async function watchVmList() {
        while (true) {
            try {
                await loadVMList();
            }
            catch (error) {
                recordError('error loading VM list', error);
            }
            await new Promise((resolve) => setTimeout(resolve, 3000));
        }
    }
    async function copyToClipboard(text) {
        try {
            await navigator.clipboard.writeText(text);
            successMessage.value = '✅ Copied to clipboard!';
            setTimeout(() => {
                successMessage.value = '';
            }, 2000);
        }
        catch (error) {
            console.error('Failed to copy to clipboard', error);
            errorMessage.value = 'Failed to copy to clipboard';
            setTimeout(() => {
                errorMessage.value = '';
            }, 3000);
        }
    }
    function downloadFile(filename, content) {
        const blob = new Blob([content], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    }
    function downloadAppCompose(vm) {
        var _a;
        if ((_a = vm.configuration) === null || _a === void 0 ? void 0 : _a.compose_file) {
            downloadFile(`${vm.name}-app-compose.json`, vm.configuration.compose_file);
        }
    }
    function downloadUserConfig(vm) {
        var _a;
        if ((_a = vm.configuration) === null || _a === void 0 ? void 0 : _a.user_config) {
            downloadFile(`${vm.name}-user-config.txt`, vm.configuration.user_config);
        }
    }
    function getVmFeatures(vm) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        const features = [];
        // Check KMS
        const kmsEnabled = ((_a = vm.appCompose) === null || _a === void 0 ? void 0 : _a.kms_enabled) || ((_c = (_b = vm.appCompose) === null || _b === void 0 ? void 0 : _b.features) === null || _c === void 0 ? void 0 : _c.includes('kms')) ||
            ((_e = (_d = vm.configuration) === null || _d === void 0 ? void 0 : _d.kms_urls) === null || _e === void 0 ? void 0 : _e.length) > 0;
        if (kmsEnabled)
            features.push("kms");
        // Check Gateway/TProxy
        const gatewayEnabled = ((_f = vm.appCompose) === null || _f === void 0 ? void 0 : _f.gateway_enabled) || ((_g = vm.appCompose) === null || _g === void 0 ? void 0 : _g.tproxy_enabled) ||
            ((_j = (_h = vm.appCompose) === null || _h === void 0 ? void 0 : _h.features) === null || _j === void 0 ? void 0 : _j.includes('tproxy-net')) || ((_l = (_k = vm.configuration) === null || _k === void 0 ? void 0 : _k.gateway_urls) === null || _l === void 0 ? void 0 : _l.length) > 0;
        if (gatewayEnabled)
            features.push("gateway");
        // Check other features from appCompose
        if ((_m = vm.appCompose) === null || _m === void 0 ? void 0 : _m.public_logs)
            features.push("logs");
        if ((_o = vm.appCompose) === null || _o === void 0 ? void 0 : _o.public_sysinfo)
            features.push("sysinfo");
        if ((_p = vm.appCompose) === null || _p === void 0 ? void 0 : _p.public_tcbinfo)
            features.push("tcbinfo");
        return features.length > 0 ? features.join(', ') : 'None';
    }
    onMounted(() => {
        watchVmList();
        loadImages();
        loadGpus();
        loadVersion();
    });
    return {
        version,
        vms,
        expandedVMs,
        networkInfo,
        searchQuery,
        currentPage,
        pageInput,
        pageSize,
        totalVMs,
        hasMorePages,
        loadingVMDetails,
        maxPage,
        vmForm,
        availableImages,
        availableGpus,
        availableGpuProducts,
        allowAttachAllGpus,
        updateDialog,
        updateMessage,
        successMessage,
        errorMessage,
        cloneConfigDialog,
        showCreateDialog,
        config,
        composeHashPreview,
        updateComposeHashPreview,
        showDeployDialog,
        leaveCreateDialog,
        loadComposeFile,
        loadUpdateFile,
        createVm,
        updateVM,
        cloneConfig,
        loadVMList,
        toggleDetails,
        toggleDropdown,
        closeAllDropdowns,
        showLogs,
        showDashboard,
        stopVm,
        shutdownVm,
        startVm,
        removeVm,
        showUpdateDialog,
        showCloneConfig,
        formatMemory,
        bytesToMB,
        vmStatus,
        kmsEnabled,
        gatewayEnabled,
        goToPage,
        nextPage,
        prevPage,
        onPageSizeChange,
        copyToClipboard,
        downloadAppCompose,
        downloadUserConfig,
        getVmFeatures,
        systemMenu,
        toggleSystemMenu,
        closeSystemMenu,
        openApiDocs,
        openLegacyUi,
        reloadVMs,
        devMode,
        toggleDevMode,
        shortUptime,
    };
}

}, map: {"../lib/x25519.js":"build/ts/lib/x25519.js","../lib/vmmRpcClient":"build/ts/lib/vmmRpcClient.js"} },
'build/ts/lib/x25519.js': { factory: function(module, exports, require) {
// SPDX-FileCopyrightText: © 2016 Dmitry Chestnykh, © 2019 Harvey Connor
// SPDX-License-Identifier: MIT
let _0 = new Uint8Array(16);
let _9 = new Uint8Array(32);
_9[0] = 9;
function gf(init) {
    var i, r = new Float64Array(16);
    if (init)
        for (i = 0; i < init.length; i++)
            r[i] = init[i];
    return r;
}
;
const gf0 = gf(), gf1 = gf([1]), _121665 = gf([0xdb41, 1]), D = gf([
    0x78a3,
    0x1359,
    0x4dca,
    0x75eb,
    0xd8ab,
    0x4141,
    0x0a4d,
    0x0070,
    0xe898,
    0x7779,
    0x4079,
    0x8cc7,
    0xfe73,
    0x2b6f,
    0x6cee,
    0x5203,
]), D2 = gf([
    0xf159,
    0x26b2,
    0x9b94,
    0xebd6,
    0xb156,
    0x8283,
    0x149a,
    0x00e0,
    0xd130,
    0xeef3,
    0x80f2,
    0x198e,
    0xfce7,
    0x56df,
    0xd9dc,
    0x2406,
]), X = gf([
    0xd51a,
    0x8f25,
    0x2d60,
    0xc956,
    0xa7b2,
    0x9525,
    0xc760,
    0x692c,
    0xdc5c,
    0xfdd6,
    0xe231,
    0xc0a4,
    0x53fe,
    0xcd6e,
    0x36d3,
    0x2169,
]), Y = gf([
    0x6658,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
]), I = gf([
    0xa0b0,
    0x4a0e,
    0x1b27,
    0xc4ee,
    0xe478,
    0xad2f,
    0x1806,
    0x2f43,
    0xd7a7,
    0x3dfb,
    0x0099,
    0x2b4d,
    0xdf0b,
    0x4fc1,
    0x2480,
    0x2b83,
]);
function ts64(x, i, h, l) {
    x[i] = (h >> 24) & 0xff;
    x[i + 1] = (h >> 16) & 0xff;
    x[i + 2] = (h >> 8) & 0xff;
    x[i + 3] = h & 0xff;
    x[i + 4] = (l >> 24) & 0xff;
    x[i + 5] = (l >> 16) & 0xff;
    x[i + 6] = (l >> 8) & 0xff;
    x[i + 7] = l & 0xff;
}
function vn(x, xi, y, yi, n) {
    var i, d = 0;
    for (i = 0; i < n; i++)
        d |= x[xi + i] ^ y[yi + i];
    return (1 & ((d - 1) >>> 8)) - 1;
}
function crypto_verify_32(x, xi, y, yi) {
    return vn(x, xi, y, yi, 32);
}
function set25519(r, a) {
    var i;
    for (i = 0; i < 16; i++)
        r[i] = a[i] | 0;
}
function car25519(o) {
    var i, v, c = 1;
    for (i = 0; i < 16; i++) {
        v = o[i] + c + 65535;
        c = Math.floor(v / 65536);
        o[i] = v - c * 65536;
    }
    o[0] += c - 1 + 37 * (c - 1);
}
function sel25519(p, q, b) {
    var t, c = ~(b - 1);
    for (var i = 0; i < 16; i++) {
        t = c & (p[i] ^ q[i]);
        p[i] ^= t;
        q[i] ^= t;
    }
}
function pack25519(o, n) {
    var i, j, b;
    var m = gf(), t = gf();
    for (i = 0; i < 16; i++)
        t[i] = n[i];
    car25519(t);
    car25519(t);
    car25519(t);
    for (j = 0; j < 2; j++) {
        m[0] = t[0] - 0xffed;
        for (i = 1; i < 15; i++) {
            m[i] = t[i] - 0xffff - ((m[i - 1] >> 16) & 1);
            m[i - 1] &= 0xffff;
        }
        m[15] = t[15] - 0x7fff - ((m[14] >> 16) & 1);
        b = (m[15] >> 16) & 1;
        m[14] &= 0xffff;
        sel25519(t, m, 1 - b);
    }
    for (i = 0; i < 16; i++) {
        o[2 * i] = t[i] & 0xff;
        o[2 * i + 1] = t[i] >> 8;
    }
}
function neq25519(a, b) {
    var c = new Uint8Array(32), d = new Uint8Array(32);
    pack25519(c, a);
    pack25519(d, b);
    return crypto_verify_32(c, 0, d, 0);
}
function par25519(a) {
    var d = new Uint8Array(32);
    pack25519(d, a);
    return d[0] & 1;
}
function unpack25519(o, n) {
    var i;
    for (i = 0; i < 16; i++)
        o[i] = n[2 * i] + (n[2 * i + 1] << 8);
    o[15] &= 0x7fff;
}
function A(o, a, b) {
    for (var i = 0; i < 16; i++)
        o[i] = a[i] + b[i];
}
function Z(o, a, b) {
    for (var i = 0; i < 16; i++)
        o[i] = a[i] - b[i];
}
function M(o, a, b) {
    var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
    v = a[0];
    t0 += v * b0;
    t1 += v * b1;
    t2 += v * b2;
    t3 += v * b3;
    t4 += v * b4;
    t5 += v * b5;
    t6 += v * b6;
    t7 += v * b7;
    t8 += v * b8;
    t9 += v * b9;
    t10 += v * b10;
    t11 += v * b11;
    t12 += v * b12;
    t13 += v * b13;
    t14 += v * b14;
    t15 += v * b15;
    v = a[1];
    t1 += v * b0;
    t2 += v * b1;
    t3 += v * b2;
    t4 += v * b3;
    t5 += v * b4;
    t6 += v * b5;
    t7 += v * b6;
    t8 += v * b7;
    t9 += v * b8;
    t10 += v * b9;
    t11 += v * b10;
    t12 += v * b11;
    t13 += v * b12;
    t14 += v * b13;
    t15 += v * b14;
    t16 += v * b15;
    v = a[2];
    t2 += v * b0;
    t3 += v * b1;
    t4 += v * b2;
    t5 += v * b3;
    t6 += v * b4;
    t7 += v * b5;
    t8 += v * b6;
    t9 += v * b7;
    t10 += v * b8;
    t11 += v * b9;
    t12 += v * b10;
    t13 += v * b11;
    t14 += v * b12;
    t15 += v * b13;
    t16 += v * b14;
    t17 += v * b15;
    v = a[3];
    t3 += v * b0;
    t4 += v * b1;
    t5 += v * b2;
    t6 += v * b3;
    t7 += v * b4;
    t8 += v * b5;
    t9 += v * b6;
    t10 += v * b7;
    t11 += v * b8;
    t12 += v * b9;
    t13 += v * b10;
    t14 += v * b11;
    t15 += v * b12;
    t16 += v * b13;
    t17 += v * b14;
    t18 += v * b15;
    v = a[4];
    t4 += v * b0;
    t5 += v * b1;
    t6 += v * b2;
    t7 += v * b3;
    t8 += v * b4;
    t9 += v * b5;
    t10 += v * b6;
    t11 += v * b7;
    t12 += v * b8;
    t13 += v * b9;
    t14 += v * b10;
    t15 += v * b11;
    t16 += v * b12;
    t17 += v * b13;
    t18 += v * b14;
    t19 += v * b15;
    v = a[5];
    t5 += v * b0;
    t6 += v * b1;
    t7 += v * b2;
    t8 += v * b3;
    t9 += v * b4;
    t10 += v * b5;
    t11 += v * b6;
    t12 += v * b7;
    t13 += v * b8;
    t14 += v * b9;
    t15 += v * b10;
    t16 += v * b11;
    t17 += v * b12;
    t18 += v * b13;
    t19 += v * b14;
    t20 += v * b15;
    v = a[6];
    t6 += v * b0;
    t7 += v * b1;
    t8 += v * b2;
    t9 += v * b3;
    t10 += v * b4;
    t11 += v * b5;
    t12 += v * b6;
    t13 += v * b7;
    t14 += v * b8;
    t15 += v * b9;
    t16 += v * b10;
    t17 += v * b11;
    t18 += v * b12;
    t19 += v * b13;
    t20 += v * b14;
    t21 += v * b15;
    v = a[7];
    t7 += v * b0;
    t8 += v * b1;
    t9 += v * b2;
    t10 += v * b3;
    t11 += v * b4;
    t12 += v * b5;
    t13 += v * b6;
    t14 += v * b7;
    t15 += v * b8;
    t16 += v * b9;
    t17 += v * b10;
    t18 += v * b11;
    t19 += v * b12;
    t20 += v * b13;
    t21 += v * b14;
    t22 += v * b15;
    v = a[8];
    t8 += v * b0;
    t9 += v * b1;
    t10 += v * b2;
    t11 += v * b3;
    t12 += v * b4;
    t13 += v * b5;
    t14 += v * b6;
    t15 += v * b7;
    t16 += v * b8;
    t17 += v * b9;
    t18 += v * b10;
    t19 += v * b11;
    t20 += v * b12;
    t21 += v * b13;
    t22 += v * b14;
    t23 += v * b15;
    v = a[9];
    t9 += v * b0;
    t10 += v * b1;
    t11 += v * b2;
    t12 += v * b3;
    t13 += v * b4;
    t14 += v * b5;
    t15 += v * b6;
    t16 += v * b7;
    t17 += v * b8;
    t18 += v * b9;
    t19 += v * b10;
    t20 += v * b11;
    t21 += v * b12;
    t22 += v * b13;
    t23 += v * b14;
    t24 += v * b15;
    v = a[10];
    t10 += v * b0;
    t11 += v * b1;
    t12 += v * b2;
    t13 += v * b3;
    t14 += v * b4;
    t15 += v * b5;
    t16 += v * b6;
    t17 += v * b7;
    t18 += v * b8;
    t19 += v * b9;
    t20 += v * b10;
    t21 += v * b11;
    t22 += v * b12;
    t23 += v * b13;
    t24 += v * b14;
    t25 += v * b15;
    v = a[11];
    t11 += v * b0;
    t12 += v * b1;
    t13 += v * b2;
    t14 += v * b3;
    t15 += v * b4;
    t16 += v * b5;
    t17 += v * b6;
    t18 += v * b7;
    t19 += v * b8;
    t20 += v * b9;
    t21 += v * b10;
    t22 += v * b11;
    t23 += v * b12;
    t24 += v * b13;
    t25 += v * b14;
    t26 += v * b15;
    v = a[12];
    t12 += v * b0;
    t13 += v * b1;
    t14 += v * b2;
    t15 += v * b3;
    t16 += v * b4;
    t17 += v * b5;
    t18 += v * b6;
    t19 += v * b7;
    t20 += v * b8;
    t21 += v * b9;
    t22 += v * b10;
    t23 += v * b11;
    t24 += v * b12;
    t25 += v * b13;
    t26 += v * b14;
    t27 += v * b15;
    v = a[13];
    t13 += v * b0;
    t14 += v * b1;
    t15 += v * b2;
    t16 += v * b3;
    t17 += v * b4;
    t18 += v * b5;
    t19 += v * b6;
    t20 += v * b7;
    t21 += v * b8;
    t22 += v * b9;
    t23 += v * b10;
    t24 += v * b11;
    t25 += v * b12;
    t26 += v * b13;
    t27 += v * b14;
    t28 += v * b15;
    v = a[14];
    t14 += v * b0;
    t15 += v * b1;
    t16 += v * b2;
    t17 += v * b3;
    t18 += v * b4;
    t19 += v * b5;
    t20 += v * b6;
    t21 += v * b7;
    t22 += v * b8;
    t23 += v * b9;
    t24 += v * b10;
    t25 += v * b11;
    t26 += v * b12;
    t27 += v * b13;
    t28 += v * b14;
    t29 += v * b15;
    v = a[15];
    t15 += v * b0;
    t16 += v * b1;
    t17 += v * b2;
    t18 += v * b3;
    t19 += v * b4;
    t20 += v * b5;
    t21 += v * b6;
    t22 += v * b7;
    t23 += v * b8;
    t24 += v * b9;
    t25 += v * b10;
    t26 += v * b11;
    t27 += v * b12;
    t28 += v * b13;
    t29 += v * b14;
    t30 += v * b15;
    t0 += 38 * t16;
    t1 += 38 * t17;
    t2 += 38 * t18;
    t3 += 38 * t19;
    t4 += 38 * t20;
    t5 += 38 * t21;
    t6 += 38 * t22;
    t7 += 38 * t23;
    t8 += 38 * t24;
    t9 += 38 * t25;
    t10 += 38 * t26;
    t11 += 38 * t27;
    t12 += 38 * t28;
    t13 += 38 * t29;
    t14 += 38 * t30;
    // t15 left as is
    // first car
    c = 1;
    v = t0 + c + 65535;
    c = Math.floor(v / 65536);
    t0 = v - c * 65536;
    v = t1 + c + 65535;
    c = Math.floor(v / 65536);
    t1 = v - c * 65536;
    v = t2 + c + 65535;
    c = Math.floor(v / 65536);
    t2 = v - c * 65536;
    v = t3 + c + 65535;
    c = Math.floor(v / 65536);
    t3 = v - c * 65536;
    v = t4 + c + 65535;
    c = Math.floor(v / 65536);
    t4 = v - c * 65536;
    v = t5 + c + 65535;
    c = Math.floor(v / 65536);
    t5 = v - c * 65536;
    v = t6 + c + 65535;
    c = Math.floor(v / 65536);
    t6 = v - c * 65536;
    v = t7 + c + 65535;
    c = Math.floor(v / 65536);
    t7 = v - c * 65536;
    v = t8 + c + 65535;
    c = Math.floor(v / 65536);
    t8 = v - c * 65536;
    v = t9 + c + 65535;
    c = Math.floor(v / 65536);
    t9 = v - c * 65536;
    v = t10 + c + 65535;
    c = Math.floor(v / 65536);
    t10 = v - c * 65536;
    v = t11 + c + 65535;
    c = Math.floor(v / 65536);
    t11 = v - c * 65536;
    v = t12 + c + 65535;
    c = Math.floor(v / 65536);
    t12 = v - c * 65536;
    v = t13 + c + 65535;
    c = Math.floor(v / 65536);
    t13 = v - c * 65536;
    v = t14 + c + 65535;
    c = Math.floor(v / 65536);
    t14 = v - c * 65536;
    v = t15 + c + 65535;
    c = Math.floor(v / 65536);
    t15 = v - c * 65536;
    t0 += c - 1 + 37 * (c - 1);
    // second car
    c = 1;
    v = t0 + c + 65535;
    c = Math.floor(v / 65536);
    t0 = v - c * 65536;
    v = t1 + c + 65535;
    c = Math.floor(v / 65536);
    t1 = v - c * 65536;
    v = t2 + c + 65535;
    c = Math.floor(v / 65536);
    t2 = v - c * 65536;
    v = t3 + c + 65535;
    c = Math.floor(v / 65536);
    t3 = v - c * 65536;
    v = t4 + c + 65535;
    c = Math.floor(v / 65536);
    t4 = v - c * 65536;
    v = t5 + c + 65535;
    c = Math.floor(v / 65536);
    t5 = v - c * 65536;
    v = t6 + c + 65535;
    c = Math.floor(v / 65536);
    t6 = v - c * 65536;
    v = t7 + c + 65535;
    c = Math.floor(v / 65536);
    t7 = v - c * 65536;
    v = t8 + c + 65535;
    c = Math.floor(v / 65536);
    t8 = v - c * 65536;
    v = t9 + c + 65535;
    c = Math.floor(v / 65536);
    t9 = v - c * 65536;
    v = t10 + c + 65535;
    c = Math.floor(v / 65536);
    t10 = v - c * 65536;
    v = t11 + c + 65535;
    c = Math.floor(v / 65536);
    t11 = v - c * 65536;
    v = t12 + c + 65535;
    c = Math.floor(v / 65536);
    t12 = v - c * 65536;
    v = t13 + c + 65535;
    c = Math.floor(v / 65536);
    t13 = v - c * 65536;
    v = t14 + c + 65535;
    c = Math.floor(v / 65536);
    t14 = v - c * 65536;
    v = t15 + c + 65535;
    c = Math.floor(v / 65536);
    t15 = v - c * 65536;
    t0 += c - 1 + 37 * (c - 1);
    o[0] = t0;
    o[1] = t1;
    o[2] = t2;
    o[3] = t3;
    o[4] = t4;
    o[5] = t5;
    o[6] = t6;
    o[7] = t7;
    o[8] = t8;
    o[9] = t9;
    o[10] = t10;
    o[11] = t11;
    o[12] = t12;
    o[13] = t13;
    o[14] = t14;
    o[15] = t15;
}
function S(o, a) {
    M(o, a, a);
}
function inv25519(o, i) {
    var c = gf();
    var a;
    for (a = 0; a < 16; a++)
        c[a] = i[a];
    for (a = 253; a >= 0; a--) {
        S(c, c);
        if (a !== 2 && a !== 4)
            M(c, c, i);
    }
    for (a = 0; a < 16; a++)
        o[a] = c[a];
}
function pow2523(o, i) {
    var c = gf();
    var a;
    for (a = 0; a < 16; a++)
        c[a] = i[a];
    for (a = 250; a >= 0; a--) {
        S(c, c);
        if (a !== 1)
            M(c, c, i);
    }
    for (a = 0; a < 16; a++)
        o[a] = c[a];
}
function crypto_scalarmult(q, n, p) {
    var z = new Uint8Array(32);
    var x = new Float64Array(80), r, i;
    var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
    for (i = 0; i < 31; i++)
        z[i] = n[i];
    z[31] = (n[31] & 127) | 64;
    z[0] &= 248;
    unpack25519(x, p);
    for (i = 0; i < 16; i++) {
        b[i] = x[i];
        d[i] = a[i] = c[i] = 0;
    }
    a[0] = d[0] = 1;
    for (i = 254; i >= 0; --i) {
        r = (z[i >>> 3] >>> (i & 7)) & 1;
        sel25519(a, b, r);
        sel25519(c, d, r);
        A(e, a, c);
        Z(a, a, c);
        A(c, b, d);
        Z(b, b, d);
        S(d, e);
        S(f, a);
        M(a, c, a);
        M(c, b, e);
        A(e, a, c);
        Z(a, a, c);
        S(b, a);
        Z(c, d, f);
        M(a, c, _121665);
        A(a, a, d);
        M(c, c, a);
        M(a, d, f);
        M(d, b, x);
        S(b, e);
        sel25519(a, b, r);
        sel25519(c, d, r);
    }
    for (i = 0; i < 16; i++) {
        x[i + 16] = a[i];
        x[i + 32] = c[i];
        x[i + 48] = b[i];
        x[i + 64] = d[i];
    }
    var x32 = x.subarray(32);
    var x16 = x.subarray(16);
    inv25519(x32, x32);
    M(x16, x16, x32);
    pack25519(q, x16);
    return 0;
}
function crypto_scalarmult_base(q, n) {
    return crypto_scalarmult(q, n, _9);
}
var K = [
    0x428a2f98,
    0xd728ae22,
    0x71374491,
    0x23ef65cd,
    0xb5c0fbcf,
    0xec4d3b2f,
    0xe9b5dba5,
    0x8189dbbc,
    0x3956c25b,
    0xf348b538,
    0x59f111f1,
    0xb605d019,
    0x923f82a4,
    0xaf194f9b,
    0xab1c5ed5,
    0xda6d8118,
    0xd807aa98,
    0xa3030242,
    0x12835b01,
    0x45706fbe,
    0x243185be,
    0x4ee4b28c,
    0x550c7dc3,
    0xd5ffb4e2,
    0x72be5d74,
    0xf27b896f,
    0x80deb1fe,
    0x3b1696b1,
    0x9bdc06a7,
    0x25c71235,
    0xc19bf174,
    0xcf692694,
    0xe49b69c1,
    0x9ef14ad2,
    0xefbe4786,
    0x384f25e3,
    0x0fc19dc6,
    0x8b8cd5b5,
    0x240ca1cc,
    0x77ac9c65,
    0x2de92c6f,
    0x592b0275,
    0x4a7484aa,
    0x6ea6e483,
    0x5cb0a9dc,
    0xbd41fbd4,
    0x76f988da,
    0x831153b5,
    0x983e5152,
    0xee66dfab,
    0xa831c66d,
    0x2db43210,
    0xb00327c8,
    0x98fb213f,
    0xbf597fc7,
    0xbeef0ee4,
    0xc6e00bf3,
    0x3da88fc2,
    0xd5a79147,
    0x930aa725,
    0x06ca6351,
    0xe003826f,
    0x14292967,
    0x0a0e6e70,
    0x27b70a85,
    0x46d22ffc,
    0x2e1b2138,
    0x5c26c926,
    0x4d2c6dfc,
    0x5ac42aed,
    0x53380d13,
    0x9d95b3df,
    0x650a7354,
    0x8baf63de,
    0x766a0abb,
    0x3c77b2a8,
    0x81c2c92e,
    0x47edaee6,
    0x92722c85,
    0x1482353b,
    0xa2bfe8a1,
    0x4cf10364,
    0xa81a664b,
    0xbc423001,
    0xc24b8b70,
    0xd0f89791,
    0xc76c51a3,
    0x0654be30,
    0xd192e819,
    0xd6ef5218,
    0xd6990624,
    0x5565a910,
    0xf40e3585,
    0x5771202a,
    0x106aa070,
    0x32bbd1b8,
    0x19a4c116,
    0xb8d2d0c8,
    0x1e376c08,
    0x5141ab53,
    0x2748774c,
    0xdf8eeb99,
    0x34b0bcb5,
    0xe19b48a8,
    0x391c0cb3,
    0xc5c95a63,
    0x4ed8aa4a,
    0xe3418acb,
    0x5b9cca4f,
    0x7763e373,
    0x682e6ff3,
    0xd6b2b8a3,
    0x748f82ee,
    0x5defb2fc,
    0x78a5636f,
    0x43172f60,
    0x84c87814,
    0xa1f0ab72,
    0x8cc70208,
    0x1a6439ec,
    0x90befffa,
    0x23631e28,
    0xa4506ceb,
    0xde82bde9,
    0xbef9a3f7,
    0xb2c67915,
    0xc67178f2,
    0xe372532b,
    0xca273ece,
    0xea26619c,
    0xd186b8c7,
    0x21c0c207,
    0xeada7dd6,
    0xcde0eb1e,
    0xf57d4f7f,
    0xee6ed178,
    0x06f067aa,
    0x72176fba,
    0x0a637dc5,
    0xa2c898a6,
    0x113f9804,
    0xbef90dae,
    0x1b710b35,
    0x131c471b,
    0x28db77f5,
    0x23047d84,
    0x32caab7b,
    0x40c72493,
    0x3c9ebe0a,
    0x15c9bebc,
    0x431d67c4,
    0x9c100d4c,
    0x4cc5d4be,
    0xcb3e42b6,
    0x597f299c,
    0xfc657e2a,
    0x5fcb6fab,
    0x3ad6faec,
    0x6c44198c,
    0x4a475817,
];
function crypto_hashblocks_hl(hh, hl, m, n) {
    var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h, l, a, b, c, d;
    var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
    var pos = 0;
    while (n >= 128) {
        for (i = 0; i < 16; i++) {
            j = 8 * i + pos;
            wh[i] = (m[j + 0] << 24) | (m[j + 1] << 16) | (m[j + 2] << 8) | m[j + 3];
            wl[i] = (m[j + 4] << 24) | (m[j + 5] << 16) | (m[j + 6] << 8) | m[j + 7];
        }
        for (i = 0; i < 80; i++) {
            bh0 = ah0;
            bh1 = ah1;
            bh2 = ah2;
            bh3 = ah3;
            bh4 = ah4;
            bh5 = ah5;
            bh6 = ah6;
            bh7 = ah7;
            bl0 = al0;
            bl1 = al1;
            bl2 = al2;
            bl3 = al3;
            bl4 = al4;
            bl5 = al5;
            bl6 = al6;
            bl7 = al7;
            // add
            h = ah7;
            l = al7;
            a = l & 0xffff;
            b = l >>> 16;
            c = h & 0xffff;
            d = h >>> 16;
            // Sigma1
            h =
                ((ah4 >>> 14) | (al4 << (32 - 14))) ^
                    ((ah4 >>> 18) | (al4 << (32 - 18))) ^
                    ((al4 >>> (41 - 32)) | (ah4 << (32 - (41 - 32))));
            l =
                ((al4 >>> 14) | (ah4 << (32 - 14))) ^
                    ((al4 >>> 18) | (ah4 << (32 - 18))) ^
                    ((ah4 >>> (41 - 32)) | (al4 << (32 - (41 - 32))));
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            // Ch
            h = (ah4 & ah5) ^ (~ah4 & ah6);
            l = (al4 & al5) ^ (~al4 & al6);
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            // K
            h = K[i * 2];
            l = K[i * 2 + 1];
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            // w
            h = wh[i % 16];
            l = wl[i % 16];
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            th = (c & 0xffff) | (d << 16);
            tl = (a & 0xffff) | (b << 16);
            // add
            h = th;
            l = tl;
            a = l & 0xffff;
            b = l >>> 16;
            c = h & 0xffff;
            d = h >>> 16;
            // Sigma0
            h =
                ((ah0 >>> 28) | (al0 << (32 - 28))) ^
                    ((al0 >>> (34 - 32)) | (ah0 << (32 - (34 - 32)))) ^
                    ((al0 >>> (39 - 32)) | (ah0 << (32 - (39 - 32))));
            l =
                ((al0 >>> 28) | (ah0 << (32 - 28))) ^
                    ((ah0 >>> (34 - 32)) | (al0 << (32 - (34 - 32)))) ^
                    ((ah0 >>> (39 - 32)) | (al0 << (32 - (39 - 32))));
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            // Maj
            h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);
            l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh7 = (c & 0xffff) | (d << 16);
            bl7 = (a & 0xffff) | (b << 16);
            // add
            h = bh3;
            l = bl3;
            a = l & 0xffff;
            b = l >>> 16;
            c = h & 0xffff;
            d = h >>> 16;
            h = th;
            l = tl;
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh3 = (c & 0xffff) | (d << 16);
            bl3 = (a & 0xffff) | (b << 16);
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i % 16 === 15) {
                for (j = 0; j < 16; j++) {
                    // add
                    h = wh[j];
                    l = wl[j];
                    a = l & 0xffff;
                    b = l >>> 16;
                    c = h & 0xffff;
                    d = h >>> 16;
                    h = wh[(j + 9) % 16];
                    l = wl[(j + 9) % 16];
                    a += l & 0xffff;
                    b += l >>> 16;
                    c += h & 0xffff;
                    d += h >>> 16;
                    // sigma0
                    th = wh[(j + 1) % 16];
                    tl = wl[(j + 1) % 16];
                    h = ((th >>> 1) | (tl << (32 - 1))) ^ ((th >>> 8) | (tl << (32 - 8))) ^ (th >>> 7);
                    l = ((tl >>> 1) | (th << (32 - 1))) ^ ((tl >>> 8) | (th << (32 - 8))) ^ ((tl >>> 7) | (th << (32 - 7)));
                    a += l & 0xffff;
                    b += l >>> 16;
                    c += h & 0xffff;
                    d += h >>> 16;
                    // sigma1
                    th = wh[(j + 14) % 16];
                    tl = wl[(j + 14) % 16];
                    h = ((th >>> 19) | (tl << (32 - 19))) ^ ((tl >>> (61 - 32)) | (th << (32 - (61 - 32)))) ^ (th >>> 6);
                    l =
                        ((tl >>> 19) | (th << (32 - 19))) ^
                            ((th >>> (61 - 32)) | (tl << (32 - (61 - 32)))) ^
                            ((tl >>> 6) | (th << (32 - 6)));
                    a += l & 0xffff;
                    b += l >>> 16;
                    c += h & 0xffff;
                    d += h >>> 16;
                    b += a >>> 16;
                    c += b >>> 16;
                    d += c >>> 16;
                    wh[j] = (c & 0xffff) | (d << 16);
                    wl[j] = (a & 0xffff) | (b << 16);
                }
            }
        }
        // add
        h = ah0;
        l = al0;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[0];
        l = hl[0];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[0] = ah0 = (c & 0xffff) | (d << 16);
        hl[0] = al0 = (a & 0xffff) | (b << 16);
        h = ah1;
        l = al1;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[1];
        l = hl[1];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[1] = ah1 = (c & 0xffff) | (d << 16);
        hl[1] = al1 = (a & 0xffff) | (b << 16);
        h = ah2;
        l = al2;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[2];
        l = hl[2];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[2] = ah2 = (c & 0xffff) | (d << 16);
        hl[2] = al2 = (a & 0xffff) | (b << 16);
        h = ah3;
        l = al3;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[3];
        l = hl[3];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[3] = ah3 = (c & 0xffff) | (d << 16);
        hl[3] = al3 = (a & 0xffff) | (b << 16);
        h = ah4;
        l = al4;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[4];
        l = hl[4];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[4] = ah4 = (c & 0xffff) | (d << 16);
        hl[4] = al4 = (a & 0xffff) | (b << 16);
        h = ah5;
        l = al5;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[5];
        l = hl[5];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[5] = ah5 = (c & 0xffff) | (d << 16);
        hl[5] = al5 = (a & 0xffff) | (b << 16);
        h = ah6;
        l = al6;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[6];
        l = hl[6];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[6] = ah6 = (c & 0xffff) | (d << 16);
        hl[6] = al6 = (a & 0xffff) | (b << 16);
        h = ah7;
        l = al7;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[7];
        l = hl[7];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[7] = ah7 = (c & 0xffff) | (d << 16);
        hl[7] = al7 = (a & 0xffff) | (b << 16);
        pos += 128;
        n -= 128;
    }
    return n;
}
function crypto_hash(out, m, n) {
    var hh = new Int32Array(8), hl = new Int32Array(8), x = new Uint8Array(256), i, b = n;
    hh[0] = 0x6a09e667;
    hh[1] = 0xbb67ae85;
    hh[2] = 0x3c6ef372;
    hh[3] = 0xa54ff53a;
    hh[4] = 0x510e527f;
    hh[5] = 0x9b05688c;
    hh[6] = 0x1f83d9ab;
    hh[7] = 0x5be0cd19;
    hl[0] = 0xf3bcc908;
    hl[1] = 0x84caa73b;
    hl[2] = 0xfe94f82b;
    hl[3] = 0x5f1d36f1;
    hl[4] = 0xade682d1;
    hl[5] = 0x2b3e6c1f;
    hl[6] = 0xfb41bd6b;
    hl[7] = 0x137e2179;
    crypto_hashblocks_hl(hh, hl, m, n);
    n %= 128;
    for (i = 0; i < n; i++)
        x[i] = m[b - n + i];
    x[n] = 128;
    n = 256 - 128 * (n < 112 ? 1 : 0);
    x[n - 9] = 0;
    ts64(x, n - 8, (b / 0x20000000) | 0, b << 3);
    crypto_hashblocks_hl(hh, hl, x, n);
    for (i = 0; i < 8; i++)
        ts64(out, 8 * i, hh[i], hl[i]);
    return 0;
}
function add(p, q) {
    var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
    Z(a, p[1], p[0]);
    Z(t, q[1], q[0]);
    M(a, a, t);
    A(b, p[0], p[1]);
    A(t, q[0], q[1]);
    M(b, b, t);
    M(c, p[3], q[3]);
    M(c, c, D2);
    M(d, p[2], q[2]);
    A(d, d, d);
    Z(e, b, a);
    Z(f, d, c);
    A(g, d, c);
    A(h, b, a);
    M(p[0], e, f);
    M(p[1], h, g);
    M(p[2], g, f);
    M(p[3], e, h);
}
function cswap(p, q, b) {
    var i;
    for (i = 0; i < 4; i++) {
        sel25519(p[i], q[i], b);
    }
}
function pack(r, p) {
    var tx = gf(), ty = gf(), zi = gf();
    inv25519(zi, p[2]);
    M(tx, p[0], zi);
    M(ty, p[1], zi);
    pack25519(r, ty);
    r[31] ^= par25519(tx) << 7;
}
function scalarmult(p, q, s) {
    var b, i;
    set25519(p[0], gf0);
    set25519(p[1], gf1);
    set25519(p[2], gf1);
    set25519(p[3], gf0);
    for (i = 255; i >= 0; --i) {
        b = (s[(i / 8) | 0] >> (i & 7)) & 1;
        cswap(p, q, b);
        add(q, p);
        add(p, p);
        cswap(p, q, b);
    }
}
function scalarbase(p, s) {
    var q = [gf(), gf(), gf(), gf()];
    set25519(q[0], X);
    set25519(q[1], Y);
    set25519(q[2], gf1);
    M(q[3], X, Y);
    scalarmult(p, q, s);
}
var L = new Float64Array([
    0xed,
    0xd3,
    0xf5,
    0x5c,
    0x1a,
    0x63,
    0x12,
    0x58,
    0xd6,
    0x9c,
    0xf7,
    0xa2,
    0xde,
    0xf9,
    0xde,
    0x14,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0x10,
]);
function modL(r, x) {
    var carry, i, j, k;
    for (i = 63; i >= 32; --i) {
        carry = 0;
        for (j = i - 32, k = i - 12; j < k; ++j) {
            x[j] += carry - 16 * x[i] * L[j - (i - 32)];
            carry = (x[j] + 128) >> 8;
            x[j] -= carry * 256;
        }
        x[j] += carry;
        x[i] = 0;
    }
    carry = 0;
    for (j = 0; j < 32; j++) {
        x[j] += carry - (x[31] >> 4) * L[j];
        carry = x[j] >> 8;
        x[j] &= 255;
    }
    for (j = 0; j < 32; j++)
        x[j] -= carry * L[j];
    for (i = 0; i < 32; i++) {
        x[i + 1] += x[i] >> 8;
        r[i] = x[i] & 255;
    }
}
function reduce(r) {
    var x = new Float64Array(64), i;
    for (i = 0; i < 64; i++)
        x[i] = r[i];
    for (i = 0; i < 64; i++)
        r[i] = 0;
    modL(r, x);
}
// Like crypto_sign, but uses secret key directly in hash.
function crypto_sign_direct(sm, m, n, sk) {
    var h = new Uint8Array(64), r = new Uint8Array(64);
    var i, j, x = new Float64Array(64);
    var p = [gf(), gf(), gf(), gf()];
    for (i = 0; i < n; i++)
        sm[64 + i] = m[i];
    for (i = 0; i < 32; i++)
        sm[32 + i] = sk[i];
    crypto_hash(r, sm.subarray(32), n + 32);
    reduce(r);
    scalarbase(p, r);
    pack(sm, p);
    for (i = 0; i < 32; i++)
        sm[i + 32] = sk[32 + i];
    crypto_hash(h, sm, n + 64);
    reduce(h);
    for (i = 0; i < 64; i++)
        x[i] = 0;
    for (i = 0; i < 32; i++)
        x[i] = r[i];
    for (i = 0; i < 32; i++) {
        for (j = 0; j < 32; j++) {
            x[i + j] += h[i] * sk[j];
        }
    }
    modL(sm.subarray(32), x);
    return n + 64;
}
// Note: sm must be n+128.
function crypto_sign_direct_rnd(sm, m, n, sk, rnd) {
    var h = new Uint8Array(64), r = new Uint8Array(64);
    var i, j, x = new Float64Array(64);
    var p = [gf(), gf(), gf(), gf()];
    // Hash separation.
    sm[0] = 0xfe;
    for (i = 1; i < 32; i++)
        sm[i] = 0xff;
    // Secret key.
    for (i = 0; i < 32; i++)
        sm[32 + i] = sk[i];
    // Message.
    for (i = 0; i < n; i++)
        sm[64 + i] = m[i];
    // Random suffix.
    for (i = 0; i < 64; i++)
        sm[n + 64 + i] = rnd[i];
    crypto_hash(r, sm, n + 128);
    reduce(r);
    scalarbase(p, r);
    pack(sm, p);
    for (i = 0; i < 32; i++)
        sm[i + 32] = sk[32 + i];
    crypto_hash(h, sm, n + 64);
    reduce(h);
    // Wipe out random suffix.
    for (i = 0; i < 64; i++)
        sm[n + 64 + i] = 0;
    for (i = 0; i < 64; i++)
        x[i] = 0;
    for (i = 0; i < 32; i++)
        x[i] = r[i];
    for (i = 0; i < 32; i++) {
        for (j = 0; j < 32; j++) {
            x[i + j] += h[i] * sk[j];
        }
    }
    modL(sm.subarray(32, n + 64), x);
    return n + 64;
}
function curve25519_sign(sm, m, n, sk, opt_rnd) {
    // If opt_rnd is provided, sm must have n + 128,
    // otherwise it must have n + 64 bytes.
    // Convert Curve25519 secret key into Ed25519 secret key (includes pub key).
    var edsk = new Uint8Array(64);
    var p = [gf(), gf(), gf(), gf()];
    for (var i = 0; i < 32; i++)
        edsk[i] = sk[i];
    // Ensure private key is in the correct format.
    edsk[0] &= 248;
    edsk[31] &= 127;
    edsk[31] |= 64;
    scalarbase(p, edsk);
    pack(edsk.subarray(32), p);
    // Remember sign bit.
    var signBit = edsk[63] & 128;
    var smlen;
    if (opt_rnd) {
        smlen = crypto_sign_direct_rnd(sm, m, n, edsk, opt_rnd);
    }
    else {
        smlen = crypto_sign_direct(sm, m, n, edsk);
    }
    // Copy sign bit from public key into signature.
    sm[63] |= signBit;
    return smlen;
}
function unpackneg(r, p) {
    var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
    set25519(r[2], gf1);
    unpack25519(r[1], p);
    S(num, r[1]);
    M(den, num, D);
    Z(num, num, r[2]);
    A(den, r[2], den);
    S(den2, den);
    S(den4, den2);
    M(den6, den4, den2);
    M(t, den6, num);
    M(t, t, den);
    pow2523(t, t);
    M(t, t, num);
    M(t, t, den);
    M(t, t, den);
    M(r[0], t, den);
    S(chk, r[0]);
    M(chk, chk, den);
    if (neq25519(chk, num))
        M(r[0], r[0], I);
    S(chk, r[0]);
    M(chk, chk, den);
    if (neq25519(chk, num))
        return -1;
    if (par25519(r[0]) === p[31] >> 7)
        Z(r[0], gf0, r[0]);
    M(r[3], r[0], r[1]);
    return 0;
}
function crypto_sign_open(m, sm, n, pk) {
    var i, mlen;
    var t = new Uint8Array(32), h = new Uint8Array(64);
    var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
    mlen = -1;
    if (n < 64)
        return -1;
    if (unpackneg(q, pk))
        return -1;
    for (i = 0; i < n; i++)
        m[i] = sm[i];
    for (i = 0; i < 32; i++)
        m[i + 32] = pk[i];
    crypto_hash(h, m, n);
    reduce(h);
    scalarmult(p, q, h);
    scalarbase(q, sm.subarray(32));
    add(p, q);
    pack(t, p);
    n -= 64;
    if (crypto_verify_32(sm, 0, t, 0)) {
        for (i = 0; i < n; i++)
            m[i] = 0;
        return -1;
    }
    for (i = 0; i < n; i++)
        m[i] = sm[i + 64];
    mlen = n;
    return mlen;
}
// Converts Curve25519 public key back to Ed25519 public key.
// edwardsY = (montgomeryX - 1) / (montgomeryX + 1)
function convertPublicKey(pk) {
    var z = new Uint8Array(32), x = gf(), a = gf(), b = gf();
    unpack25519(x, pk);
    A(a, x, gf1);
    Z(b, x, gf1);
    inv25519(a, a);
    M(a, a, b);
    pack25519(z, a);
    return z;
}
function curve25519_sign_open(m, sm, n, pk) {
    // Convert Curve25519 public key into Ed25519 public key.
    var edpk = convertPublicKey(pk);
    // Restore sign bit from signature.
    edpk[31] |= sm[63] & 128;
    // Remove sign bit from signature.
    sm[63] &= 127;
    // Verify signed message.
    return crypto_sign_open(m, sm, n, edpk);
}
/* High-level API */
function checkArrayTypes(...args) {
    var t, i;
    for (i = 0; i < arguments.length; i++) {
        if ((t = Object.prototype.toString.call(arguments[i])) !== '[object Uint8Array]')
            throw new TypeError('unexpected type ' + t + ', use Uint8Array');
    }
}
/**
 * Returns a raw shared key between own private key and peer's public key (in other words, this is an ECC Diffie-Hellman function X25519, performing scalar multiplication).
 *
 * The result should not be used directly as a key, but should be processed with a one-way function (e.g. HSalsa20 as in NaCl, or any secure cryptographic hash function, such as SHA-256, or key derivation function, such as HKDF).
 *
 * @export
 * @param {Uint8Array} secretKey
 * @param {Uint8Array} publicKey
 * @returns Uint8Array
 */
function sharedKey(secretKey, publicKey) {
    checkArrayTypes(publicKey, secretKey);
    if (publicKey.length !== 32)
        throw new Error('wrong public key length');
    if (secretKey.length !== 32)
        throw new Error('wrong secret key length');
    var sharedKey = new Uint8Array(32);
    crypto_scalarmult(sharedKey, secretKey, publicKey);
    return sharedKey;
}
/**
 * Signs the given message using the private key and returns a signed message (signature concatenated with the message copy).
 *
 * Optional random data argument (which must have 64 random bytes) turns on hash separation and randomization to make signatures non-deterministic.
 *
 * @export
 * @param {Uint8Array} secretKey
 * @param {*} msg
 * @param {Uint8Array} opt_random
 * @returns
 */
function signMessage(secretKey, msg, opt_random) {
    checkArrayTypes(msg, secretKey);
    if (secretKey.length !== 32)
        throw new Error('wrong secret key length');
    if (opt_random) {
        checkArrayTypes(opt_random);
        if (opt_random.length !== 64)
            throw new Error('wrong random data length');
        var buf = new Uint8Array(128 + msg.length);
        curve25519_sign(buf, msg, msg.length, secretKey, opt_random);
        return new Uint8Array(buf.subarray(0, 64 + msg.length));
    }
    else {
        var signedMsg = new Uint8Array(64 + msg.length);
        curve25519_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
    }
}
/**
 * Verifies signed message with the public key and returns the original message without signature if it's correct or null if verification fails.
 *
 * @export
 * @param {Uint8Array} publicKey
 * @param {*} signedMsg
 * @returns Message
 */
function openMessage(publicKey, signedMsg) {
    checkArrayTypes(signedMsg, publicKey);
    if (publicKey.length !== 32)
        throw new Error('wrong public key length');
    var tmp = new Uint8Array(signedMsg.length);
    var mlen = curve25519_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
    if (mlen < 0)
        return null;
    var m = new Uint8Array(mlen);
    for (var i = 0; i < m.length; i++)
        m[i] = tmp[i];
    return m;
}
/**
 * Signs the given message using the private key and returns signature.
 *
 * Optional random data argument (which must have 64 random bytes) turns on hash separation and randomization to make signatures non-deterministic.
 *
 * @export
 * @param {Uint8Array} secretKey
 * @param {*} msg
 * @param {Uint8Array} opt_random
 * @returns
 */
function sign(secretKey, msg, opt_random) {
    checkArrayTypes(secretKey, msg);
    if (secretKey.length !== 32)
        throw new Error('wrong secret key length');
    if (opt_random) {
        checkArrayTypes(opt_random);
        if (opt_random.length !== 64)
            throw new Error('wrong random data length');
    }
    var buf = new Uint8Array((opt_random ? 128 : 64) + msg.length);
    curve25519_sign(buf, msg, msg.length, secretKey, opt_random);
    var signature = new Uint8Array(64);
    for (var i = 0; i < signature.length; i++)
        signature[i] = buf[i];
    return signature;
}
/**
 * Verifies the given signature for the message using the given private key. Returns true if the signature is valid, false otherwise.
 *
 * @export
 * @param {Uint8Array} publicKey
 * @param {*} msg
 * @param {*} signature
 * @returns
 */
function verify(publicKey, msg, signature) {
    checkArrayTypes(msg, signature, publicKey);
    if (signature.length !== 64)
        throw new Error('wrong signature length');
    if (publicKey.length !== 32)
        throw new Error('wrong public key length');
    var sm = new Uint8Array(64 + msg.length);
    var m = new Uint8Array(64 + msg.length);
    var i;
    for (i = 0; i < 64; i++)
        sm[i] = signature[i];
    for (i = 0; i < msg.length; i++)
        sm[i + 64] = msg[i];
    return curve25519_sign_open(m, sm, sm.length, publicKey) >= 0;
}
/**
 * Generates a new key pair from the given 32-byte secret seed (which should be generated with a CSPRNG) and returns it as object.
 *
 * The returned keys can be used for signing and key agreement.
 *
 * @export
 * @param {Uint8Array} seed required
 * @returns
 */
function generateKeyPair(seed) {
    checkArrayTypes(seed);
    if (seed.length !== 32)
        throw new Error('wrong seed length');
    var sk = new Uint8Array(32);
    var pk = new Uint8Array(32);
    for (var i = 0; i < 32; i++)
        sk[i] = seed[i];
    crypto_scalarmult_base(pk, sk);
    // Turn secret key into the correct format.
    sk[0] &= 248;
    sk[31] &= 127;
    sk[31] |= 64;
    // Remove sign bit from public key.
    pk[31] &= 127;
    return {
        public: pk,
        private: sk,
    };
}
module.exports = {
    sharedKey,
    signMessage,
    openMessage,
    sign,
    verify,
    generateKeyPair,
};

}, map: {} },
'build/ts/lib/vmmRpcClient.js': { factory: function(module, exports, require) {
"use strict";
// SPDX-FileCopyrightText: © 2025 Phala Network <dstack@phala.network>
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.getVmmRpcClient = getVmmRpcClient;
const { vmm } = require('../proto/vmm_rpc.js');
const { prpc } = require('../proto/prpc.js');
const textDecoder = new TextDecoder();
const EMPTY_BODY = new Uint8Array();
let cachedClient;
function decodePrpcError(buffer) {
    try {
        if (buffer && buffer.length > 0) {
            const err = prpc.PrpcError.decode(buffer);
            if (err === null || err === void 0 ? void 0 : err.message) {
                return err.message;
            }
        }
    }
    catch (_a) {
        // Ignore decode failures; fall through to text decoding.
    }
    try {
        const text = buffer && buffer.length > 0 ? textDecoder.decode(buffer) : '';
        return text || 'Unknown RPC error';
    }
    catch (_b) {
        return 'Unknown RPC error';
    }
}
function normalizeRequestData(data) {
    if (!data) {
        return EMPTY_BODY;
    }
    if (data instanceof Uint8Array) {
        return data;
    }
    return new Uint8Array(data);
}
function resolveMethodName(method) {
    if (!method) {
        return '';
    }
    const type = typeof method;
    if (type === 'string') {
        return method;
    }
    if (type === 'function' || type === 'object') {
        if (method.name) {
            return method.name.charAt(0).toUpperCase() + method.name.slice(1);
        }
        if (method.fullName) {
            const parts = String(method.fullName).split('.');
            return parts[parts.length - 1];
        }
    }
    return String(method);
}
function getVmmRpcClient(basePath = '/prpc') {
    if (cachedClient) {
        return cachedClient;
    }
    const rpcImpl = (method, requestData, callback) => {
        const methodName = resolveMethodName(method);
        const payload = normalizeRequestData(requestData);
        fetch(`${basePath}/${methodName}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/octet-stream',
            },
            body: payload,
            credentials: 'same-origin',
        })
            .then(async (response) => {
            const buffer = new Uint8Array(await response.arrayBuffer());
            if (!response.ok) {
                callback(new Error(decodePrpcError(buffer)));
                return;
            }
            callback(null, buffer);
        })
            .catch((error) => {
            callback(error);
        });
    };
    cachedClient = vmm.Vmm.create(rpcImpl, false, false);
    return cachedClient;
}

}, map: {"../proto/vmm_rpc.js":"build/ts/proto/vmm_rpc.js","../proto/prpc.js":"build/ts/proto/prpc.js"} },
'build/ts/proto/vmm_rpc.js': { factory: function(module, exports, require) {
/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";
var $protobuf = require("protobufjs/minimal");
// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
$root.vmm = (function () {
    /**
     * Namespace vmm.
     * @exports vmm
     * @namespace
     */
    var vmm = {};
    vmm.VmInfo = (function () {
        /**
         * Properties of a VmInfo.
         * @memberof vmm
         * @interface IVmInfo
         * @property {string|null} [id] VmInfo id
         * @property {string|null} [name] VmInfo name
         * @property {string|null} [status] VmInfo status
         * @property {string|null} [uptime] VmInfo uptime
         * @property {string|null} [app_url] VmInfo app_url
         * @property {string|null} [app_id] VmInfo app_id
         * @property {string|null} [instance_id] VmInfo instance_id
         * @property {vmm.IVmConfiguration|null} [configuration] VmInfo configuration
         * @property {string|null} [exited_at] VmInfo exited_at
         * @property {string|null} [boot_progress] VmInfo boot_progress
         * @property {string|null} [boot_error] VmInfo boot_error
         * @property {string|null} [shutdown_progress] VmInfo shutdown_progress
         * @property {string|null} [image_version] VmInfo image_version
         * @property {Array.<vmm.IGuestEvent>|null} [events] VmInfo events
         */
        /**
         * Constructs a new VmInfo.
         * @memberof vmm
         * @classdesc Represents a VmInfo.
         * @implements IVmInfo
         * @constructor
         * @param {vmm.IVmInfo=} [properties] Properties to set
         */
        function VmInfo(properties) {
            this.events = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * VmInfo id.
         * @member {string} id
         * @memberof vmm.VmInfo
         * @instance
         */
        VmInfo.prototype.id = "";
        /**
         * VmInfo name.
         * @member {string} name
         * @memberof vmm.VmInfo
         * @instance
         */
        VmInfo.prototype.name = "";
        /**
         * VmInfo status.
         * @member {string} status
         * @memberof vmm.VmInfo
         * @instance
         */
        VmInfo.prototype.status = "";
        /**
         * VmInfo uptime.
         * @member {string} uptime
         * @memberof vmm.VmInfo
         * @instance
         */
        VmInfo.prototype.uptime = "";
        /**
         * VmInfo app_url.
         * @member {string|null|undefined} app_url
         * @memberof vmm.VmInfo
         * @instance
         */
        VmInfo.prototype.app_url = null;
        /**
         * VmInfo app_id.
         * @member {string} app_id
         * @memberof vmm.VmInfo
         * @instance
         */
        VmInfo.prototype.app_id = "";
        /**
         * VmInfo instance_id.
         * @member {string|null|undefined} instance_id
         * @memberof vmm.VmInfo
         * @instance
         */
        VmInfo.prototype.instance_id = null;
        /**
         * VmInfo configuration.
         * @member {vmm.IVmConfiguration|null|undefined} configuration
         * @memberof vmm.VmInfo
         * @instance
         */
        VmInfo.prototype.configuration = null;
        /**
         * VmInfo exited_at.
         * @member {string|null|undefined} exited_at
         * @memberof vmm.VmInfo
         * @instance
         */
        VmInfo.prototype.exited_at = null;
        /**
         * VmInfo boot_progress.
         * @member {string} boot_progress
         * @memberof vmm.VmInfo
         * @instance
         */
        VmInfo.prototype.boot_progress = "";
        /**
         * VmInfo boot_error.
         * @member {string} boot_error
         * @memberof vmm.VmInfo
         * @instance
         */
        VmInfo.prototype.boot_error = "";
        /**
         * VmInfo shutdown_progress.
         * @member {string} shutdown_progress
         * @memberof vmm.VmInfo
         * @instance
         */
        VmInfo.prototype.shutdown_progress = "";
        /**
         * VmInfo image_version.
         * @member {string} image_version
         * @memberof vmm.VmInfo
         * @instance
         */
        VmInfo.prototype.image_version = "";
        /**
         * VmInfo events.
         * @member {Array.<vmm.IGuestEvent>} events
         * @memberof vmm.VmInfo
         * @instance
         */
        VmInfo.prototype.events = $util.emptyArray;
        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;
        /**
         * VmInfo _app_url.
         * @member {"app_url"|undefined} _app_url
         * @memberof vmm.VmInfo
         * @instance
         */
        Object.defineProperty(VmInfo.prototype, "_app_url", {
            get: $util.oneOfGetter($oneOfFields = ["app_url"]),
            set: $util.oneOfSetter($oneOfFields)
        });
        /**
         * VmInfo _instance_id.
         * @member {"instance_id"|undefined} _instance_id
         * @memberof vmm.VmInfo
         * @instance
         */
        Object.defineProperty(VmInfo.prototype, "_instance_id", {
            get: $util.oneOfGetter($oneOfFields = ["instance_id"]),
            set: $util.oneOfSetter($oneOfFields)
        });
        /**
         * VmInfo _exited_at.
         * @member {"exited_at"|undefined} _exited_at
         * @memberof vmm.VmInfo
         * @instance
         */
        Object.defineProperty(VmInfo.prototype, "_exited_at", {
            get: $util.oneOfGetter($oneOfFields = ["exited_at"]),
            set: $util.oneOfSetter($oneOfFields)
        });
        /**
         * Creates a new VmInfo instance using the specified properties.
         * @function create
         * @memberof vmm.VmInfo
         * @static
         * @param {vmm.IVmInfo=} [properties] Properties to set
         * @returns {vmm.VmInfo} VmInfo instance
         */
        VmInfo.create = function create(properties) {
            return new VmInfo(properties);
        };
        /**
         * Encodes the specified VmInfo message. Does not implicitly {@link vmm.VmInfo.verify|verify} messages.
         * @function encode
         * @memberof vmm.VmInfo
         * @static
         * @param {vmm.IVmInfo} message VmInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VmInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.id);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.name);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.status);
            if (message.uptime != null && Object.hasOwnProperty.call(message, "uptime"))
                writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.uptime);
            if (message.app_url != null && Object.hasOwnProperty.call(message, "app_url"))
                writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.app_url);
            if (message.app_id != null && Object.hasOwnProperty.call(message, "app_id"))
                writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.app_id);
            if (message.instance_id != null && Object.hasOwnProperty.call(message, "instance_id"))
                writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.instance_id);
            if (message.configuration != null && Object.hasOwnProperty.call(message, "configuration"))
                $root.vmm.VmConfiguration.encode(message.configuration, writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();
            if (message.exited_at != null && Object.hasOwnProperty.call(message, "exited_at"))
                writer.uint32(/* id 9, wireType 2 =*/ 74).string(message.exited_at);
            if (message.boot_progress != null && Object.hasOwnProperty.call(message, "boot_progress"))
                writer.uint32(/* id 10, wireType 2 =*/ 82).string(message.boot_progress);
            if (message.boot_error != null && Object.hasOwnProperty.call(message, "boot_error"))
                writer.uint32(/* id 11, wireType 2 =*/ 90).string(message.boot_error);
            if (message.shutdown_progress != null && Object.hasOwnProperty.call(message, "shutdown_progress"))
                writer.uint32(/* id 12, wireType 2 =*/ 98).string(message.shutdown_progress);
            if (message.image_version != null && Object.hasOwnProperty.call(message, "image_version"))
                writer.uint32(/* id 13, wireType 2 =*/ 106).string(message.image_version);
            if (message.events != null && message.events.length)
                for (var i = 0; i < message.events.length; ++i)
                    $root.vmm.GuestEvent.encode(message.events[i], writer.uint32(/* id 14, wireType 2 =*/ 114).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified VmInfo message, length delimited. Does not implicitly {@link vmm.VmInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vmm.VmInfo
         * @static
         * @param {vmm.IVmInfo} message VmInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VmInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a VmInfo message from the specified reader or buffer.
         * @function decode
         * @memberof vmm.VmInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vmm.VmInfo} VmInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VmInfo.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vmm.VmInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                    case 1: {
                        message.id = reader.string();
                        break;
                    }
                    case 2: {
                        message.name = reader.string();
                        break;
                    }
                    case 3: {
                        message.status = reader.string();
                        break;
                    }
                    case 4: {
                        message.uptime = reader.string();
                        break;
                    }
                    case 5: {
                        message.app_url = reader.string();
                        break;
                    }
                    case 6: {
                        message.app_id = reader.string();
                        break;
                    }
                    case 7: {
                        message.instance_id = reader.string();
                        break;
                    }
                    case 8: {
                        message.configuration = $root.vmm.VmConfiguration.decode(reader, reader.uint32());
                        break;
                    }
                    case 9: {
                        message.exited_at = reader.string();
                        break;
                    }
                    case 10: {
                        message.boot_progress = reader.string();
                        break;
                    }
                    case 11: {
                        message.boot_error = reader.string();
                        break;
                    }
                    case 12: {
                        message.shutdown_progress = reader.string();
                        break;
                    }
                    case 13: {
                        message.image_version = reader.string();
                        break;
                    }
                    case 14: {
                        if (!(message.events && message.events.length))
                            message.events = [];
                        message.events.push($root.vmm.GuestEvent.decode(reader, reader.uint32()));
                        break;
                    }
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a VmInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vmm.VmInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vmm.VmInfo} VmInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VmInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a VmInfo message.
         * @function verify
         * @memberof vmm.VmInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VmInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.status != null && message.hasOwnProperty("status"))
                if (!$util.isString(message.status))
                    return "status: string expected";
            if (message.uptime != null && message.hasOwnProperty("uptime"))
                if (!$util.isString(message.uptime))
                    return "uptime: string expected";
            if (message.app_url != null && message.hasOwnProperty("app_url")) {
                properties._app_url = 1;
                if (!$util.isString(message.app_url))
                    return "app_url: string expected";
            }
            if (message.app_id != null && message.hasOwnProperty("app_id"))
                if (!$util.isString(message.app_id))
                    return "app_id: string expected";
            if (message.instance_id != null && message.hasOwnProperty("instance_id")) {
                properties._instance_id = 1;
                if (!$util.isString(message.instance_id))
                    return "instance_id: string expected";
            }
            if (message.configuration != null && message.hasOwnProperty("configuration")) {
                var error = $root.vmm.VmConfiguration.verify(message.configuration);
                if (error)
                    return "configuration." + error;
            }
            if (message.exited_at != null && message.hasOwnProperty("exited_at")) {
                properties._exited_at = 1;
                if (!$util.isString(message.exited_at))
                    return "exited_at: string expected";
            }
            if (message.boot_progress != null && message.hasOwnProperty("boot_progress"))
                if (!$util.isString(message.boot_progress))
                    return "boot_progress: string expected";
            if (message.boot_error != null && message.hasOwnProperty("boot_error"))
                if (!$util.isString(message.boot_error))
                    return "boot_error: string expected";
            if (message.shutdown_progress != null && message.hasOwnProperty("shutdown_progress"))
                if (!$util.isString(message.shutdown_progress))
                    return "shutdown_progress: string expected";
            if (message.image_version != null && message.hasOwnProperty("image_version"))
                if (!$util.isString(message.image_version))
                    return "image_version: string expected";
            if (message.events != null && message.hasOwnProperty("events")) {
                if (!Array.isArray(message.events))
                    return "events: array expected";
                for (var i = 0; i < message.events.length; ++i) {
                    var error = $root.vmm.GuestEvent.verify(message.events[i]);
                    if (error)
                        return "events." + error;
                }
            }
            return null;
        };
        /**
         * Creates a VmInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vmm.VmInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vmm.VmInfo} VmInfo
         */
        VmInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.vmm.VmInfo)
                return object;
            var message = new $root.vmm.VmInfo();
            if (object.id != null)
                message.id = String(object.id);
            if (object.name != null)
                message.name = String(object.name);
            if (object.status != null)
                message.status = String(object.status);
            if (object.uptime != null)
                message.uptime = String(object.uptime);
            if (object.app_url != null)
                message.app_url = String(object.app_url);
            if (object.app_id != null)
                message.app_id = String(object.app_id);
            if (object.instance_id != null)
                message.instance_id = String(object.instance_id);
            if (object.configuration != null) {
                if (typeof object.configuration !== "object")
                    throw TypeError(".vmm.VmInfo.configuration: object expected");
                message.configuration = $root.vmm.VmConfiguration.fromObject(object.configuration);
            }
            if (object.exited_at != null)
                message.exited_at = String(object.exited_at);
            if (object.boot_progress != null)
                message.boot_progress = String(object.boot_progress);
            if (object.boot_error != null)
                message.boot_error = String(object.boot_error);
            if (object.shutdown_progress != null)
                message.shutdown_progress = String(object.shutdown_progress);
            if (object.image_version != null)
                message.image_version = String(object.image_version);
            if (object.events) {
                if (!Array.isArray(object.events))
                    throw TypeError(".vmm.VmInfo.events: array expected");
                message.events = [];
                for (var i = 0; i < object.events.length; ++i) {
                    if (typeof object.events[i] !== "object")
                        throw TypeError(".vmm.VmInfo.events: object expected");
                    message.events[i] = $root.vmm.GuestEvent.fromObject(object.events[i]);
                }
            }
            return message;
        };
        /**
         * Creates a plain object from a VmInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vmm.VmInfo
         * @static
         * @param {vmm.VmInfo} message VmInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VmInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.events = [];
            if (options.defaults) {
                object.id = "";
                object.name = "";
                object.status = "";
                object.uptime = "";
                object.app_id = "";
                object.configuration = null;
                object.boot_progress = "";
                object.boot_error = "";
                object.shutdown_progress = "";
                object.image_version = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = message.status;
            if (message.uptime != null && message.hasOwnProperty("uptime"))
                object.uptime = message.uptime;
            if (message.app_url != null && message.hasOwnProperty("app_url")) {
                object.app_url = message.app_url;
                if (options.oneofs)
                    object._app_url = "app_url";
            }
            if (message.app_id != null && message.hasOwnProperty("app_id"))
                object.app_id = message.app_id;
            if (message.instance_id != null && message.hasOwnProperty("instance_id")) {
                object.instance_id = message.instance_id;
                if (options.oneofs)
                    object._instance_id = "instance_id";
            }
            if (message.configuration != null && message.hasOwnProperty("configuration"))
                object.configuration = $root.vmm.VmConfiguration.toObject(message.configuration, options);
            if (message.exited_at != null && message.hasOwnProperty("exited_at")) {
                object.exited_at = message.exited_at;
                if (options.oneofs)
                    object._exited_at = "exited_at";
            }
            if (message.boot_progress != null && message.hasOwnProperty("boot_progress"))
                object.boot_progress = message.boot_progress;
            if (message.boot_error != null && message.hasOwnProperty("boot_error"))
                object.boot_error = message.boot_error;
            if (message.shutdown_progress != null && message.hasOwnProperty("shutdown_progress"))
                object.shutdown_progress = message.shutdown_progress;
            if (message.image_version != null && message.hasOwnProperty("image_version"))
                object.image_version = message.image_version;
            if (message.events && message.events.length) {
                object.events = [];
                for (var j = 0; j < message.events.length; ++j)
                    object.events[j] = $root.vmm.GuestEvent.toObject(message.events[j], options);
            }
            return object;
        };
        /**
         * Converts this VmInfo to JSON.
         * @function toJSON
         * @memberof vmm.VmInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VmInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * Gets the default type url for VmInfo
         * @function getTypeUrl
         * @memberof vmm.VmInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        VmInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/vmm.VmInfo";
        };
        return VmInfo;
    })();
    vmm.GuestEvent = (function () {
        /**
         * Properties of a GuestEvent.
         * @memberof vmm
         * @interface IGuestEvent
         * @property {string|null} [event] GuestEvent event
         * @property {string|null} [body] GuestEvent body
         * @property {number|Long|null} [timestamp] GuestEvent timestamp
         */
        /**
         * Constructs a new GuestEvent.
         * @memberof vmm
         * @classdesc Represents a GuestEvent.
         * @implements IGuestEvent
         * @constructor
         * @param {vmm.IGuestEvent=} [properties] Properties to set
         */
        function GuestEvent(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * GuestEvent event.
         * @member {string} event
         * @memberof vmm.GuestEvent
         * @instance
         */
        GuestEvent.prototype.event = "";
        /**
         * GuestEvent body.
         * @member {string} body
         * @memberof vmm.GuestEvent
         * @instance
         */
        GuestEvent.prototype.body = "";
        /**
         * GuestEvent timestamp.
         * @member {number|Long} timestamp
         * @memberof vmm.GuestEvent
         * @instance
         */
        GuestEvent.prototype.timestamp = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        /**
         * Creates a new GuestEvent instance using the specified properties.
         * @function create
         * @memberof vmm.GuestEvent
         * @static
         * @param {vmm.IGuestEvent=} [properties] Properties to set
         * @returns {vmm.GuestEvent} GuestEvent instance
         */
        GuestEvent.create = function create(properties) {
            return new GuestEvent(properties);
        };
        /**
         * Encodes the specified GuestEvent message. Does not implicitly {@link vmm.GuestEvent.verify|verify} messages.
         * @function encode
         * @memberof vmm.GuestEvent
         * @static
         * @param {vmm.IGuestEvent} message GuestEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuestEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.event != null && Object.hasOwnProperty.call(message, "event"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.event);
            if (message.body != null && Object.hasOwnProperty.call(message, "body"))
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.body);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 3, wireType 0 =*/ 24).uint64(message.timestamp);
            return writer;
        };
        /**
         * Encodes the specified GuestEvent message, length delimited. Does not implicitly {@link vmm.GuestEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vmm.GuestEvent
         * @static
         * @param {vmm.IGuestEvent} message GuestEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuestEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a GuestEvent message from the specified reader or buffer.
         * @function decode
         * @memberof vmm.GuestEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vmm.GuestEvent} GuestEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuestEvent.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vmm.GuestEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                    case 1: {
                        message.event = reader.string();
                        break;
                    }
                    case 2: {
                        message.body = reader.string();
                        break;
                    }
                    case 3: {
                        message.timestamp = reader.uint64();
                        break;
                    }
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a GuestEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vmm.GuestEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vmm.GuestEvent} GuestEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuestEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a GuestEvent message.
         * @function verify
         * @memberof vmm.GuestEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GuestEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.event != null && message.hasOwnProperty("event"))
                if (!$util.isString(message.event))
                    return "event: string expected";
            if (message.body != null && message.hasOwnProperty("body"))
                if (!$util.isString(message.body))
                    return "body: string expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            return null;
        };
        /**
         * Creates a GuestEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vmm.GuestEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vmm.GuestEvent} GuestEvent
         */
        GuestEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.vmm.GuestEvent)
                return object;
            var message = new $root.vmm.GuestEvent();
            if (object.event != null)
                message.event = String(object.event);
            if (object.body != null)
                message.body = String(object.body);
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
            return message;
        };
        /**
         * Creates a plain object from a GuestEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vmm.GuestEvent
         * @static
         * @param {vmm.GuestEvent} message GuestEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GuestEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.event = "";
                object.body = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.timestamp = options.longs === String ? "0" : 0;
            }
            if (message.event != null && message.hasOwnProperty("event"))
                object.event = message.event;
            if (message.body != null && message.hasOwnProperty("body"))
                object.body = message.body;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
            return object;
        };
        /**
         * Converts this GuestEvent to JSON.
         * @function toJSON
         * @memberof vmm.GuestEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GuestEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * Gets the default type url for GuestEvent
         * @function getTypeUrl
         * @memberof vmm.GuestEvent
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GuestEvent.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/vmm.GuestEvent";
        };
        return GuestEvent;
    })();
    vmm.Id = (function () {
        /**
         * Properties of an Id.
         * @memberof vmm
         * @interface IId
         * @property {string|null} [id] Id id
         */
        /**
         * Constructs a new Id.
         * @memberof vmm
         * @classdesc Represents an Id.
         * @implements IId
         * @constructor
         * @param {vmm.IId=} [properties] Properties to set
         */
        function Id(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Id id.
         * @member {string} id
         * @memberof vmm.Id
         * @instance
         */
        Id.prototype.id = "";
        /**
         * Creates a new Id instance using the specified properties.
         * @function create
         * @memberof vmm.Id
         * @static
         * @param {vmm.IId=} [properties] Properties to set
         * @returns {vmm.Id} Id instance
         */
        Id.create = function create(properties) {
            return new Id(properties);
        };
        /**
         * Encodes the specified Id message. Does not implicitly {@link vmm.Id.verify|verify} messages.
         * @function encode
         * @memberof vmm.Id
         * @static
         * @param {vmm.IId} message Id message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Id.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.id);
            return writer;
        };
        /**
         * Encodes the specified Id message, length delimited. Does not implicitly {@link vmm.Id.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vmm.Id
         * @static
         * @param {vmm.IId} message Id message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Id.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an Id message from the specified reader or buffer.
         * @function decode
         * @memberof vmm.Id
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vmm.Id} Id
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Id.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vmm.Id();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                    case 1: {
                        message.id = reader.string();
                        break;
                    }
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an Id message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vmm.Id
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vmm.Id} Id
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Id.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an Id message.
         * @function verify
         * @memberof vmm.Id
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Id.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            return null;
        };
        /**
         * Creates an Id message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vmm.Id
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vmm.Id} Id
         */
        Id.fromObject = function fromObject(object) {
            if (object instanceof $root.vmm.Id)
                return object;
            var message = new $root.vmm.Id();
            if (object.id != null)
                message.id = String(object.id);
            return message;
        };
        /**
         * Creates a plain object from an Id message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vmm.Id
         * @static
         * @param {vmm.Id} message Id
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Id.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.id = "";
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            return object;
        };
        /**
         * Converts this Id to JSON.
         * @function toJSON
         * @memberof vmm.Id
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Id.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * Gets the default type url for Id
         * @function getTypeUrl
         * @memberof vmm.Id
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Id.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/vmm.Id";
        };
        return Id;
    })();
    vmm.ComposeHash = (function () {
        /**
         * Properties of a ComposeHash.
         * @memberof vmm
         * @interface IComposeHash
         * @property {string|null} [hash] ComposeHash hash
         */
        /**
         * Constructs a new ComposeHash.
         * @memberof vmm
         * @classdesc Represents a ComposeHash.
         * @implements IComposeHash
         * @constructor
         * @param {vmm.IComposeHash=} [properties] Properties to set
         */
        function ComposeHash(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ComposeHash hash.
         * @member {string} hash
         * @memberof vmm.ComposeHash
         * @instance
         */
        ComposeHash.prototype.hash = "";
        /**
         * Creates a new ComposeHash instance using the specified properties.
         * @function create
         * @memberof vmm.ComposeHash
         * @static
         * @param {vmm.IComposeHash=} [properties] Properties to set
         * @returns {vmm.ComposeHash} ComposeHash instance
         */
        ComposeHash.create = function create(properties) {
            return new ComposeHash(properties);
        };
        /**
         * Encodes the specified ComposeHash message. Does not implicitly {@link vmm.ComposeHash.verify|verify} messages.
         * @function encode
         * @memberof vmm.ComposeHash
         * @static
         * @param {vmm.IComposeHash} message ComposeHash message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ComposeHash.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.hash);
            return writer;
        };
        /**
         * Encodes the specified ComposeHash message, length delimited. Does not implicitly {@link vmm.ComposeHash.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vmm.ComposeHash
         * @static
         * @param {vmm.IComposeHash} message ComposeHash message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ComposeHash.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a ComposeHash message from the specified reader or buffer.
         * @function decode
         * @memberof vmm.ComposeHash
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vmm.ComposeHash} ComposeHash
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ComposeHash.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vmm.ComposeHash();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                    case 1: {
                        message.hash = reader.string();
                        break;
                    }
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a ComposeHash message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vmm.ComposeHash
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vmm.ComposeHash} ComposeHash
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ComposeHash.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a ComposeHash message.
         * @function verify
         * @memberof vmm.ComposeHash
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ComposeHash.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hash != null && message.hasOwnProperty("hash"))
                if (!$util.isString(message.hash))
                    return "hash: string expected";
            return null;
        };
        /**
         * Creates a ComposeHash message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vmm.ComposeHash
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vmm.ComposeHash} ComposeHash
         */
        ComposeHash.fromObject = function fromObject(object) {
            if (object instanceof $root.vmm.ComposeHash)
                return object;
            var message = new $root.vmm.ComposeHash();
            if (object.hash != null)
                message.hash = String(object.hash);
            return message;
        };
        /**
         * Creates a plain object from a ComposeHash message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vmm.ComposeHash
         * @static
         * @param {vmm.ComposeHash} message ComposeHash
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ComposeHash.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.hash = "";
            if (message.hash != null && message.hasOwnProperty("hash"))
                object.hash = message.hash;
            return object;
        };
        /**
         * Converts this ComposeHash to JSON.
         * @function toJSON
         * @memberof vmm.ComposeHash
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ComposeHash.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * Gets the default type url for ComposeHash
         * @function getTypeUrl
         * @memberof vmm.ComposeHash
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ComposeHash.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/vmm.ComposeHash";
        };
        return ComposeHash;
    })();
    vmm.VmConfiguration = (function () {
        /**
         * Properties of a VmConfiguration.
         * @memberof vmm
         * @interface IVmConfiguration
         * @property {string|null} [name] VmConfiguration name
         * @property {string|null} [image] VmConfiguration image
         * @property {string|null} [compose_file] VmConfiguration compose_file
         * @property {number|null} [vcpu] VmConfiguration vcpu
         * @property {number|null} [memory] VmConfiguration memory
         * @property {number|null} [disk_size] VmConfiguration disk_size
         * @property {Array.<vmm.IPortMapping>|null} [ports] VmConfiguration ports
         * @property {Uint8Array|null} [encrypted_env] VmConfiguration encrypted_env
         * @property {string|null} [app_id] VmConfiguration app_id
         * @property {string|null} [user_config] VmConfiguration user_config
         * @property {boolean|null} [hugepages] VmConfiguration hugepages
         * @property {boolean|null} [pin_numa] VmConfiguration pin_numa
         * @property {vmm.IGpuConfig|null} [gpus] VmConfiguration gpus
         * @property {Array.<string>|null} [kms_urls] VmConfiguration kms_urls
         * @property {Array.<string>|null} [gateway_urls] VmConfiguration gateway_urls
         * @property {boolean|null} [stopped] VmConfiguration stopped
         * @property {boolean|null} [no_tee] VmConfiguration no_tee
         */
        /**
         * Constructs a new VmConfiguration.
         * @memberof vmm
         * @classdesc Represents a VmConfiguration.
         * @implements IVmConfiguration
         * @constructor
         * @param {vmm.IVmConfiguration=} [properties] Properties to set
         */
        function VmConfiguration(properties) {
            this.ports = [];
            this.kms_urls = [];
            this.gateway_urls = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * VmConfiguration name.
         * @member {string} name
         * @memberof vmm.VmConfiguration
         * @instance
         */
        VmConfiguration.prototype.name = "";
        /**
         * VmConfiguration image.
         * @member {string} image
         * @memberof vmm.VmConfiguration
         * @instance
         */
        VmConfiguration.prototype.image = "";
        /**
         * VmConfiguration compose_file.
         * @member {string} compose_file
         * @memberof vmm.VmConfiguration
         * @instance
         */
        VmConfiguration.prototype.compose_file = "";
        /**
         * VmConfiguration vcpu.
         * @member {number} vcpu
         * @memberof vmm.VmConfiguration
         * @instance
         */
        VmConfiguration.prototype.vcpu = 0;
        /**
         * VmConfiguration memory.
         * @member {number} memory
         * @memberof vmm.VmConfiguration
         * @instance
         */
        VmConfiguration.prototype.memory = 0;
        /**
         * VmConfiguration disk_size.
         * @member {number} disk_size
         * @memberof vmm.VmConfiguration
         * @instance
         */
        VmConfiguration.prototype.disk_size = 0;
        /**
         * VmConfiguration ports.
         * @member {Array.<vmm.IPortMapping>} ports
         * @memberof vmm.VmConfiguration
         * @instance
         */
        VmConfiguration.prototype.ports = $util.emptyArray;
        /**
         * VmConfiguration encrypted_env.
         * @member {Uint8Array} encrypted_env
         * @memberof vmm.VmConfiguration
         * @instance
         */
        VmConfiguration.prototype.encrypted_env = $util.newBuffer([]);
        /**
         * VmConfiguration app_id.
         * @member {string|null|undefined} app_id
         * @memberof vmm.VmConfiguration
         * @instance
         */
        VmConfiguration.prototype.app_id = null;
        /**
         * VmConfiguration user_config.
         * @member {string} user_config
         * @memberof vmm.VmConfiguration
         * @instance
         */
        VmConfiguration.prototype.user_config = "";
        /**
         * VmConfiguration hugepages.
         * @member {boolean} hugepages
         * @memberof vmm.VmConfiguration
         * @instance
         */
        VmConfiguration.prototype.hugepages = false;
        /**
         * VmConfiguration pin_numa.
         * @member {boolean} pin_numa
         * @memberof vmm.VmConfiguration
         * @instance
         */
        VmConfiguration.prototype.pin_numa = false;
        /**
         * VmConfiguration gpus.
         * @member {vmm.IGpuConfig|null|undefined} gpus
         * @memberof vmm.VmConfiguration
         * @instance
         */
        VmConfiguration.prototype.gpus = null;
        /**
         * VmConfiguration kms_urls.
         * @member {Array.<string>} kms_urls
         * @memberof vmm.VmConfiguration
         * @instance
         */
        VmConfiguration.prototype.kms_urls = $util.emptyArray;
        /**
         * VmConfiguration gateway_urls.
         * @member {Array.<string>} gateway_urls
         * @memberof vmm.VmConfiguration
         * @instance
         */
        VmConfiguration.prototype.gateway_urls = $util.emptyArray;
        /**
         * VmConfiguration stopped.
         * @member {boolean} stopped
         * @memberof vmm.VmConfiguration
         * @instance
         */
        VmConfiguration.prototype.stopped = false;
        /**
         * VmConfiguration no_tee.
         * @member {boolean} no_tee
         * @memberof vmm.VmConfiguration
         * @instance
         */
        VmConfiguration.prototype.no_tee = false;
        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;
        /**
         * VmConfiguration _app_id.
         * @member {"app_id"|undefined} _app_id
         * @memberof vmm.VmConfiguration
         * @instance
         */
        Object.defineProperty(VmConfiguration.prototype, "_app_id", {
            get: $util.oneOfGetter($oneOfFields = ["app_id"]),
            set: $util.oneOfSetter($oneOfFields)
        });
        /**
         * Creates a new VmConfiguration instance using the specified properties.
         * @function create
         * @memberof vmm.VmConfiguration
         * @static
         * @param {vmm.IVmConfiguration=} [properties] Properties to set
         * @returns {vmm.VmConfiguration} VmConfiguration instance
         */
        VmConfiguration.create = function create(properties) {
            return new VmConfiguration(properties);
        };
        /**
         * Encodes the specified VmConfiguration message. Does not implicitly {@link vmm.VmConfiguration.verify|verify} messages.
         * @function encode
         * @memberof vmm.VmConfiguration
         * @static
         * @param {vmm.IVmConfiguration} message VmConfiguration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VmConfiguration.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
            if (message.image != null && Object.hasOwnProperty.call(message, "image"))
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.image);
            if (message.compose_file != null && Object.hasOwnProperty.call(message, "compose_file"))
                writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.compose_file);
            if (message.vcpu != null && Object.hasOwnProperty.call(message, "vcpu"))
                writer.uint32(/* id 4, wireType 0 =*/ 32).uint32(message.vcpu);
            if (message.memory != null && Object.hasOwnProperty.call(message, "memory"))
                writer.uint32(/* id 5, wireType 0 =*/ 40).uint32(message.memory);
            if (message.disk_size != null && Object.hasOwnProperty.call(message, "disk_size"))
                writer.uint32(/* id 6, wireType 0 =*/ 48).uint32(message.disk_size);
            if (message.ports != null && message.ports.length)
                for (var i = 0; i < message.ports.length; ++i)
                    $root.vmm.PortMapping.encode(message.ports[i], writer.uint32(/* id 7, wireType 2 =*/ 58).fork()).ldelim();
            if (message.encrypted_env != null && Object.hasOwnProperty.call(message, "encrypted_env"))
                writer.uint32(/* id 8, wireType 2 =*/ 66).bytes(message.encrypted_env);
            if (message.app_id != null && Object.hasOwnProperty.call(message, "app_id"))
                writer.uint32(/* id 9, wireType 2 =*/ 74).string(message.app_id);
            if (message.user_config != null && Object.hasOwnProperty.call(message, "user_config"))
                writer.uint32(/* id 10, wireType 2 =*/ 82).string(message.user_config);
            if (message.hugepages != null && Object.hasOwnProperty.call(message, "hugepages"))
                writer.uint32(/* id 11, wireType 0 =*/ 88).bool(message.hugepages);
            if (message.pin_numa != null && Object.hasOwnProperty.call(message, "pin_numa"))
                writer.uint32(/* id 12, wireType 0 =*/ 96).bool(message.pin_numa);
            if (message.gpus != null && Object.hasOwnProperty.call(message, "gpus"))
                $root.vmm.GpuConfig.encode(message.gpus, writer.uint32(/* id 13, wireType 2 =*/ 106).fork()).ldelim();
            if (message.kms_urls != null && message.kms_urls.length)
                for (var i = 0; i < message.kms_urls.length; ++i)
                    writer.uint32(/* id 14, wireType 2 =*/ 114).string(message.kms_urls[i]);
            if (message.gateway_urls != null && message.gateway_urls.length)
                for (var i = 0; i < message.gateway_urls.length; ++i)
                    writer.uint32(/* id 15, wireType 2 =*/ 122).string(message.gateway_urls[i]);
            if (message.stopped != null && Object.hasOwnProperty.call(message, "stopped"))
                writer.uint32(/* id 16, wireType 0 =*/ 128).bool(message.stopped);
            if (message.no_tee != null && Object.hasOwnProperty.call(message, "no_tee"))
                writer.uint32(/* id 17, wireType 0 =*/ 136).bool(message.no_tee);
            return writer;
        };
        /**
         * Encodes the specified VmConfiguration message, length delimited. Does not implicitly {@link vmm.VmConfiguration.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vmm.VmConfiguration
         * @static
         * @param {vmm.IVmConfiguration} message VmConfiguration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VmConfiguration.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a VmConfiguration message from the specified reader or buffer.
         * @function decode
         * @memberof vmm.VmConfiguration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vmm.VmConfiguration} VmConfiguration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VmConfiguration.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vmm.VmConfiguration();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                    case 1: {
                        message.name = reader.string();
                        break;
                    }
                    case 2: {
                        message.image = reader.string();
                        break;
                    }
                    case 3: {
                        message.compose_file = reader.string();
                        break;
                    }
                    case 4: {
                        message.vcpu = reader.uint32();
                        break;
                    }
                    case 5: {
                        message.memory = reader.uint32();
                        break;
                    }
                    case 6: {
                        message.disk_size = reader.uint32();
                        break;
                    }
                    case 7: {
                        if (!(message.ports && message.ports.length))
                            message.ports = [];
                        message.ports.push($root.vmm.PortMapping.decode(reader, reader.uint32()));
                        break;
                    }
                    case 8: {
                        message.encrypted_env = reader.bytes();
                        break;
                    }
                    case 9: {
                        message.app_id = reader.string();
                        break;
                    }
                    case 10: {
                        message.user_config = reader.string();
                        break;
                    }
                    case 11: {
                        message.hugepages = reader.bool();
                        break;
                    }
                    case 12: {
                        message.pin_numa = reader.bool();
                        break;
                    }
                    case 13: {
                        message.gpus = $root.vmm.GpuConfig.decode(reader, reader.uint32());
                        break;
                    }
                    case 14: {
                        if (!(message.kms_urls && message.kms_urls.length))
                            message.kms_urls = [];
                        message.kms_urls.push(reader.string());
                        break;
                    }
                    case 15: {
                        if (!(message.gateway_urls && message.gateway_urls.length))
                            message.gateway_urls = [];
                        message.gateway_urls.push(reader.string());
                        break;
                    }
                    case 16: {
                        message.stopped = reader.bool();
                        break;
                    }
                    case 17: {
                        message.no_tee = reader.bool();
                        break;
                    }
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a VmConfiguration message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vmm.VmConfiguration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vmm.VmConfiguration} VmConfiguration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VmConfiguration.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a VmConfiguration message.
         * @function verify
         * @memberof vmm.VmConfiguration
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VmConfiguration.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.image != null && message.hasOwnProperty("image"))
                if (!$util.isString(message.image))
                    return "image: string expected";
            if (message.compose_file != null && message.hasOwnProperty("compose_file"))
                if (!$util.isString(message.compose_file))
                    return "compose_file: string expected";
            if (message.vcpu != null && message.hasOwnProperty("vcpu"))
                if (!$util.isInteger(message.vcpu))
                    return "vcpu: integer expected";
            if (message.memory != null && message.hasOwnProperty("memory"))
                if (!$util.isInteger(message.memory))
                    return "memory: integer expected";
            if (message.disk_size != null && message.hasOwnProperty("disk_size"))
                if (!$util.isInteger(message.disk_size))
                    return "disk_size: integer expected";
            if (message.ports != null && message.hasOwnProperty("ports")) {
                if (!Array.isArray(message.ports))
                    return "ports: array expected";
                for (var i = 0; i < message.ports.length; ++i) {
                    var error = $root.vmm.PortMapping.verify(message.ports[i]);
                    if (error)
                        return "ports." + error;
                }
            }
            if (message.encrypted_env != null && message.hasOwnProperty("encrypted_env"))
                if (!(message.encrypted_env && typeof message.encrypted_env.length === "number" || $util.isString(message.encrypted_env)))
                    return "encrypted_env: buffer expected";
            if (message.app_id != null && message.hasOwnProperty("app_id")) {
                properties._app_id = 1;
                if (!$util.isString(message.app_id))
                    return "app_id: string expected";
            }
            if (message.user_config != null && message.hasOwnProperty("user_config"))
                if (!$util.isString(message.user_config))
                    return "user_config: string expected";
            if (message.hugepages != null && message.hasOwnProperty("hugepages"))
                if (typeof message.hugepages !== "boolean")
                    return "hugepages: boolean expected";
            if (message.pin_numa != null && message.hasOwnProperty("pin_numa"))
                if (typeof message.pin_numa !== "boolean")
                    return "pin_numa: boolean expected";
            if (message.gpus != null && message.hasOwnProperty("gpus")) {
                var error = $root.vmm.GpuConfig.verify(message.gpus);
                if (error)
                    return "gpus." + error;
            }
            if (message.kms_urls != null && message.hasOwnProperty("kms_urls")) {
                if (!Array.isArray(message.kms_urls))
                    return "kms_urls: array expected";
                for (var i = 0; i < message.kms_urls.length; ++i)
                    if (!$util.isString(message.kms_urls[i]))
                        return "kms_urls: string[] expected";
            }
            if (message.gateway_urls != null && message.hasOwnProperty("gateway_urls")) {
                if (!Array.isArray(message.gateway_urls))
                    return "gateway_urls: array expected";
                for (var i = 0; i < message.gateway_urls.length; ++i)
                    if (!$util.isString(message.gateway_urls[i]))
                        return "gateway_urls: string[] expected";
            }
            if (message.stopped != null && message.hasOwnProperty("stopped"))
                if (typeof message.stopped !== "boolean")
                    return "stopped: boolean expected";
            if (message.no_tee != null && message.hasOwnProperty("no_tee"))
                if (typeof message.no_tee !== "boolean")
                    return "no_tee: boolean expected";
            return null;
        };
        /**
         * Creates a VmConfiguration message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vmm.VmConfiguration
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vmm.VmConfiguration} VmConfiguration
         */
        VmConfiguration.fromObject = function fromObject(object) {
            if (object instanceof $root.vmm.VmConfiguration)
                return object;
            var message = new $root.vmm.VmConfiguration();
            if (object.name != null)
                message.name = String(object.name);
            if (object.image != null)
                message.image = String(object.image);
            if (object.compose_file != null)
                message.compose_file = String(object.compose_file);
            if (object.vcpu != null)
                message.vcpu = object.vcpu >>> 0;
            if (object.memory != null)
                message.memory = object.memory >>> 0;
            if (object.disk_size != null)
                message.disk_size = object.disk_size >>> 0;
            if (object.ports) {
                if (!Array.isArray(object.ports))
                    throw TypeError(".vmm.VmConfiguration.ports: array expected");
                message.ports = [];
                for (var i = 0; i < object.ports.length; ++i) {
                    if (typeof object.ports[i] !== "object")
                        throw TypeError(".vmm.VmConfiguration.ports: object expected");
                    message.ports[i] = $root.vmm.PortMapping.fromObject(object.ports[i]);
                }
            }
            if (object.encrypted_env != null)
                if (typeof object.encrypted_env === "string")
                    $util.base64.decode(object.encrypted_env, message.encrypted_env = $util.newBuffer($util.base64.length(object.encrypted_env)), 0);
                else if (object.encrypted_env.length >= 0)
                    message.encrypted_env = object.encrypted_env;
            if (object.app_id != null)
                message.app_id = String(object.app_id);
            if (object.user_config != null)
                message.user_config = String(object.user_config);
            if (object.hugepages != null)
                message.hugepages = Boolean(object.hugepages);
            if (object.pin_numa != null)
                message.pin_numa = Boolean(object.pin_numa);
            if (object.gpus != null) {
                if (typeof object.gpus !== "object")
                    throw TypeError(".vmm.VmConfiguration.gpus: object expected");
                message.gpus = $root.vmm.GpuConfig.fromObject(object.gpus);
            }
            if (object.kms_urls) {
                if (!Array.isArray(object.kms_urls))
                    throw TypeError(".vmm.VmConfiguration.kms_urls: array expected");
                message.kms_urls = [];
                for (var i = 0; i < object.kms_urls.length; ++i)
                    message.kms_urls[i] = String(object.kms_urls[i]);
            }
            if (object.gateway_urls) {
                if (!Array.isArray(object.gateway_urls))
                    throw TypeError(".vmm.VmConfiguration.gateway_urls: array expected");
                message.gateway_urls = [];
                for (var i = 0; i < object.gateway_urls.length; ++i)
                    message.gateway_urls[i] = String(object.gateway_urls[i]);
            }
            if (object.stopped != null)
                message.stopped = Boolean(object.stopped);
            if (object.no_tee != null)
                message.no_tee = Boolean(object.no_tee);
            return message;
        };
        /**
         * Creates a plain object from a VmConfiguration message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vmm.VmConfiguration
         * @static
         * @param {vmm.VmConfiguration} message VmConfiguration
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VmConfiguration.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.ports = [];
                object.kms_urls = [];
                object.gateway_urls = [];
            }
            if (options.defaults) {
                object.name = "";
                object.image = "";
                object.compose_file = "";
                object.vcpu = 0;
                object.memory = 0;
                object.disk_size = 0;
                if (options.bytes === String)
                    object.encrypted_env = "";
                else {
                    object.encrypted_env = [];
                    if (options.bytes !== Array)
                        object.encrypted_env = $util.newBuffer(object.encrypted_env);
                }
                object.user_config = "";
                object.hugepages = false;
                object.pin_numa = false;
                object.gpus = null;
                object.stopped = false;
                object.no_tee = false;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.image != null && message.hasOwnProperty("image"))
                object.image = message.image;
            if (message.compose_file != null && message.hasOwnProperty("compose_file"))
                object.compose_file = message.compose_file;
            if (message.vcpu != null && message.hasOwnProperty("vcpu"))
                object.vcpu = message.vcpu;
            if (message.memory != null && message.hasOwnProperty("memory"))
                object.memory = message.memory;
            if (message.disk_size != null && message.hasOwnProperty("disk_size"))
                object.disk_size = message.disk_size;
            if (message.ports && message.ports.length) {
                object.ports = [];
                for (var j = 0; j < message.ports.length; ++j)
                    object.ports[j] = $root.vmm.PortMapping.toObject(message.ports[j], options);
            }
            if (message.encrypted_env != null && message.hasOwnProperty("encrypted_env"))
                object.encrypted_env = options.bytes === String ? $util.base64.encode(message.encrypted_env, 0, message.encrypted_env.length) : options.bytes === Array ? Array.prototype.slice.call(message.encrypted_env) : message.encrypted_env;
            if (message.app_id != null && message.hasOwnProperty("app_id")) {
                object.app_id = message.app_id;
                if (options.oneofs)
                    object._app_id = "app_id";
            }
            if (message.user_config != null && message.hasOwnProperty("user_config"))
                object.user_config = message.user_config;
            if (message.hugepages != null && message.hasOwnProperty("hugepages"))
                object.hugepages = message.hugepages;
            if (message.pin_numa != null && message.hasOwnProperty("pin_numa"))
                object.pin_numa = message.pin_numa;
            if (message.gpus != null && message.hasOwnProperty("gpus"))
                object.gpus = $root.vmm.GpuConfig.toObject(message.gpus, options);
            if (message.kms_urls && message.kms_urls.length) {
                object.kms_urls = [];
                for (var j = 0; j < message.kms_urls.length; ++j)
                    object.kms_urls[j] = message.kms_urls[j];
            }
            if (message.gateway_urls && message.gateway_urls.length) {
                object.gateway_urls = [];
                for (var j = 0; j < message.gateway_urls.length; ++j)
                    object.gateway_urls[j] = message.gateway_urls[j];
            }
            if (message.stopped != null && message.hasOwnProperty("stopped"))
                object.stopped = message.stopped;
            if (message.no_tee != null && message.hasOwnProperty("no_tee"))
                object.no_tee = message.no_tee;
            return object;
        };
        /**
         * Converts this VmConfiguration to JSON.
         * @function toJSON
         * @memberof vmm.VmConfiguration
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VmConfiguration.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * Gets the default type url for VmConfiguration
         * @function getTypeUrl
         * @memberof vmm.VmConfiguration
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        VmConfiguration.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/vmm.VmConfiguration";
        };
        return VmConfiguration;
    })();
    vmm.GpuConfig = (function () {
        /**
         * Properties of a GpuConfig.
         * @memberof vmm
         * @interface IGpuConfig
         * @property {Array.<vmm.IGpuSpec>|null} [gpus] GpuConfig gpus
         * @property {string|null} [attach_mode] GpuConfig attach_mode
         */
        /**
         * Constructs a new GpuConfig.
         * @memberof vmm
         * @classdesc Represents a GpuConfig.
         * @implements IGpuConfig
         * @constructor
         * @param {vmm.IGpuConfig=} [properties] Properties to set
         */
        function GpuConfig(properties) {
            this.gpus = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * GpuConfig gpus.
         * @member {Array.<vmm.IGpuSpec>} gpus
         * @memberof vmm.GpuConfig
         * @instance
         */
        GpuConfig.prototype.gpus = $util.emptyArray;
        /**
         * GpuConfig attach_mode.
         * @member {string} attach_mode
         * @memberof vmm.GpuConfig
         * @instance
         */
        GpuConfig.prototype.attach_mode = "";
        /**
         * Creates a new GpuConfig instance using the specified properties.
         * @function create
         * @memberof vmm.GpuConfig
         * @static
         * @param {vmm.IGpuConfig=} [properties] Properties to set
         * @returns {vmm.GpuConfig} GpuConfig instance
         */
        GpuConfig.create = function create(properties) {
            return new GpuConfig(properties);
        };
        /**
         * Encodes the specified GpuConfig message. Does not implicitly {@link vmm.GpuConfig.verify|verify} messages.
         * @function encode
         * @memberof vmm.GpuConfig
         * @static
         * @param {vmm.IGpuConfig} message GpuConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GpuConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gpus != null && message.gpus.length)
                for (var i = 0; i < message.gpus.length; ++i)
                    $root.vmm.GpuSpec.encode(message.gpus[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.attach_mode != null && Object.hasOwnProperty.call(message, "attach_mode"))
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.attach_mode);
            return writer;
        };
        /**
         * Encodes the specified GpuConfig message, length delimited. Does not implicitly {@link vmm.GpuConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vmm.GpuConfig
         * @static
         * @param {vmm.IGpuConfig} message GpuConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GpuConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a GpuConfig message from the specified reader or buffer.
         * @function decode
         * @memberof vmm.GpuConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vmm.GpuConfig} GpuConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GpuConfig.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vmm.GpuConfig();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                    case 1: {
                        if (!(message.gpus && message.gpus.length))
                            message.gpus = [];
                        message.gpus.push($root.vmm.GpuSpec.decode(reader, reader.uint32()));
                        break;
                    }
                    case 2: {
                        message.attach_mode = reader.string();
                        break;
                    }
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a GpuConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vmm.GpuConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vmm.GpuConfig} GpuConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GpuConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a GpuConfig message.
         * @function verify
         * @memberof vmm.GpuConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GpuConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gpus != null && message.hasOwnProperty("gpus")) {
                if (!Array.isArray(message.gpus))
                    return "gpus: array expected";
                for (var i = 0; i < message.gpus.length; ++i) {
                    var error = $root.vmm.GpuSpec.verify(message.gpus[i]);
                    if (error)
                        return "gpus." + error;
                }
            }
            if (message.attach_mode != null && message.hasOwnProperty("attach_mode"))
                if (!$util.isString(message.attach_mode))
                    return "attach_mode: string expected";
            return null;
        };
        /**
         * Creates a GpuConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vmm.GpuConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vmm.GpuConfig} GpuConfig
         */
        GpuConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.vmm.GpuConfig)
                return object;
            var message = new $root.vmm.GpuConfig();
            if (object.gpus) {
                if (!Array.isArray(object.gpus))
                    throw TypeError(".vmm.GpuConfig.gpus: array expected");
                message.gpus = [];
                for (var i = 0; i < object.gpus.length; ++i) {
                    if (typeof object.gpus[i] !== "object")
                        throw TypeError(".vmm.GpuConfig.gpus: object expected");
                    message.gpus[i] = $root.vmm.GpuSpec.fromObject(object.gpus[i]);
                }
            }
            if (object.attach_mode != null)
                message.attach_mode = String(object.attach_mode);
            return message;
        };
        /**
         * Creates a plain object from a GpuConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vmm.GpuConfig
         * @static
         * @param {vmm.GpuConfig} message GpuConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GpuConfig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.gpus = [];
            if (options.defaults)
                object.attach_mode = "";
            if (message.gpus && message.gpus.length) {
                object.gpus = [];
                for (var j = 0; j < message.gpus.length; ++j)
                    object.gpus[j] = $root.vmm.GpuSpec.toObject(message.gpus[j], options);
            }
            if (message.attach_mode != null && message.hasOwnProperty("attach_mode"))
                object.attach_mode = message.attach_mode;
            return object;
        };
        /**
         * Converts this GpuConfig to JSON.
         * @function toJSON
         * @memberof vmm.GpuConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GpuConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * Gets the default type url for GpuConfig
         * @function getTypeUrl
         * @memberof vmm.GpuConfig
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GpuConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/vmm.GpuConfig";
        };
        return GpuConfig;
    })();
    vmm.GpuSpec = (function () {
        /**
         * Properties of a GpuSpec.
         * @memberof vmm
         * @interface IGpuSpec
         * @property {string|null} [slot] GpuSpec slot
         */
        /**
         * Constructs a new GpuSpec.
         * @memberof vmm
         * @classdesc Represents a GpuSpec.
         * @implements IGpuSpec
         * @constructor
         * @param {vmm.IGpuSpec=} [properties] Properties to set
         */
        function GpuSpec(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * GpuSpec slot.
         * @member {string} slot
         * @memberof vmm.GpuSpec
         * @instance
         */
        GpuSpec.prototype.slot = "";
        /**
         * Creates a new GpuSpec instance using the specified properties.
         * @function create
         * @memberof vmm.GpuSpec
         * @static
         * @param {vmm.IGpuSpec=} [properties] Properties to set
         * @returns {vmm.GpuSpec} GpuSpec instance
         */
        GpuSpec.create = function create(properties) {
            return new GpuSpec(properties);
        };
        /**
         * Encodes the specified GpuSpec message. Does not implicitly {@link vmm.GpuSpec.verify|verify} messages.
         * @function encode
         * @memberof vmm.GpuSpec
         * @static
         * @param {vmm.IGpuSpec} message GpuSpec message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GpuSpec.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.slot != null && Object.hasOwnProperty.call(message, "slot"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.slot);
            return writer;
        };
        /**
         * Encodes the specified GpuSpec message, length delimited. Does not implicitly {@link vmm.GpuSpec.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vmm.GpuSpec
         * @static
         * @param {vmm.IGpuSpec} message GpuSpec message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GpuSpec.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a GpuSpec message from the specified reader or buffer.
         * @function decode
         * @memberof vmm.GpuSpec
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vmm.GpuSpec} GpuSpec
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GpuSpec.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vmm.GpuSpec();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                    case 1: {
                        message.slot = reader.string();
                        break;
                    }
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a GpuSpec message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vmm.GpuSpec
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vmm.GpuSpec} GpuSpec
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GpuSpec.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a GpuSpec message.
         * @function verify
         * @memberof vmm.GpuSpec
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GpuSpec.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.slot != null && message.hasOwnProperty("slot"))
                if (!$util.isString(message.slot))
                    return "slot: string expected";
            return null;
        };
        /**
         * Creates a GpuSpec message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vmm.GpuSpec
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vmm.GpuSpec} GpuSpec
         */
        GpuSpec.fromObject = function fromObject(object) {
            if (object instanceof $root.vmm.GpuSpec)
                return object;
            var message = new $root.vmm.GpuSpec();
            if (object.slot != null)
                message.slot = String(object.slot);
            return message;
        };
        /**
         * Creates a plain object from a GpuSpec message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vmm.GpuSpec
         * @static
         * @param {vmm.GpuSpec} message GpuSpec
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GpuSpec.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.slot = "";
            if (message.slot != null && message.hasOwnProperty("slot"))
                object.slot = message.slot;
            return object;
        };
        /**
         * Converts this GpuSpec to JSON.
         * @function toJSON
         * @memberof vmm.GpuSpec
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GpuSpec.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * Gets the default type url for GpuSpec
         * @function getTypeUrl
         * @memberof vmm.GpuSpec
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GpuSpec.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/vmm.GpuSpec";
        };
        return GpuSpec;
    })();
    vmm.PortMapping = (function () {
        /**
         * Properties of a PortMapping.
         * @memberof vmm
         * @interface IPortMapping
         * @property {string|null} [protocol] PortMapping protocol
         * @property {number|null} [host_port] PortMapping host_port
         * @property {number|null} [vm_port] PortMapping vm_port
         * @property {string|null} [host_address] PortMapping host_address
         */
        /**
         * Constructs a new PortMapping.
         * @memberof vmm
         * @classdesc Represents a PortMapping.
         * @implements IPortMapping
         * @constructor
         * @param {vmm.IPortMapping=} [properties] Properties to set
         */
        function PortMapping(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * PortMapping protocol.
         * @member {string} protocol
         * @memberof vmm.PortMapping
         * @instance
         */
        PortMapping.prototype.protocol = "";
        /**
         * PortMapping host_port.
         * @member {number} host_port
         * @memberof vmm.PortMapping
         * @instance
         */
        PortMapping.prototype.host_port = 0;
        /**
         * PortMapping vm_port.
         * @member {number} vm_port
         * @memberof vmm.PortMapping
         * @instance
         */
        PortMapping.prototype.vm_port = 0;
        /**
         * PortMapping host_address.
         * @member {string} host_address
         * @memberof vmm.PortMapping
         * @instance
         */
        PortMapping.prototype.host_address = "";
        /**
         * Creates a new PortMapping instance using the specified properties.
         * @function create
         * @memberof vmm.PortMapping
         * @static
         * @param {vmm.IPortMapping=} [properties] Properties to set
         * @returns {vmm.PortMapping} PortMapping instance
         */
        PortMapping.create = function create(properties) {
            return new PortMapping(properties);
        };
        /**
         * Encodes the specified PortMapping message. Does not implicitly {@link vmm.PortMapping.verify|verify} messages.
         * @function encode
         * @memberof vmm.PortMapping
         * @static
         * @param {vmm.IPortMapping} message PortMapping message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PortMapping.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.protocol != null && Object.hasOwnProperty.call(message, "protocol"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.protocol);
            if (message.host_port != null && Object.hasOwnProperty.call(message, "host_port"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).uint32(message.host_port);
            if (message.vm_port != null && Object.hasOwnProperty.call(message, "vm_port"))
                writer.uint32(/* id 3, wireType 0 =*/ 24).uint32(message.vm_port);
            if (message.host_address != null && Object.hasOwnProperty.call(message, "host_address"))
                writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.host_address);
            return writer;
        };
        /**
         * Encodes the specified PortMapping message, length delimited. Does not implicitly {@link vmm.PortMapping.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vmm.PortMapping
         * @static
         * @param {vmm.IPortMapping} message PortMapping message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PortMapping.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a PortMapping message from the specified reader or buffer.
         * @function decode
         * @memberof vmm.PortMapping
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vmm.PortMapping} PortMapping
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PortMapping.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vmm.PortMapping();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                    case 1: {
                        message.protocol = reader.string();
                        break;
                    }
                    case 2: {
                        message.host_port = reader.uint32();
                        break;
                    }
                    case 3: {
                        message.vm_port = reader.uint32();
                        break;
                    }
                    case 4: {
                        message.host_address = reader.string();
                        break;
                    }
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a PortMapping message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vmm.PortMapping
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vmm.PortMapping} PortMapping
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PortMapping.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a PortMapping message.
         * @function verify
         * @memberof vmm.PortMapping
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PortMapping.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.protocol != null && message.hasOwnProperty("protocol"))
                if (!$util.isString(message.protocol))
                    return "protocol: string expected";
            if (message.host_port != null && message.hasOwnProperty("host_port"))
                if (!$util.isInteger(message.host_port))
                    return "host_port: integer expected";
            if (message.vm_port != null && message.hasOwnProperty("vm_port"))
                if (!$util.isInteger(message.vm_port))
                    return "vm_port: integer expected";
            if (message.host_address != null && message.hasOwnProperty("host_address"))
                if (!$util.isString(message.host_address))
                    return "host_address: string expected";
            return null;
        };
        /**
         * Creates a PortMapping message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vmm.PortMapping
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vmm.PortMapping} PortMapping
         */
        PortMapping.fromObject = function fromObject(object) {
            if (object instanceof $root.vmm.PortMapping)
                return object;
            var message = new $root.vmm.PortMapping();
            if (object.protocol != null)
                message.protocol = String(object.protocol);
            if (object.host_port != null)
                message.host_port = object.host_port >>> 0;
            if (object.vm_port != null)
                message.vm_port = object.vm_port >>> 0;
            if (object.host_address != null)
                message.host_address = String(object.host_address);
            return message;
        };
        /**
         * Creates a plain object from a PortMapping message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vmm.PortMapping
         * @static
         * @param {vmm.PortMapping} message PortMapping
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PortMapping.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.protocol = "";
                object.host_port = 0;
                object.vm_port = 0;
                object.host_address = "";
            }
            if (message.protocol != null && message.hasOwnProperty("protocol"))
                object.protocol = message.protocol;
            if (message.host_port != null && message.hasOwnProperty("host_port"))
                object.host_port = message.host_port;
            if (message.vm_port != null && message.hasOwnProperty("vm_port"))
                object.vm_port = message.vm_port;
            if (message.host_address != null && message.hasOwnProperty("host_address"))
                object.host_address = message.host_address;
            return object;
        };
        /**
         * Converts this PortMapping to JSON.
         * @function toJSON
         * @memberof vmm.PortMapping
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PortMapping.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * Gets the default type url for PortMapping
         * @function getTypeUrl
         * @memberof vmm.PortMapping
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PortMapping.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/vmm.PortMapping";
        };
        return PortMapping;
    })();
    vmm.UpdateVmRequest = (function () {
        /**
         * Properties of an UpdateVmRequest.
         * @memberof vmm
         * @interface IUpdateVmRequest
         * @property {string|null} [id] UpdateVmRequest id
         * @property {string|null} [compose_file] UpdateVmRequest compose_file
         * @property {Uint8Array|null} [encrypted_env] UpdateVmRequest encrypted_env
         * @property {string|null} [user_config] UpdateVmRequest user_config
         * @property {boolean|null} [update_ports] UpdateVmRequest update_ports
         * @property {Array.<vmm.IPortMapping>|null} [ports] UpdateVmRequest ports
         * @property {boolean|null} [update_kms_urls] UpdateVmRequest update_kms_urls
         * @property {Array.<string>|null} [kms_urls] UpdateVmRequest kms_urls
         * @property {boolean|null} [update_gateway_urls] UpdateVmRequest update_gateway_urls
         * @property {Array.<string>|null} [gateway_urls] UpdateVmRequest gateway_urls
         * @property {vmm.IGpuConfig|null} [gpus] UpdateVmRequest gpus
         * @property {number|null} [vcpu] UpdateVmRequest vcpu
         * @property {number|null} [memory] UpdateVmRequest memory
         * @property {number|null} [disk_size] UpdateVmRequest disk_size
         * @property {string|null} [image] UpdateVmRequest image
         * @property {boolean|null} [no_tee] UpdateVmRequest no_tee
         */
        /**
         * Constructs a new UpdateVmRequest.
         * @memberof vmm
         * @classdesc Represents an UpdateVmRequest.
         * @implements IUpdateVmRequest
         * @constructor
         * @param {vmm.IUpdateVmRequest=} [properties] Properties to set
         */
        function UpdateVmRequest(properties) {
            this.ports = [];
            this.kms_urls = [];
            this.gateway_urls = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * UpdateVmRequest id.
         * @member {string} id
         * @memberof vmm.UpdateVmRequest
         * @instance
         */
        UpdateVmRequest.prototype.id = "";
        /**
         * UpdateVmRequest compose_file.
         * @member {string} compose_file
         * @memberof vmm.UpdateVmRequest
         * @instance
         */
        UpdateVmRequest.prototype.compose_file = "";
        /**
         * UpdateVmRequest encrypted_env.
         * @member {Uint8Array} encrypted_env
         * @memberof vmm.UpdateVmRequest
         * @instance
         */
        UpdateVmRequest.prototype.encrypted_env = $util.newBuffer([]);
        /**
         * UpdateVmRequest user_config.
         * @member {string} user_config
         * @memberof vmm.UpdateVmRequest
         * @instance
         */
        UpdateVmRequest.prototype.user_config = "";
        /**
         * UpdateVmRequest update_ports.
         * @member {boolean} update_ports
         * @memberof vmm.UpdateVmRequest
         * @instance
         */
        UpdateVmRequest.prototype.update_ports = false;
        /**
         * UpdateVmRequest ports.
         * @member {Array.<vmm.IPortMapping>} ports
         * @memberof vmm.UpdateVmRequest
         * @instance
         */
        UpdateVmRequest.prototype.ports = $util.emptyArray;
        /**
         * UpdateVmRequest update_kms_urls.
         * @member {boolean} update_kms_urls
         * @memberof vmm.UpdateVmRequest
         * @instance
         */
        UpdateVmRequest.prototype.update_kms_urls = false;
        /**
         * UpdateVmRequest kms_urls.
         * @member {Array.<string>} kms_urls
         * @memberof vmm.UpdateVmRequest
         * @instance
         */
        UpdateVmRequest.prototype.kms_urls = $util.emptyArray;
        /**
         * UpdateVmRequest update_gateway_urls.
         * @member {boolean} update_gateway_urls
         * @memberof vmm.UpdateVmRequest
         * @instance
         */
        UpdateVmRequest.prototype.update_gateway_urls = false;
        /**
         * UpdateVmRequest gateway_urls.
         * @member {Array.<string>} gateway_urls
         * @memberof vmm.UpdateVmRequest
         * @instance
         */
        UpdateVmRequest.prototype.gateway_urls = $util.emptyArray;
        /**
         * UpdateVmRequest gpus.
         * @member {vmm.IGpuConfig|null|undefined} gpus
         * @memberof vmm.UpdateVmRequest
         * @instance
         */
        UpdateVmRequest.prototype.gpus = null;
        /**
         * UpdateVmRequest vcpu.
         * @member {number|null|undefined} vcpu
         * @memberof vmm.UpdateVmRequest
         * @instance
         */
        UpdateVmRequest.prototype.vcpu = null;
        /**
         * UpdateVmRequest memory.
         * @member {number|null|undefined} memory
         * @memberof vmm.UpdateVmRequest
         * @instance
         */
        UpdateVmRequest.prototype.memory = null;
        /**
         * UpdateVmRequest disk_size.
         * @member {number|null|undefined} disk_size
         * @memberof vmm.UpdateVmRequest
         * @instance
         */
        UpdateVmRequest.prototype.disk_size = null;
        /**
         * UpdateVmRequest image.
         * @member {string|null|undefined} image
         * @memberof vmm.UpdateVmRequest
         * @instance
         */
        UpdateVmRequest.prototype.image = null;
        /**
         * UpdateVmRequest no_tee.
         * @member {boolean|null|undefined} no_tee
         * @memberof vmm.UpdateVmRequest
         * @instance
         */
        UpdateVmRequest.prototype.no_tee = null;
        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;
        /**
         * UpdateVmRequest _vcpu.
         * @member {"vcpu"|undefined} _vcpu
         * @memberof vmm.UpdateVmRequest
         * @instance
         */
        Object.defineProperty(UpdateVmRequest.prototype, "_vcpu", {
            get: $util.oneOfGetter($oneOfFields = ["vcpu"]),
            set: $util.oneOfSetter($oneOfFields)
        });
        /**
         * UpdateVmRequest _memory.
         * @member {"memory"|undefined} _memory
         * @memberof vmm.UpdateVmRequest
         * @instance
         */
        Object.defineProperty(UpdateVmRequest.prototype, "_memory", {
            get: $util.oneOfGetter($oneOfFields = ["memory"]),
            set: $util.oneOfSetter($oneOfFields)
        });
        /**
         * UpdateVmRequest _disk_size.
         * @member {"disk_size"|undefined} _disk_size
         * @memberof vmm.UpdateVmRequest
         * @instance
         */
        Object.defineProperty(UpdateVmRequest.prototype, "_disk_size", {
            get: $util.oneOfGetter($oneOfFields = ["disk_size"]),
            set: $util.oneOfSetter($oneOfFields)
        });
        /**
         * UpdateVmRequest _image.
         * @member {"image"|undefined} _image
         * @memberof vmm.UpdateVmRequest
         * @instance
         */
        Object.defineProperty(UpdateVmRequest.prototype, "_image", {
            get: $util.oneOfGetter($oneOfFields = ["image"]),
            set: $util.oneOfSetter($oneOfFields)
        });
        /**
         * UpdateVmRequest _no_tee.
         * @member {"no_tee"|undefined} _no_tee
         * @memberof vmm.UpdateVmRequest
         * @instance
         */
        Object.defineProperty(UpdateVmRequest.prototype, "_no_tee", {
            get: $util.oneOfGetter($oneOfFields = ["no_tee"]),
            set: $util.oneOfSetter($oneOfFields)
        });
        /**
         * Creates a new UpdateVmRequest instance using the specified properties.
         * @function create
         * @memberof vmm.UpdateVmRequest
         * @static
         * @param {vmm.IUpdateVmRequest=} [properties] Properties to set
         * @returns {vmm.UpdateVmRequest} UpdateVmRequest instance
         */
        UpdateVmRequest.create = function create(properties) {
            return new UpdateVmRequest(properties);
        };
        /**
         * Encodes the specified UpdateVmRequest message. Does not implicitly {@link vmm.UpdateVmRequest.verify|verify} messages.
         * @function encode
         * @memberof vmm.UpdateVmRequest
         * @static
         * @param {vmm.IUpdateVmRequest} message UpdateVmRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateVmRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.id);
            if (message.compose_file != null && Object.hasOwnProperty.call(message, "compose_file"))
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.compose_file);
            if (message.encrypted_env != null && Object.hasOwnProperty.call(message, "encrypted_env"))
                writer.uint32(/* id 3, wireType 2 =*/ 26).bytes(message.encrypted_env);
            if (message.user_config != null && Object.hasOwnProperty.call(message, "user_config"))
                writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.user_config);
            if (message.update_ports != null && Object.hasOwnProperty.call(message, "update_ports"))
                writer.uint32(/* id 5, wireType 0 =*/ 40).bool(message.update_ports);
            if (message.ports != null && message.ports.length)
                for (var i = 0; i < message.ports.length; ++i)
                    $root.vmm.PortMapping.encode(message.ports[i], writer.uint32(/* id 7, wireType 2 =*/ 58).fork()).ldelim();
            if (message.update_kms_urls != null && Object.hasOwnProperty.call(message, "update_kms_urls"))
                writer.uint32(/* id 8, wireType 0 =*/ 64).bool(message.update_kms_urls);
            if (message.kms_urls != null && message.kms_urls.length)
                for (var i = 0; i < message.kms_urls.length; ++i)
                    writer.uint32(/* id 9, wireType 2 =*/ 74).string(message.kms_urls[i]);
            if (message.update_gateway_urls != null && Object.hasOwnProperty.call(message, "update_gateway_urls"))
                writer.uint32(/* id 10, wireType 0 =*/ 80).bool(message.update_gateway_urls);
            if (message.gateway_urls != null && message.gateway_urls.length)
                for (var i = 0; i < message.gateway_urls.length; ++i)
                    writer.uint32(/* id 11, wireType 2 =*/ 90).string(message.gateway_urls[i]);
            if (message.gpus != null && Object.hasOwnProperty.call(message, "gpus"))
                $root.vmm.GpuConfig.encode(message.gpus, writer.uint32(/* id 13, wireType 2 =*/ 106).fork()).ldelim();
            if (message.vcpu != null && Object.hasOwnProperty.call(message, "vcpu"))
                writer.uint32(/* id 14, wireType 0 =*/ 112).uint32(message.vcpu);
            if (message.memory != null && Object.hasOwnProperty.call(message, "memory"))
                writer.uint32(/* id 15, wireType 0 =*/ 120).uint32(message.memory);
            if (message.disk_size != null && Object.hasOwnProperty.call(message, "disk_size"))
                writer.uint32(/* id 16, wireType 0 =*/ 128).uint32(message.disk_size);
            if (message.image != null && Object.hasOwnProperty.call(message, "image"))
                writer.uint32(/* id 17, wireType 2 =*/ 138).string(message.image);
            if (message.no_tee != null && Object.hasOwnProperty.call(message, "no_tee"))
                writer.uint32(/* id 18, wireType 0 =*/ 144).bool(message.no_tee);
            return writer;
        };
        /**
         * Encodes the specified UpdateVmRequest message, length delimited. Does not implicitly {@link vmm.UpdateVmRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vmm.UpdateVmRequest
         * @static
         * @param {vmm.IUpdateVmRequest} message UpdateVmRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateVmRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an UpdateVmRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vmm.UpdateVmRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vmm.UpdateVmRequest} UpdateVmRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateVmRequest.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vmm.UpdateVmRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                    case 1: {
                        message.id = reader.string();
                        break;
                    }
                    case 2: {
                        message.compose_file = reader.string();
                        break;
                    }
                    case 3: {
                        message.encrypted_env = reader.bytes();
                        break;
                    }
                    case 4: {
                        message.user_config = reader.string();
                        break;
                    }
                    case 5: {
                        message.update_ports = reader.bool();
                        break;
                    }
                    case 7: {
                        if (!(message.ports && message.ports.length))
                            message.ports = [];
                        message.ports.push($root.vmm.PortMapping.decode(reader, reader.uint32()));
                        break;
                    }
                    case 8: {
                        message.update_kms_urls = reader.bool();
                        break;
                    }
                    case 9: {
                        if (!(message.kms_urls && message.kms_urls.length))
                            message.kms_urls = [];
                        message.kms_urls.push(reader.string());
                        break;
                    }
                    case 10: {
                        message.update_gateway_urls = reader.bool();
                        break;
                    }
                    case 11: {
                        if (!(message.gateway_urls && message.gateway_urls.length))
                            message.gateway_urls = [];
                        message.gateway_urls.push(reader.string());
                        break;
                    }
                    case 13: {
                        message.gpus = $root.vmm.GpuConfig.decode(reader, reader.uint32());
                        break;
                    }
                    case 14: {
                        message.vcpu = reader.uint32();
                        break;
                    }
                    case 15: {
                        message.memory = reader.uint32();
                        break;
                    }
                    case 16: {
                        message.disk_size = reader.uint32();
                        break;
                    }
                    case 17: {
                        message.image = reader.string();
                        break;
                    }
                    case 18: {
                        message.no_tee = reader.bool();
                        break;
                    }
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an UpdateVmRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vmm.UpdateVmRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vmm.UpdateVmRequest} UpdateVmRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateVmRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an UpdateVmRequest message.
         * @function verify
         * @memberof vmm.UpdateVmRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateVmRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.compose_file != null && message.hasOwnProperty("compose_file"))
                if (!$util.isString(message.compose_file))
                    return "compose_file: string expected";
            if (message.encrypted_env != null && message.hasOwnProperty("encrypted_env"))
                if (!(message.encrypted_env && typeof message.encrypted_env.length === "number" || $util.isString(message.encrypted_env)))
                    return "encrypted_env: buffer expected";
            if (message.user_config != null && message.hasOwnProperty("user_config"))
                if (!$util.isString(message.user_config))
                    return "user_config: string expected";
            if (message.update_ports != null && message.hasOwnProperty("update_ports"))
                if (typeof message.update_ports !== "boolean")
                    return "update_ports: boolean expected";
            if (message.ports != null && message.hasOwnProperty("ports")) {
                if (!Array.isArray(message.ports))
                    return "ports: array expected";
                for (var i = 0; i < message.ports.length; ++i) {
                    var error = $root.vmm.PortMapping.verify(message.ports[i]);
                    if (error)
                        return "ports." + error;
                }
            }
            if (message.update_kms_urls != null && message.hasOwnProperty("update_kms_urls"))
                if (typeof message.update_kms_urls !== "boolean")
                    return "update_kms_urls: boolean expected";
            if (message.kms_urls != null && message.hasOwnProperty("kms_urls")) {
                if (!Array.isArray(message.kms_urls))
                    return "kms_urls: array expected";
                for (var i = 0; i < message.kms_urls.length; ++i)
                    if (!$util.isString(message.kms_urls[i]))
                        return "kms_urls: string[] expected";
            }
            if (message.update_gateway_urls != null && message.hasOwnProperty("update_gateway_urls"))
                if (typeof message.update_gateway_urls !== "boolean")
                    return "update_gateway_urls: boolean expected";
            if (message.gateway_urls != null && message.hasOwnProperty("gateway_urls")) {
                if (!Array.isArray(message.gateway_urls))
                    return "gateway_urls: array expected";
                for (var i = 0; i < message.gateway_urls.length; ++i)
                    if (!$util.isString(message.gateway_urls[i]))
                        return "gateway_urls: string[] expected";
            }
            if (message.gpus != null && message.hasOwnProperty("gpus")) {
                var error = $root.vmm.GpuConfig.verify(message.gpus);
                if (error)
                    return "gpus." + error;
            }
            if (message.vcpu != null && message.hasOwnProperty("vcpu")) {
                properties._vcpu = 1;
                if (!$util.isInteger(message.vcpu))
                    return "vcpu: integer expected";
            }
            if (message.memory != null && message.hasOwnProperty("memory")) {
                properties._memory = 1;
                if (!$util.isInteger(message.memory))
                    return "memory: integer expected";
            }
            if (message.disk_size != null && message.hasOwnProperty("disk_size")) {
                properties._disk_size = 1;
                if (!$util.isInteger(message.disk_size))
                    return "disk_size: integer expected";
            }
            if (message.image != null && message.hasOwnProperty("image")) {
                properties._image = 1;
                if (!$util.isString(message.image))
                    return "image: string expected";
            }
            if (message.no_tee != null && message.hasOwnProperty("no_tee")) {
                properties._no_tee = 1;
                if (typeof message.no_tee !== "boolean")
                    return "no_tee: boolean expected";
            }
            return null;
        };
        /**
         * Creates an UpdateVmRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vmm.UpdateVmRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vmm.UpdateVmRequest} UpdateVmRequest
         */
        UpdateVmRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vmm.UpdateVmRequest)
                return object;
            var message = new $root.vmm.UpdateVmRequest();
            if (object.id != null)
                message.id = String(object.id);
            if (object.compose_file != null)
                message.compose_file = String(object.compose_file);
            if (object.encrypted_env != null)
                if (typeof object.encrypted_env === "string")
                    $util.base64.decode(object.encrypted_env, message.encrypted_env = $util.newBuffer($util.base64.length(object.encrypted_env)), 0);
                else if (object.encrypted_env.length >= 0)
                    message.encrypted_env = object.encrypted_env;
            if (object.user_config != null)
                message.user_config = String(object.user_config);
            if (object.update_ports != null)
                message.update_ports = Boolean(object.update_ports);
            if (object.ports) {
                if (!Array.isArray(object.ports))
                    throw TypeError(".vmm.UpdateVmRequest.ports: array expected");
                message.ports = [];
                for (var i = 0; i < object.ports.length; ++i) {
                    if (typeof object.ports[i] !== "object")
                        throw TypeError(".vmm.UpdateVmRequest.ports: object expected");
                    message.ports[i] = $root.vmm.PortMapping.fromObject(object.ports[i]);
                }
            }
            if (object.update_kms_urls != null)
                message.update_kms_urls = Boolean(object.update_kms_urls);
            if (object.kms_urls) {
                if (!Array.isArray(object.kms_urls))
                    throw TypeError(".vmm.UpdateVmRequest.kms_urls: array expected");
                message.kms_urls = [];
                for (var i = 0; i < object.kms_urls.length; ++i)
                    message.kms_urls[i] = String(object.kms_urls[i]);
            }
            if (object.update_gateway_urls != null)
                message.update_gateway_urls = Boolean(object.update_gateway_urls);
            if (object.gateway_urls) {
                if (!Array.isArray(object.gateway_urls))
                    throw TypeError(".vmm.UpdateVmRequest.gateway_urls: array expected");
                message.gateway_urls = [];
                for (var i = 0; i < object.gateway_urls.length; ++i)
                    message.gateway_urls[i] = String(object.gateway_urls[i]);
            }
            if (object.gpus != null) {
                if (typeof object.gpus !== "object")
                    throw TypeError(".vmm.UpdateVmRequest.gpus: object expected");
                message.gpus = $root.vmm.GpuConfig.fromObject(object.gpus);
            }
            if (object.vcpu != null)
                message.vcpu = object.vcpu >>> 0;
            if (object.memory != null)
                message.memory = object.memory >>> 0;
            if (object.disk_size != null)
                message.disk_size = object.disk_size >>> 0;
            if (object.image != null)
                message.image = String(object.image);
            if (object.no_tee != null)
                message.no_tee = Boolean(object.no_tee);
            return message;
        };
        /**
         * Creates a plain object from an UpdateVmRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vmm.UpdateVmRequest
         * @static
         * @param {vmm.UpdateVmRequest} message UpdateVmRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateVmRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.ports = [];
                object.kms_urls = [];
                object.gateway_urls = [];
            }
            if (options.defaults) {
                object.id = "";
                object.compose_file = "";
                if (options.bytes === String)
                    object.encrypted_env = "";
                else {
                    object.encrypted_env = [];
                    if (options.bytes !== Array)
                        object.encrypted_env = $util.newBuffer(object.encrypted_env);
                }
                object.user_config = "";
                object.update_ports = false;
                object.update_kms_urls = false;
                object.update_gateway_urls = false;
                object.gpus = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.compose_file != null && message.hasOwnProperty("compose_file"))
                object.compose_file = message.compose_file;
            if (message.encrypted_env != null && message.hasOwnProperty("encrypted_env"))
                object.encrypted_env = options.bytes === String ? $util.base64.encode(message.encrypted_env, 0, message.encrypted_env.length) : options.bytes === Array ? Array.prototype.slice.call(message.encrypted_env) : message.encrypted_env;
            if (message.user_config != null && message.hasOwnProperty("user_config"))
                object.user_config = message.user_config;
            if (message.update_ports != null && message.hasOwnProperty("update_ports"))
                object.update_ports = message.update_ports;
            if (message.ports && message.ports.length) {
                object.ports = [];
                for (var j = 0; j < message.ports.length; ++j)
                    object.ports[j] = $root.vmm.PortMapping.toObject(message.ports[j], options);
            }
            if (message.update_kms_urls != null && message.hasOwnProperty("update_kms_urls"))
                object.update_kms_urls = message.update_kms_urls;
            if (message.kms_urls && message.kms_urls.length) {
                object.kms_urls = [];
                for (var j = 0; j < message.kms_urls.length; ++j)
                    object.kms_urls[j] = message.kms_urls[j];
            }
            if (message.update_gateway_urls != null && message.hasOwnProperty("update_gateway_urls"))
                object.update_gateway_urls = message.update_gateway_urls;
            if (message.gateway_urls && message.gateway_urls.length) {
                object.gateway_urls = [];
                for (var j = 0; j < message.gateway_urls.length; ++j)
                    object.gateway_urls[j] = message.gateway_urls[j];
            }
            if (message.gpus != null && message.hasOwnProperty("gpus"))
                object.gpus = $root.vmm.GpuConfig.toObject(message.gpus, options);
            if (message.vcpu != null && message.hasOwnProperty("vcpu")) {
                object.vcpu = message.vcpu;
                if (options.oneofs)
                    object._vcpu = "vcpu";
            }
            if (message.memory != null && message.hasOwnProperty("memory")) {
                object.memory = message.memory;
                if (options.oneofs)
                    object._memory = "memory";
            }
            if (message.disk_size != null && message.hasOwnProperty("disk_size")) {
                object.disk_size = message.disk_size;
                if (options.oneofs)
                    object._disk_size = "disk_size";
            }
            if (message.image != null && message.hasOwnProperty("image")) {
                object.image = message.image;
                if (options.oneofs)
                    object._image = "image";
            }
            if (message.no_tee != null && message.hasOwnProperty("no_tee")) {
                object.no_tee = message.no_tee;
                if (options.oneofs)
                    object._no_tee = "no_tee";
            }
            return object;
        };
        /**
         * Converts this UpdateVmRequest to JSON.
         * @function toJSON
         * @memberof vmm.UpdateVmRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateVmRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * Gets the default type url for UpdateVmRequest
         * @function getTypeUrl
         * @memberof vmm.UpdateVmRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UpdateVmRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/vmm.UpdateVmRequest";
        };
        return UpdateVmRequest;
    })();
    vmm.StatusRequest = (function () {
        /**
         * Properties of a StatusRequest.
         * @memberof vmm
         * @interface IStatusRequest
         * @property {Array.<string>|null} [ids] StatusRequest ids
         * @property {boolean|null} [brief] StatusRequest brief
         * @property {string|null} [keyword] StatusRequest keyword
         * @property {number|null} [page] StatusRequest page
         * @property {number|null} [page_size] StatusRequest page_size
         */
        /**
         * Constructs a new StatusRequest.
         * @memberof vmm
         * @classdesc Represents a StatusRequest.
         * @implements IStatusRequest
         * @constructor
         * @param {vmm.IStatusRequest=} [properties] Properties to set
         */
        function StatusRequest(properties) {
            this.ids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * StatusRequest ids.
         * @member {Array.<string>} ids
         * @memberof vmm.StatusRequest
         * @instance
         */
        StatusRequest.prototype.ids = $util.emptyArray;
        /**
         * StatusRequest brief.
         * @member {boolean} brief
         * @memberof vmm.StatusRequest
         * @instance
         */
        StatusRequest.prototype.brief = false;
        /**
         * StatusRequest keyword.
         * @member {string} keyword
         * @memberof vmm.StatusRequest
         * @instance
         */
        StatusRequest.prototype.keyword = "";
        /**
         * StatusRequest page.
         * @member {number} page
         * @memberof vmm.StatusRequest
         * @instance
         */
        StatusRequest.prototype.page = 0;
        /**
         * StatusRequest page_size.
         * @member {number} page_size
         * @memberof vmm.StatusRequest
         * @instance
         */
        StatusRequest.prototype.page_size = 0;
        /**
         * Creates a new StatusRequest instance using the specified properties.
         * @function create
         * @memberof vmm.StatusRequest
         * @static
         * @param {vmm.IStatusRequest=} [properties] Properties to set
         * @returns {vmm.StatusRequest} StatusRequest instance
         */
        StatusRequest.create = function create(properties) {
            return new StatusRequest(properties);
        };
        /**
         * Encodes the specified StatusRequest message. Does not implicitly {@link vmm.StatusRequest.verify|verify} messages.
         * @function encode
         * @memberof vmm.StatusRequest
         * @static
         * @param {vmm.IStatusRequest} message StatusRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StatusRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ids != null && message.ids.length)
                for (var i = 0; i < message.ids.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.ids[i]);
            if (message.brief != null && Object.hasOwnProperty.call(message, "brief"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message.brief);
            if (message.keyword != null && Object.hasOwnProperty.call(message, "keyword"))
                writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.keyword);
            if (message.page != null && Object.hasOwnProperty.call(message, "page"))
                writer.uint32(/* id 4, wireType 0 =*/ 32).uint32(message.page);
            if (message.page_size != null && Object.hasOwnProperty.call(message, "page_size"))
                writer.uint32(/* id 5, wireType 0 =*/ 40).uint32(message.page_size);
            return writer;
        };
        /**
         * Encodes the specified StatusRequest message, length delimited. Does not implicitly {@link vmm.StatusRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vmm.StatusRequest
         * @static
         * @param {vmm.IStatusRequest} message StatusRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StatusRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a StatusRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vmm.StatusRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vmm.StatusRequest} StatusRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StatusRequest.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vmm.StatusRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                    case 1: {
                        if (!(message.ids && message.ids.length))
                            message.ids = [];
                        message.ids.push(reader.string());
                        break;
                    }
                    case 2: {
                        message.brief = reader.bool();
                        break;
                    }
                    case 3: {
                        message.keyword = reader.string();
                        break;
                    }
                    case 4: {
                        message.page = reader.uint32();
                        break;
                    }
                    case 5: {
                        message.page_size = reader.uint32();
                        break;
                    }
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a StatusRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vmm.StatusRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vmm.StatusRequest} StatusRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StatusRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a StatusRequest message.
         * @function verify
         * @memberof vmm.StatusRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StatusRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ids != null && message.hasOwnProperty("ids")) {
                if (!Array.isArray(message.ids))
                    return "ids: array expected";
                for (var i = 0; i < message.ids.length; ++i)
                    if (!$util.isString(message.ids[i]))
                        return "ids: string[] expected";
            }
            if (message.brief != null && message.hasOwnProperty("brief"))
                if (typeof message.brief !== "boolean")
                    return "brief: boolean expected";
            if (message.keyword != null && message.hasOwnProperty("keyword"))
                if (!$util.isString(message.keyword))
                    return "keyword: string expected";
            if (message.page != null && message.hasOwnProperty("page"))
                if (!$util.isInteger(message.page))
                    return "page: integer expected";
            if (message.page_size != null && message.hasOwnProperty("page_size"))
                if (!$util.isInteger(message.page_size))
                    return "page_size: integer expected";
            return null;
        };
        /**
         * Creates a StatusRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vmm.StatusRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vmm.StatusRequest} StatusRequest
         */
        StatusRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vmm.StatusRequest)
                return object;
            var message = new $root.vmm.StatusRequest();
            if (object.ids) {
                if (!Array.isArray(object.ids))
                    throw TypeError(".vmm.StatusRequest.ids: array expected");
                message.ids = [];
                for (var i = 0; i < object.ids.length; ++i)
                    message.ids[i] = String(object.ids[i]);
            }
            if (object.brief != null)
                message.brief = Boolean(object.brief);
            if (object.keyword != null)
                message.keyword = String(object.keyword);
            if (object.page != null)
                message.page = object.page >>> 0;
            if (object.page_size != null)
                message.page_size = object.page_size >>> 0;
            return message;
        };
        /**
         * Creates a plain object from a StatusRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vmm.StatusRequest
         * @static
         * @param {vmm.StatusRequest} message StatusRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StatusRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.ids = [];
            if (options.defaults) {
                object.brief = false;
                object.keyword = "";
                object.page = 0;
                object.page_size = 0;
            }
            if (message.ids && message.ids.length) {
                object.ids = [];
                for (var j = 0; j < message.ids.length; ++j)
                    object.ids[j] = message.ids[j];
            }
            if (message.brief != null && message.hasOwnProperty("brief"))
                object.brief = message.brief;
            if (message.keyword != null && message.hasOwnProperty("keyword"))
                object.keyword = message.keyword;
            if (message.page != null && message.hasOwnProperty("page"))
                object.page = message.page;
            if (message.page_size != null && message.hasOwnProperty("page_size"))
                object.page_size = message.page_size;
            return object;
        };
        /**
         * Converts this StatusRequest to JSON.
         * @function toJSON
         * @memberof vmm.StatusRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StatusRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * Gets the default type url for StatusRequest
         * @function getTypeUrl
         * @memberof vmm.StatusRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        StatusRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/vmm.StatusRequest";
        };
        return StatusRequest;
    })();
    vmm.StatusResponse = (function () {
        /**
         * Properties of a StatusResponse.
         * @memberof vmm
         * @interface IStatusResponse
         * @property {Array.<vmm.IVmInfo>|null} [vms] StatusResponse vms
         * @property {boolean|null} [port_mapping_enabled] StatusResponse port_mapping_enabled
         * @property {number|null} [total] StatusResponse total
         */
        /**
         * Constructs a new StatusResponse.
         * @memberof vmm
         * @classdesc Represents a StatusResponse.
         * @implements IStatusResponse
         * @constructor
         * @param {vmm.IStatusResponse=} [properties] Properties to set
         */
        function StatusResponse(properties) {
            this.vms = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * StatusResponse vms.
         * @member {Array.<vmm.IVmInfo>} vms
         * @memberof vmm.StatusResponse
         * @instance
         */
        StatusResponse.prototype.vms = $util.emptyArray;
        /**
         * StatusResponse port_mapping_enabled.
         * @member {boolean} port_mapping_enabled
         * @memberof vmm.StatusResponse
         * @instance
         */
        StatusResponse.prototype.port_mapping_enabled = false;
        /**
         * StatusResponse total.
         * @member {number} total
         * @memberof vmm.StatusResponse
         * @instance
         */
        StatusResponse.prototype.total = 0;
        /**
         * Creates a new StatusResponse instance using the specified properties.
         * @function create
         * @memberof vmm.StatusResponse
         * @static
         * @param {vmm.IStatusResponse=} [properties] Properties to set
         * @returns {vmm.StatusResponse} StatusResponse instance
         */
        StatusResponse.create = function create(properties) {
            return new StatusResponse(properties);
        };
        /**
         * Encodes the specified StatusResponse message. Does not implicitly {@link vmm.StatusResponse.verify|verify} messages.
         * @function encode
         * @memberof vmm.StatusResponse
         * @static
         * @param {vmm.IStatusResponse} message StatusResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StatusResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.vms != null && message.vms.length)
                for (var i = 0; i < message.vms.length; ++i)
                    $root.vmm.VmInfo.encode(message.vms[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.port_mapping_enabled != null && Object.hasOwnProperty.call(message, "port_mapping_enabled"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message.port_mapping_enabled);
            if (message.total != null && Object.hasOwnProperty.call(message, "total"))
                writer.uint32(/* id 3, wireType 0 =*/ 24).uint32(message.total);
            return writer;
        };
        /**
         * Encodes the specified StatusResponse message, length delimited. Does not implicitly {@link vmm.StatusResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vmm.StatusResponse
         * @static
         * @param {vmm.IStatusResponse} message StatusResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StatusResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a StatusResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vmm.StatusResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vmm.StatusResponse} StatusResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StatusResponse.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vmm.StatusResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                    case 1: {
                        if (!(message.vms && message.vms.length))
                            message.vms = [];
                        message.vms.push($root.vmm.VmInfo.decode(reader, reader.uint32()));
                        break;
                    }
                    case 2: {
                        message.port_mapping_enabled = reader.bool();
                        break;
                    }
                    case 3: {
                        message.total = reader.uint32();
                        break;
                    }
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a StatusResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vmm.StatusResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vmm.StatusResponse} StatusResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StatusResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a StatusResponse message.
         * @function verify
         * @memberof vmm.StatusResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StatusResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.vms != null && message.hasOwnProperty("vms")) {
                if (!Array.isArray(message.vms))
                    return "vms: array expected";
                for (var i = 0; i < message.vms.length; ++i) {
                    var error = $root.vmm.VmInfo.verify(message.vms[i]);
                    if (error)
                        return "vms." + error;
                }
            }
            if (message.port_mapping_enabled != null && message.hasOwnProperty("port_mapping_enabled"))
                if (typeof message.port_mapping_enabled !== "boolean")
                    return "port_mapping_enabled: boolean expected";
            if (message.total != null && message.hasOwnProperty("total"))
                if (!$util.isInteger(message.total))
                    return "total: integer expected";
            return null;
        };
        /**
         * Creates a StatusResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vmm.StatusResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vmm.StatusResponse} StatusResponse
         */
        StatusResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vmm.StatusResponse)
                return object;
            var message = new $root.vmm.StatusResponse();
            if (object.vms) {
                if (!Array.isArray(object.vms))
                    throw TypeError(".vmm.StatusResponse.vms: array expected");
                message.vms = [];
                for (var i = 0; i < object.vms.length; ++i) {
                    if (typeof object.vms[i] !== "object")
                        throw TypeError(".vmm.StatusResponse.vms: object expected");
                    message.vms[i] = $root.vmm.VmInfo.fromObject(object.vms[i]);
                }
            }
            if (object.port_mapping_enabled != null)
                message.port_mapping_enabled = Boolean(object.port_mapping_enabled);
            if (object.total != null)
                message.total = object.total >>> 0;
            return message;
        };
        /**
         * Creates a plain object from a StatusResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vmm.StatusResponse
         * @static
         * @param {vmm.StatusResponse} message StatusResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StatusResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.vms = [];
            if (options.defaults) {
                object.port_mapping_enabled = false;
                object.total = 0;
            }
            if (message.vms && message.vms.length) {
                object.vms = [];
                for (var j = 0; j < message.vms.length; ++j)
                    object.vms[j] = $root.vmm.VmInfo.toObject(message.vms[j], options);
            }
            if (message.port_mapping_enabled != null && message.hasOwnProperty("port_mapping_enabled"))
                object.port_mapping_enabled = message.port_mapping_enabled;
            if (message.total != null && message.hasOwnProperty("total"))
                object.total = message.total;
            return object;
        };
        /**
         * Converts this StatusResponse to JSON.
         * @function toJSON
         * @memberof vmm.StatusResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StatusResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * Gets the default type url for StatusResponse
         * @function getTypeUrl
         * @memberof vmm.StatusResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        StatusResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/vmm.StatusResponse";
        };
        return StatusResponse;
    })();
    vmm.ImageListResponse = (function () {
        /**
         * Properties of an ImageListResponse.
         * @memberof vmm
         * @interface IImageListResponse
         * @property {Array.<vmm.IImageInfo>|null} [images] ImageListResponse images
         */
        /**
         * Constructs a new ImageListResponse.
         * @memberof vmm
         * @classdesc Represents an ImageListResponse.
         * @implements IImageListResponse
         * @constructor
         * @param {vmm.IImageListResponse=} [properties] Properties to set
         */
        function ImageListResponse(properties) {
            this.images = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ImageListResponse images.
         * @member {Array.<vmm.IImageInfo>} images
         * @memberof vmm.ImageListResponse
         * @instance
         */
        ImageListResponse.prototype.images = $util.emptyArray;
        /**
         * Creates a new ImageListResponse instance using the specified properties.
         * @function create
         * @memberof vmm.ImageListResponse
         * @static
         * @param {vmm.IImageListResponse=} [properties] Properties to set
         * @returns {vmm.ImageListResponse} ImageListResponse instance
         */
        ImageListResponse.create = function create(properties) {
            return new ImageListResponse(properties);
        };
        /**
         * Encodes the specified ImageListResponse message. Does not implicitly {@link vmm.ImageListResponse.verify|verify} messages.
         * @function encode
         * @memberof vmm.ImageListResponse
         * @static
         * @param {vmm.IImageListResponse} message ImageListResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImageListResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.images != null && message.images.length)
                for (var i = 0; i < message.images.length; ++i)
                    $root.vmm.ImageInfo.encode(message.images[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified ImageListResponse message, length delimited. Does not implicitly {@link vmm.ImageListResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vmm.ImageListResponse
         * @static
         * @param {vmm.IImageListResponse} message ImageListResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImageListResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an ImageListResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vmm.ImageListResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vmm.ImageListResponse} ImageListResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImageListResponse.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vmm.ImageListResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                    case 1: {
                        if (!(message.images && message.images.length))
                            message.images = [];
                        message.images.push($root.vmm.ImageInfo.decode(reader, reader.uint32()));
                        break;
                    }
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an ImageListResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vmm.ImageListResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vmm.ImageListResponse} ImageListResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImageListResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an ImageListResponse message.
         * @function verify
         * @memberof vmm.ImageListResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ImageListResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.images != null && message.hasOwnProperty("images")) {
                if (!Array.isArray(message.images))
                    return "images: array expected";
                for (var i = 0; i < message.images.length; ++i) {
                    var error = $root.vmm.ImageInfo.verify(message.images[i]);
                    if (error)
                        return "images." + error;
                }
            }
            return null;
        };
        /**
         * Creates an ImageListResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vmm.ImageListResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vmm.ImageListResponse} ImageListResponse
         */
        ImageListResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vmm.ImageListResponse)
                return object;
            var message = new $root.vmm.ImageListResponse();
            if (object.images) {
                if (!Array.isArray(object.images))
                    throw TypeError(".vmm.ImageListResponse.images: array expected");
                message.images = [];
                for (var i = 0; i < object.images.length; ++i) {
                    if (typeof object.images[i] !== "object")
                        throw TypeError(".vmm.ImageListResponse.images: object expected");
                    message.images[i] = $root.vmm.ImageInfo.fromObject(object.images[i]);
                }
            }
            return message;
        };
        /**
         * Creates a plain object from an ImageListResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vmm.ImageListResponse
         * @static
         * @param {vmm.ImageListResponse} message ImageListResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ImageListResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.images = [];
            if (message.images && message.images.length) {
                object.images = [];
                for (var j = 0; j < message.images.length; ++j)
                    object.images[j] = $root.vmm.ImageInfo.toObject(message.images[j], options);
            }
            return object;
        };
        /**
         * Converts this ImageListResponse to JSON.
         * @function toJSON
         * @memberof vmm.ImageListResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ImageListResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * Gets the default type url for ImageListResponse
         * @function getTypeUrl
         * @memberof vmm.ImageListResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ImageListResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/vmm.ImageListResponse";
        };
        return ImageListResponse;
    })();
    vmm.ImageInfo = (function () {
        /**
         * Properties of an ImageInfo.
         * @memberof vmm
         * @interface IImageInfo
         * @property {string|null} [name] ImageInfo name
         * @property {string|null} [description] ImageInfo description
         * @property {string|null} [version] ImageInfo version
         * @property {boolean|null} [is_dev] ImageInfo is_dev
         */
        /**
         * Constructs a new ImageInfo.
         * @memberof vmm
         * @classdesc Represents an ImageInfo.
         * @implements IImageInfo
         * @constructor
         * @param {vmm.IImageInfo=} [properties] Properties to set
         */
        function ImageInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ImageInfo name.
         * @member {string} name
         * @memberof vmm.ImageInfo
         * @instance
         */
        ImageInfo.prototype.name = "";
        /**
         * ImageInfo description.
         * @member {string} description
         * @memberof vmm.ImageInfo
         * @instance
         */
        ImageInfo.prototype.description = "";
        /**
         * ImageInfo version.
         * @member {string} version
         * @memberof vmm.ImageInfo
         * @instance
         */
        ImageInfo.prototype.version = "";
        /**
         * ImageInfo is_dev.
         * @member {boolean} is_dev
         * @memberof vmm.ImageInfo
         * @instance
         */
        ImageInfo.prototype.is_dev = false;
        /**
         * Creates a new ImageInfo instance using the specified properties.
         * @function create
         * @memberof vmm.ImageInfo
         * @static
         * @param {vmm.IImageInfo=} [properties] Properties to set
         * @returns {vmm.ImageInfo} ImageInfo instance
         */
        ImageInfo.create = function create(properties) {
            return new ImageInfo(properties);
        };
        /**
         * Encodes the specified ImageInfo message. Does not implicitly {@link vmm.ImageInfo.verify|verify} messages.
         * @function encode
         * @memberof vmm.ImageInfo
         * @static
         * @param {vmm.IImageInfo} message ImageInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImageInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.description);
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.version);
            if (message.is_dev != null && Object.hasOwnProperty.call(message, "is_dev"))
                writer.uint32(/* id 4, wireType 0 =*/ 32).bool(message.is_dev);
            return writer;
        };
        /**
         * Encodes the specified ImageInfo message, length delimited. Does not implicitly {@link vmm.ImageInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vmm.ImageInfo
         * @static
         * @param {vmm.IImageInfo} message ImageInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImageInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an ImageInfo message from the specified reader or buffer.
         * @function decode
         * @memberof vmm.ImageInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vmm.ImageInfo} ImageInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImageInfo.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vmm.ImageInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                    case 1: {
                        message.name = reader.string();
                        break;
                    }
                    case 2: {
                        message.description = reader.string();
                        break;
                    }
                    case 3: {
                        message.version = reader.string();
                        break;
                    }
                    case 4: {
                        message.is_dev = reader.bool();
                        break;
                    }
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an ImageInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vmm.ImageInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vmm.ImageInfo} ImageInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImageInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an ImageInfo message.
         * @function verify
         * @memberof vmm.ImageInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ImageInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isString(message.version))
                    return "version: string expected";
            if (message.is_dev != null && message.hasOwnProperty("is_dev"))
                if (typeof message.is_dev !== "boolean")
                    return "is_dev: boolean expected";
            return null;
        };
        /**
         * Creates an ImageInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vmm.ImageInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vmm.ImageInfo} ImageInfo
         */
        ImageInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.vmm.ImageInfo)
                return object;
            var message = new $root.vmm.ImageInfo();
            if (object.name != null)
                message.name = String(object.name);
            if (object.description != null)
                message.description = String(object.description);
            if (object.version != null)
                message.version = String(object.version);
            if (object.is_dev != null)
                message.is_dev = Boolean(object.is_dev);
            return message;
        };
        /**
         * Creates a plain object from an ImageInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vmm.ImageInfo
         * @static
         * @param {vmm.ImageInfo} message ImageInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ImageInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                object.description = "";
                object.version = "";
                object.is_dev = false;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.is_dev != null && message.hasOwnProperty("is_dev"))
                object.is_dev = message.is_dev;
            return object;
        };
        /**
         * Converts this ImageInfo to JSON.
         * @function toJSON
         * @memberof vmm.ImageInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ImageInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * Gets the default type url for ImageInfo
         * @function getTypeUrl
         * @memberof vmm.ImageInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ImageInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/vmm.ImageInfo";
        };
        return ImageInfo;
    })();
    vmm.AppId = (function () {
        /**
         * Properties of an AppId.
         * @memberof vmm
         * @interface IAppId
         * @property {Uint8Array|null} [app_id] AppId app_id
         */
        /**
         * Constructs a new AppId.
         * @memberof vmm
         * @classdesc Represents an AppId.
         * @implements IAppId
         * @constructor
         * @param {vmm.IAppId=} [properties] Properties to set
         */
        function AppId(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * AppId app_id.
         * @member {Uint8Array} app_id
         * @memberof vmm.AppId
         * @instance
         */
        AppId.prototype.app_id = $util.newBuffer([]);
        /**
         * Creates a new AppId instance using the specified properties.
         * @function create
         * @memberof vmm.AppId
         * @static
         * @param {vmm.IAppId=} [properties] Properties to set
         * @returns {vmm.AppId} AppId instance
         */
        AppId.create = function create(properties) {
            return new AppId(properties);
        };
        /**
         * Encodes the specified AppId message. Does not implicitly {@link vmm.AppId.verify|verify} messages.
         * @function encode
         * @memberof vmm.AppId
         * @static
         * @param {vmm.IAppId} message AppId message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AppId.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.app_id != null && Object.hasOwnProperty.call(message, "app_id"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.app_id);
            return writer;
        };
        /**
         * Encodes the specified AppId message, length delimited. Does not implicitly {@link vmm.AppId.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vmm.AppId
         * @static
         * @param {vmm.IAppId} message AppId message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AppId.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an AppId message from the specified reader or buffer.
         * @function decode
         * @memberof vmm.AppId
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vmm.AppId} AppId
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AppId.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vmm.AppId();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                    case 1: {
                        message.app_id = reader.bytes();
                        break;
                    }
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an AppId message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vmm.AppId
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vmm.AppId} AppId
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AppId.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an AppId message.
         * @function verify
         * @memberof vmm.AppId
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AppId.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.app_id != null && message.hasOwnProperty("app_id"))
                if (!(message.app_id && typeof message.app_id.length === "number" || $util.isString(message.app_id)))
                    return "app_id: buffer expected";
            return null;
        };
        /**
         * Creates an AppId message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vmm.AppId
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vmm.AppId} AppId
         */
        AppId.fromObject = function fromObject(object) {
            if (object instanceof $root.vmm.AppId)
                return object;
            var message = new $root.vmm.AppId();
            if (object.app_id != null)
                if (typeof object.app_id === "string")
                    $util.base64.decode(object.app_id, message.app_id = $util.newBuffer($util.base64.length(object.app_id)), 0);
                else if (object.app_id.length >= 0)
                    message.app_id = object.app_id;
            return message;
        };
        /**
         * Creates a plain object from an AppId message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vmm.AppId
         * @static
         * @param {vmm.AppId} message AppId
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AppId.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.app_id = "";
                else {
                    object.app_id = [];
                    if (options.bytes !== Array)
                        object.app_id = $util.newBuffer(object.app_id);
                }
            if (message.app_id != null && message.hasOwnProperty("app_id"))
                object.app_id = options.bytes === String ? $util.base64.encode(message.app_id, 0, message.app_id.length) : options.bytes === Array ? Array.prototype.slice.call(message.app_id) : message.app_id;
            return object;
        };
        /**
         * Converts this AppId to JSON.
         * @function toJSON
         * @memberof vmm.AppId
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AppId.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * Gets the default type url for AppId
         * @function getTypeUrl
         * @memberof vmm.AppId
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AppId.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/vmm.AppId";
        };
        return AppId;
    })();
    vmm.PublicKeyResponse = (function () {
        /**
         * Properties of a PublicKeyResponse.
         * @memberof vmm
         * @interface IPublicKeyResponse
         * @property {Uint8Array|null} [public_key] PublicKeyResponse public_key
         * @property {Uint8Array|null} [signature] PublicKeyResponse signature
         */
        /**
         * Constructs a new PublicKeyResponse.
         * @memberof vmm
         * @classdesc Represents a PublicKeyResponse.
         * @implements IPublicKeyResponse
         * @constructor
         * @param {vmm.IPublicKeyResponse=} [properties] Properties to set
         */
        function PublicKeyResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * PublicKeyResponse public_key.
         * @member {Uint8Array} public_key
         * @memberof vmm.PublicKeyResponse
         * @instance
         */
        PublicKeyResponse.prototype.public_key = $util.newBuffer([]);
        /**
         * PublicKeyResponse signature.
         * @member {Uint8Array} signature
         * @memberof vmm.PublicKeyResponse
         * @instance
         */
        PublicKeyResponse.prototype.signature = $util.newBuffer([]);
        /**
         * Creates a new PublicKeyResponse instance using the specified properties.
         * @function create
         * @memberof vmm.PublicKeyResponse
         * @static
         * @param {vmm.IPublicKeyResponse=} [properties] Properties to set
         * @returns {vmm.PublicKeyResponse} PublicKeyResponse instance
         */
        PublicKeyResponse.create = function create(properties) {
            return new PublicKeyResponse(properties);
        };
        /**
         * Encodes the specified PublicKeyResponse message. Does not implicitly {@link vmm.PublicKeyResponse.verify|verify} messages.
         * @function encode
         * @memberof vmm.PublicKeyResponse
         * @static
         * @param {vmm.IPublicKeyResponse} message PublicKeyResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PublicKeyResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.public_key != null && Object.hasOwnProperty.call(message, "public_key"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.public_key);
            if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.signature);
            return writer;
        };
        /**
         * Encodes the specified PublicKeyResponse message, length delimited. Does not implicitly {@link vmm.PublicKeyResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vmm.PublicKeyResponse
         * @static
         * @param {vmm.IPublicKeyResponse} message PublicKeyResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PublicKeyResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a PublicKeyResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vmm.PublicKeyResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vmm.PublicKeyResponse} PublicKeyResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PublicKeyResponse.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vmm.PublicKeyResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                    case 1: {
                        message.public_key = reader.bytes();
                        break;
                    }
                    case 2: {
                        message.signature = reader.bytes();
                        break;
                    }
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a PublicKeyResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vmm.PublicKeyResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vmm.PublicKeyResponse} PublicKeyResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PublicKeyResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a PublicKeyResponse message.
         * @function verify
         * @memberof vmm.PublicKeyResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PublicKeyResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.public_key != null && message.hasOwnProperty("public_key"))
                if (!(message.public_key && typeof message.public_key.length === "number" || $util.isString(message.public_key)))
                    return "public_key: buffer expected";
            if (message.signature != null && message.hasOwnProperty("signature"))
                if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                    return "signature: buffer expected";
            return null;
        };
        /**
         * Creates a PublicKeyResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vmm.PublicKeyResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vmm.PublicKeyResponse} PublicKeyResponse
         */
        PublicKeyResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vmm.PublicKeyResponse)
                return object;
            var message = new $root.vmm.PublicKeyResponse();
            if (object.public_key != null)
                if (typeof object.public_key === "string")
                    $util.base64.decode(object.public_key, message.public_key = $util.newBuffer($util.base64.length(object.public_key)), 0);
                else if (object.public_key.length >= 0)
                    message.public_key = object.public_key;
            if (object.signature != null)
                if (typeof object.signature === "string")
                    $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                else if (object.signature.length >= 0)
                    message.signature = object.signature;
            return message;
        };
        /**
         * Creates a plain object from a PublicKeyResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vmm.PublicKeyResponse
         * @static
         * @param {vmm.PublicKeyResponse} message PublicKeyResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PublicKeyResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.public_key = "";
                else {
                    object.public_key = [];
                    if (options.bytes !== Array)
                        object.public_key = $util.newBuffer(object.public_key);
                }
                if (options.bytes === String)
                    object.signature = "";
                else {
                    object.signature = [];
                    if (options.bytes !== Array)
                        object.signature = $util.newBuffer(object.signature);
                }
            }
            if (message.public_key != null && message.hasOwnProperty("public_key"))
                object.public_key = options.bytes === String ? $util.base64.encode(message.public_key, 0, message.public_key.length) : options.bytes === Array ? Array.prototype.slice.call(message.public_key) : message.public_key;
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
            return object;
        };
        /**
         * Converts this PublicKeyResponse to JSON.
         * @function toJSON
         * @memberof vmm.PublicKeyResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PublicKeyResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * Gets the default type url for PublicKeyResponse
         * @function getTypeUrl
         * @memberof vmm.PublicKeyResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PublicKeyResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/vmm.PublicKeyResponse";
        };
        return PublicKeyResponse;
    })();
    vmm.GetInfoResponse = (function () {
        /**
         * Properties of a GetInfoResponse.
         * @memberof vmm
         * @interface IGetInfoResponse
         * @property {boolean|null} [found] GetInfoResponse found
         * @property {vmm.IVmInfo|null} [info] GetInfoResponse info
         */
        /**
         * Constructs a new GetInfoResponse.
         * @memberof vmm
         * @classdesc Represents a GetInfoResponse.
         * @implements IGetInfoResponse
         * @constructor
         * @param {vmm.IGetInfoResponse=} [properties] Properties to set
         */
        function GetInfoResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * GetInfoResponse found.
         * @member {boolean} found
         * @memberof vmm.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.found = false;
        /**
         * GetInfoResponse info.
         * @member {vmm.IVmInfo|null|undefined} info
         * @memberof vmm.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.info = null;
        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;
        /**
         * GetInfoResponse _info.
         * @member {"info"|undefined} _info
         * @memberof vmm.GetInfoResponse
         * @instance
         */
        Object.defineProperty(GetInfoResponse.prototype, "_info", {
            get: $util.oneOfGetter($oneOfFields = ["info"]),
            set: $util.oneOfSetter($oneOfFields)
        });
        /**
         * Creates a new GetInfoResponse instance using the specified properties.
         * @function create
         * @memberof vmm.GetInfoResponse
         * @static
         * @param {vmm.IGetInfoResponse=} [properties] Properties to set
         * @returns {vmm.GetInfoResponse} GetInfoResponse instance
         */
        GetInfoResponse.create = function create(properties) {
            return new GetInfoResponse(properties);
        };
        /**
         * Encodes the specified GetInfoResponse message. Does not implicitly {@link vmm.GetInfoResponse.verify|verify} messages.
         * @function encode
         * @memberof vmm.GetInfoResponse
         * @static
         * @param {vmm.IGetInfoResponse} message GetInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetInfoResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.found != null && Object.hasOwnProperty.call(message, "found"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).bool(message.found);
            if (message.info != null && Object.hasOwnProperty.call(message, "info"))
                $root.vmm.VmInfo.encode(message.info, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified GetInfoResponse message, length delimited. Does not implicitly {@link vmm.GetInfoResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vmm.GetInfoResponse
         * @static
         * @param {vmm.IGetInfoResponse} message GetInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a GetInfoResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vmm.GetInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vmm.GetInfoResponse} GetInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetInfoResponse.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vmm.GetInfoResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                    case 1: {
                        message.found = reader.bool();
                        break;
                    }
                    case 2: {
                        message.info = $root.vmm.VmInfo.decode(reader, reader.uint32());
                        break;
                    }
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a GetInfoResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vmm.GetInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vmm.GetInfoResponse} GetInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetInfoResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a GetInfoResponse message.
         * @function verify
         * @memberof vmm.GetInfoResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetInfoResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.found != null && message.hasOwnProperty("found"))
                if (typeof message.found !== "boolean")
                    return "found: boolean expected";
            if (message.info != null && message.hasOwnProperty("info")) {
                properties._info = 1;
                {
                    var error = $root.vmm.VmInfo.verify(message.info);
                    if (error)
                        return "info." + error;
                }
            }
            return null;
        };
        /**
         * Creates a GetInfoResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vmm.GetInfoResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vmm.GetInfoResponse} GetInfoResponse
         */
        GetInfoResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vmm.GetInfoResponse)
                return object;
            var message = new $root.vmm.GetInfoResponse();
            if (object.found != null)
                message.found = Boolean(object.found);
            if (object.info != null) {
                if (typeof object.info !== "object")
                    throw TypeError(".vmm.GetInfoResponse.info: object expected");
                message.info = $root.vmm.VmInfo.fromObject(object.info);
            }
            return message;
        };
        /**
         * Creates a plain object from a GetInfoResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vmm.GetInfoResponse
         * @static
         * @param {vmm.GetInfoResponse} message GetInfoResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetInfoResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.found = false;
            if (message.found != null && message.hasOwnProperty("found"))
                object.found = message.found;
            if (message.info != null && message.hasOwnProperty("info")) {
                object.info = $root.vmm.VmInfo.toObject(message.info, options);
                if (options.oneofs)
                    object._info = "info";
            }
            return object;
        };
        /**
         * Converts this GetInfoResponse to JSON.
         * @function toJSON
         * @memberof vmm.GetInfoResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetInfoResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * Gets the default type url for GetInfoResponse
         * @function getTypeUrl
         * @memberof vmm.GetInfoResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/vmm.GetInfoResponse";
        };
        return GetInfoResponse;
    })();
    vmm.ResizeVmRequest = (function () {
        /**
         * Properties of a ResizeVmRequest.
         * @memberof vmm
         * @interface IResizeVmRequest
         * @property {string|null} [id] ResizeVmRequest id
         * @property {number|null} [vcpu] ResizeVmRequest vcpu
         * @property {number|null} [memory] ResizeVmRequest memory
         * @property {number|null} [disk_size] ResizeVmRequest disk_size
         * @property {string|null} [image] ResizeVmRequest image
         */
        /**
         * Constructs a new ResizeVmRequest.
         * @memberof vmm
         * @classdesc Represents a ResizeVmRequest.
         * @implements IResizeVmRequest
         * @constructor
         * @param {vmm.IResizeVmRequest=} [properties] Properties to set
         */
        function ResizeVmRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ResizeVmRequest id.
         * @member {string} id
         * @memberof vmm.ResizeVmRequest
         * @instance
         */
        ResizeVmRequest.prototype.id = "";
        /**
         * ResizeVmRequest vcpu.
         * @member {number|null|undefined} vcpu
         * @memberof vmm.ResizeVmRequest
         * @instance
         */
        ResizeVmRequest.prototype.vcpu = null;
        /**
         * ResizeVmRequest memory.
         * @member {number|null|undefined} memory
         * @memberof vmm.ResizeVmRequest
         * @instance
         */
        ResizeVmRequest.prototype.memory = null;
        /**
         * ResizeVmRequest disk_size.
         * @member {number|null|undefined} disk_size
         * @memberof vmm.ResizeVmRequest
         * @instance
         */
        ResizeVmRequest.prototype.disk_size = null;
        /**
         * ResizeVmRequest image.
         * @member {string|null|undefined} image
         * @memberof vmm.ResizeVmRequest
         * @instance
         */
        ResizeVmRequest.prototype.image = null;
        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;
        /**
         * ResizeVmRequest _vcpu.
         * @member {"vcpu"|undefined} _vcpu
         * @memberof vmm.ResizeVmRequest
         * @instance
         */
        Object.defineProperty(ResizeVmRequest.prototype, "_vcpu", {
            get: $util.oneOfGetter($oneOfFields = ["vcpu"]),
            set: $util.oneOfSetter($oneOfFields)
        });
        /**
         * ResizeVmRequest _memory.
         * @member {"memory"|undefined} _memory
         * @memberof vmm.ResizeVmRequest
         * @instance
         */
        Object.defineProperty(ResizeVmRequest.prototype, "_memory", {
            get: $util.oneOfGetter($oneOfFields = ["memory"]),
            set: $util.oneOfSetter($oneOfFields)
        });
        /**
         * ResizeVmRequest _disk_size.
         * @member {"disk_size"|undefined} _disk_size
         * @memberof vmm.ResizeVmRequest
         * @instance
         */
        Object.defineProperty(ResizeVmRequest.prototype, "_disk_size", {
            get: $util.oneOfGetter($oneOfFields = ["disk_size"]),
            set: $util.oneOfSetter($oneOfFields)
        });
        /**
         * ResizeVmRequest _image.
         * @member {"image"|undefined} _image
         * @memberof vmm.ResizeVmRequest
         * @instance
         */
        Object.defineProperty(ResizeVmRequest.prototype, "_image", {
            get: $util.oneOfGetter($oneOfFields = ["image"]),
            set: $util.oneOfSetter($oneOfFields)
        });
        /**
         * Creates a new ResizeVmRequest instance using the specified properties.
         * @function create
         * @memberof vmm.ResizeVmRequest
         * @static
         * @param {vmm.IResizeVmRequest=} [properties] Properties to set
         * @returns {vmm.ResizeVmRequest} ResizeVmRequest instance
         */
        ResizeVmRequest.create = function create(properties) {
            return new ResizeVmRequest(properties);
        };
        /**
         * Encodes the specified ResizeVmRequest message. Does not implicitly {@link vmm.ResizeVmRequest.verify|verify} messages.
         * @function encode
         * @memberof vmm.ResizeVmRequest
         * @static
         * @param {vmm.IResizeVmRequest} message ResizeVmRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResizeVmRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.id);
            if (message.vcpu != null && Object.hasOwnProperty.call(message, "vcpu"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).uint32(message.vcpu);
            if (message.memory != null && Object.hasOwnProperty.call(message, "memory"))
                writer.uint32(/* id 3, wireType 0 =*/ 24).uint32(message.memory);
            if (message.disk_size != null && Object.hasOwnProperty.call(message, "disk_size"))
                writer.uint32(/* id 4, wireType 0 =*/ 32).uint32(message.disk_size);
            if (message.image != null && Object.hasOwnProperty.call(message, "image"))
                writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.image);
            return writer;
        };
        /**
         * Encodes the specified ResizeVmRequest message, length delimited. Does not implicitly {@link vmm.ResizeVmRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vmm.ResizeVmRequest
         * @static
         * @param {vmm.IResizeVmRequest} message ResizeVmRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResizeVmRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a ResizeVmRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vmm.ResizeVmRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vmm.ResizeVmRequest} ResizeVmRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResizeVmRequest.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vmm.ResizeVmRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                    case 1: {
                        message.id = reader.string();
                        break;
                    }
                    case 2: {
                        message.vcpu = reader.uint32();
                        break;
                    }
                    case 3: {
                        message.memory = reader.uint32();
                        break;
                    }
                    case 4: {
                        message.disk_size = reader.uint32();
                        break;
                    }
                    case 5: {
                        message.image = reader.string();
                        break;
                    }
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a ResizeVmRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vmm.ResizeVmRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vmm.ResizeVmRequest} ResizeVmRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResizeVmRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a ResizeVmRequest message.
         * @function verify
         * @memberof vmm.ResizeVmRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResizeVmRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.vcpu != null && message.hasOwnProperty("vcpu")) {
                properties._vcpu = 1;
                if (!$util.isInteger(message.vcpu))
                    return "vcpu: integer expected";
            }
            if (message.memory != null && message.hasOwnProperty("memory")) {
                properties._memory = 1;
                if (!$util.isInteger(message.memory))
                    return "memory: integer expected";
            }
            if (message.disk_size != null && message.hasOwnProperty("disk_size")) {
                properties._disk_size = 1;
                if (!$util.isInteger(message.disk_size))
                    return "disk_size: integer expected";
            }
            if (message.image != null && message.hasOwnProperty("image")) {
                properties._image = 1;
                if (!$util.isString(message.image))
                    return "image: string expected";
            }
            return null;
        };
        /**
         * Creates a ResizeVmRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vmm.ResizeVmRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vmm.ResizeVmRequest} ResizeVmRequest
         */
        ResizeVmRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vmm.ResizeVmRequest)
                return object;
            var message = new $root.vmm.ResizeVmRequest();
            if (object.id != null)
                message.id = String(object.id);
            if (object.vcpu != null)
                message.vcpu = object.vcpu >>> 0;
            if (object.memory != null)
                message.memory = object.memory >>> 0;
            if (object.disk_size != null)
                message.disk_size = object.disk_size >>> 0;
            if (object.image != null)
                message.image = String(object.image);
            return message;
        };
        /**
         * Creates a plain object from a ResizeVmRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vmm.ResizeVmRequest
         * @static
         * @param {vmm.ResizeVmRequest} message ResizeVmRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResizeVmRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.id = "";
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.vcpu != null && message.hasOwnProperty("vcpu")) {
                object.vcpu = message.vcpu;
                if (options.oneofs)
                    object._vcpu = "vcpu";
            }
            if (message.memory != null && message.hasOwnProperty("memory")) {
                object.memory = message.memory;
                if (options.oneofs)
                    object._memory = "memory";
            }
            if (message.disk_size != null && message.hasOwnProperty("disk_size")) {
                object.disk_size = message.disk_size;
                if (options.oneofs)
                    object._disk_size = "disk_size";
            }
            if (message.image != null && message.hasOwnProperty("image")) {
                object.image = message.image;
                if (options.oneofs)
                    object._image = "image";
            }
            return object;
        };
        /**
         * Converts this ResizeVmRequest to JSON.
         * @function toJSON
         * @memberof vmm.ResizeVmRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResizeVmRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * Gets the default type url for ResizeVmRequest
         * @function getTypeUrl
         * @memberof vmm.ResizeVmRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ResizeVmRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/vmm.ResizeVmRequest";
        };
        return ResizeVmRequest;
    })();
    vmm.KmsSettings = (function () {
        /**
         * Properties of a KmsSettings.
         * @memberof vmm
         * @interface IKmsSettings
         * @property {string|null} [url] KmsSettings url
         * @property {Array.<string>|null} [urls] KmsSettings urls
         */
        /**
         * Constructs a new KmsSettings.
         * @memberof vmm
         * @classdesc Represents a KmsSettings.
         * @implements IKmsSettings
         * @constructor
         * @param {vmm.IKmsSettings=} [properties] Properties to set
         */
        function KmsSettings(properties) {
            this.urls = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * KmsSettings url.
         * @member {string} url
         * @memberof vmm.KmsSettings
         * @instance
         */
        KmsSettings.prototype.url = "";
        /**
         * KmsSettings urls.
         * @member {Array.<string>} urls
         * @memberof vmm.KmsSettings
         * @instance
         */
        KmsSettings.prototype.urls = $util.emptyArray;
        /**
         * Creates a new KmsSettings instance using the specified properties.
         * @function create
         * @memberof vmm.KmsSettings
         * @static
         * @param {vmm.IKmsSettings=} [properties] Properties to set
         * @returns {vmm.KmsSettings} KmsSettings instance
         */
        KmsSettings.create = function create(properties) {
            return new KmsSettings(properties);
        };
        /**
         * Encodes the specified KmsSettings message. Does not implicitly {@link vmm.KmsSettings.verify|verify} messages.
         * @function encode
         * @memberof vmm.KmsSettings
         * @static
         * @param {vmm.IKmsSettings} message KmsSettings message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KmsSettings.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.url);
            if (message.urls != null && message.urls.length)
                for (var i = 0; i < message.urls.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.urls[i]);
            return writer;
        };
        /**
         * Encodes the specified KmsSettings message, length delimited. Does not implicitly {@link vmm.KmsSettings.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vmm.KmsSettings
         * @static
         * @param {vmm.IKmsSettings} message KmsSettings message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KmsSettings.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a KmsSettings message from the specified reader or buffer.
         * @function decode
         * @memberof vmm.KmsSettings
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vmm.KmsSettings} KmsSettings
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KmsSettings.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vmm.KmsSettings();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                    case 1: {
                        message.url = reader.string();
                        break;
                    }
                    case 2: {
                        if (!(message.urls && message.urls.length))
                            message.urls = [];
                        message.urls.push(reader.string());
                        break;
                    }
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a KmsSettings message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vmm.KmsSettings
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vmm.KmsSettings} KmsSettings
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KmsSettings.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a KmsSettings message.
         * @function verify
         * @memberof vmm.KmsSettings
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        KmsSettings.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!$util.isString(message.url))
                    return "url: string expected";
            if (message.urls != null && message.hasOwnProperty("urls")) {
                if (!Array.isArray(message.urls))
                    return "urls: array expected";
                for (var i = 0; i < message.urls.length; ++i)
                    if (!$util.isString(message.urls[i]))
                        return "urls: string[] expected";
            }
            return null;
        };
        /**
         * Creates a KmsSettings message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vmm.KmsSettings
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vmm.KmsSettings} KmsSettings
         */
        KmsSettings.fromObject = function fromObject(object) {
            if (object instanceof $root.vmm.KmsSettings)
                return object;
            var message = new $root.vmm.KmsSettings();
            if (object.url != null)
                message.url = String(object.url);
            if (object.urls) {
                if (!Array.isArray(object.urls))
                    throw TypeError(".vmm.KmsSettings.urls: array expected");
                message.urls = [];
                for (var i = 0; i < object.urls.length; ++i)
                    message.urls[i] = String(object.urls[i]);
            }
            return message;
        };
        /**
         * Creates a plain object from a KmsSettings message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vmm.KmsSettings
         * @static
         * @param {vmm.KmsSettings} message KmsSettings
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        KmsSettings.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.urls = [];
            if (options.defaults)
                object.url = "";
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = message.url;
            if (message.urls && message.urls.length) {
                object.urls = [];
                for (var j = 0; j < message.urls.length; ++j)
                    object.urls[j] = message.urls[j];
            }
            return object;
        };
        /**
         * Converts this KmsSettings to JSON.
         * @function toJSON
         * @memberof vmm.KmsSettings
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        KmsSettings.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * Gets the default type url for KmsSettings
         * @function getTypeUrl
         * @memberof vmm.KmsSettings
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        KmsSettings.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/vmm.KmsSettings";
        };
        return KmsSettings;
    })();
    vmm.GatewaySettings = (function () {
        /**
         * Properties of a GatewaySettings.
         * @memberof vmm
         * @interface IGatewaySettings
         * @property {string|null} [url] GatewaySettings url
         * @property {string|null} [base_domain] GatewaySettings base_domain
         * @property {number|null} [port] GatewaySettings port
         * @property {number|null} [agent_port] GatewaySettings agent_port
         * @property {Array.<string>|null} [urls] GatewaySettings urls
         */
        /**
         * Constructs a new GatewaySettings.
         * @memberof vmm
         * @classdesc Represents a GatewaySettings.
         * @implements IGatewaySettings
         * @constructor
         * @param {vmm.IGatewaySettings=} [properties] Properties to set
         */
        function GatewaySettings(properties) {
            this.urls = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * GatewaySettings url.
         * @member {string} url
         * @memberof vmm.GatewaySettings
         * @instance
         */
        GatewaySettings.prototype.url = "";
        /**
         * GatewaySettings base_domain.
         * @member {string} base_domain
         * @memberof vmm.GatewaySettings
         * @instance
         */
        GatewaySettings.prototype.base_domain = "";
        /**
         * GatewaySettings port.
         * @member {number} port
         * @memberof vmm.GatewaySettings
         * @instance
         */
        GatewaySettings.prototype.port = 0;
        /**
         * GatewaySettings agent_port.
         * @member {number} agent_port
         * @memberof vmm.GatewaySettings
         * @instance
         */
        GatewaySettings.prototype.agent_port = 0;
        /**
         * GatewaySettings urls.
         * @member {Array.<string>} urls
         * @memberof vmm.GatewaySettings
         * @instance
         */
        GatewaySettings.prototype.urls = $util.emptyArray;
        /**
         * Creates a new GatewaySettings instance using the specified properties.
         * @function create
         * @memberof vmm.GatewaySettings
         * @static
         * @param {vmm.IGatewaySettings=} [properties] Properties to set
         * @returns {vmm.GatewaySettings} GatewaySettings instance
         */
        GatewaySettings.create = function create(properties) {
            return new GatewaySettings(properties);
        };
        /**
         * Encodes the specified GatewaySettings message. Does not implicitly {@link vmm.GatewaySettings.verify|verify} messages.
         * @function encode
         * @memberof vmm.GatewaySettings
         * @static
         * @param {vmm.IGatewaySettings} message GatewaySettings message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GatewaySettings.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.url);
            if (message.base_domain != null && Object.hasOwnProperty.call(message, "base_domain"))
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.base_domain);
            if (message.port != null && Object.hasOwnProperty.call(message, "port"))
                writer.uint32(/* id 3, wireType 0 =*/ 24).uint32(message.port);
            if (message.agent_port != null && Object.hasOwnProperty.call(message, "agent_port"))
                writer.uint32(/* id 4, wireType 0 =*/ 32).uint32(message.agent_port);
            if (message.urls != null && message.urls.length)
                for (var i = 0; i < message.urls.length; ++i)
                    writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.urls[i]);
            return writer;
        };
        /**
         * Encodes the specified GatewaySettings message, length delimited. Does not implicitly {@link vmm.GatewaySettings.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vmm.GatewaySettings
         * @static
         * @param {vmm.IGatewaySettings} message GatewaySettings message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GatewaySettings.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a GatewaySettings message from the specified reader or buffer.
         * @function decode
         * @memberof vmm.GatewaySettings
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vmm.GatewaySettings} GatewaySettings
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GatewaySettings.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vmm.GatewaySettings();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                    case 1: {
                        message.url = reader.string();
                        break;
                    }
                    case 2: {
                        message.base_domain = reader.string();
                        break;
                    }
                    case 3: {
                        message.port = reader.uint32();
                        break;
                    }
                    case 4: {
                        message.agent_port = reader.uint32();
                        break;
                    }
                    case 5: {
                        if (!(message.urls && message.urls.length))
                            message.urls = [];
                        message.urls.push(reader.string());
                        break;
                    }
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a GatewaySettings message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vmm.GatewaySettings
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vmm.GatewaySettings} GatewaySettings
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GatewaySettings.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a GatewaySettings message.
         * @function verify
         * @memberof vmm.GatewaySettings
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GatewaySettings.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!$util.isString(message.url))
                    return "url: string expected";
            if (message.base_domain != null && message.hasOwnProperty("base_domain"))
                if (!$util.isString(message.base_domain))
                    return "base_domain: string expected";
            if (message.port != null && message.hasOwnProperty("port"))
                if (!$util.isInteger(message.port))
                    return "port: integer expected";
            if (message.agent_port != null && message.hasOwnProperty("agent_port"))
                if (!$util.isInteger(message.agent_port))
                    return "agent_port: integer expected";
            if (message.urls != null && message.hasOwnProperty("urls")) {
                if (!Array.isArray(message.urls))
                    return "urls: array expected";
                for (var i = 0; i < message.urls.length; ++i)
                    if (!$util.isString(message.urls[i]))
                        return "urls: string[] expected";
            }
            return null;
        };
        /**
         * Creates a GatewaySettings message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vmm.GatewaySettings
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vmm.GatewaySettings} GatewaySettings
         */
        GatewaySettings.fromObject = function fromObject(object) {
            if (object instanceof $root.vmm.GatewaySettings)
                return object;
            var message = new $root.vmm.GatewaySettings();
            if (object.url != null)
                message.url = String(object.url);
            if (object.base_domain != null)
                message.base_domain = String(object.base_domain);
            if (object.port != null)
                message.port = object.port >>> 0;
            if (object.agent_port != null)
                message.agent_port = object.agent_port >>> 0;
            if (object.urls) {
                if (!Array.isArray(object.urls))
                    throw TypeError(".vmm.GatewaySettings.urls: array expected");
                message.urls = [];
                for (var i = 0; i < object.urls.length; ++i)
                    message.urls[i] = String(object.urls[i]);
            }
            return message;
        };
        /**
         * Creates a plain object from a GatewaySettings message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vmm.GatewaySettings
         * @static
         * @param {vmm.GatewaySettings} message GatewaySettings
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GatewaySettings.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.urls = [];
            if (options.defaults) {
                object.url = "";
                object.base_domain = "";
                object.port = 0;
                object.agent_port = 0;
            }
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = message.url;
            if (message.base_domain != null && message.hasOwnProperty("base_domain"))
                object.base_domain = message.base_domain;
            if (message.port != null && message.hasOwnProperty("port"))
                object.port = message.port;
            if (message.agent_port != null && message.hasOwnProperty("agent_port"))
                object.agent_port = message.agent_port;
            if (message.urls && message.urls.length) {
                object.urls = [];
                for (var j = 0; j < message.urls.length; ++j)
                    object.urls[j] = message.urls[j];
            }
            return object;
        };
        /**
         * Converts this GatewaySettings to JSON.
         * @function toJSON
         * @memberof vmm.GatewaySettings
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GatewaySettings.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * Gets the default type url for GatewaySettings
         * @function getTypeUrl
         * @memberof vmm.GatewaySettings
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GatewaySettings.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/vmm.GatewaySettings";
        };
        return GatewaySettings;
    })();
    vmm.ResourcesSettings = (function () {
        /**
         * Properties of a ResourcesSettings.
         * @memberof vmm
         * @interface IResourcesSettings
         * @property {number|null} [max_cvm_number] ResourcesSettings max_cvm_number
         * @property {number|null} [max_allocable_vcpu] ResourcesSettings max_allocable_vcpu
         * @property {number|null} [max_allocable_memory_in_mb] ResourcesSettings max_allocable_memory_in_mb
         */
        /**
         * Constructs a new ResourcesSettings.
         * @memberof vmm
         * @classdesc Represents a ResourcesSettings.
         * @implements IResourcesSettings
         * @constructor
         * @param {vmm.IResourcesSettings=} [properties] Properties to set
         */
        function ResourcesSettings(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ResourcesSettings max_cvm_number.
         * @member {number} max_cvm_number
         * @memberof vmm.ResourcesSettings
         * @instance
         */
        ResourcesSettings.prototype.max_cvm_number = 0;
        /**
         * ResourcesSettings max_allocable_vcpu.
         * @member {number} max_allocable_vcpu
         * @memberof vmm.ResourcesSettings
         * @instance
         */
        ResourcesSettings.prototype.max_allocable_vcpu = 0;
        /**
         * ResourcesSettings max_allocable_memory_in_mb.
         * @member {number} max_allocable_memory_in_mb
         * @memberof vmm.ResourcesSettings
         * @instance
         */
        ResourcesSettings.prototype.max_allocable_memory_in_mb = 0;
        /**
         * Creates a new ResourcesSettings instance using the specified properties.
         * @function create
         * @memberof vmm.ResourcesSettings
         * @static
         * @param {vmm.IResourcesSettings=} [properties] Properties to set
         * @returns {vmm.ResourcesSettings} ResourcesSettings instance
         */
        ResourcesSettings.create = function create(properties) {
            return new ResourcesSettings(properties);
        };
        /**
         * Encodes the specified ResourcesSettings message. Does not implicitly {@link vmm.ResourcesSettings.verify|verify} messages.
         * @function encode
         * @memberof vmm.ResourcesSettings
         * @static
         * @param {vmm.IResourcesSettings} message ResourcesSettings message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourcesSettings.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.max_cvm_number != null && Object.hasOwnProperty.call(message, "max_cvm_number"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).uint32(message.max_cvm_number);
            if (message.max_allocable_vcpu != null && Object.hasOwnProperty.call(message, "max_allocable_vcpu"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).uint32(message.max_allocable_vcpu);
            if (message.max_allocable_memory_in_mb != null && Object.hasOwnProperty.call(message, "max_allocable_memory_in_mb"))
                writer.uint32(/* id 3, wireType 0 =*/ 24).uint32(message.max_allocable_memory_in_mb);
            return writer;
        };
        /**
         * Encodes the specified ResourcesSettings message, length delimited. Does not implicitly {@link vmm.ResourcesSettings.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vmm.ResourcesSettings
         * @static
         * @param {vmm.IResourcesSettings} message ResourcesSettings message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourcesSettings.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a ResourcesSettings message from the specified reader or buffer.
         * @function decode
         * @memberof vmm.ResourcesSettings
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vmm.ResourcesSettings} ResourcesSettings
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourcesSettings.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vmm.ResourcesSettings();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                    case 1: {
                        message.max_cvm_number = reader.uint32();
                        break;
                    }
                    case 2: {
                        message.max_allocable_vcpu = reader.uint32();
                        break;
                    }
                    case 3: {
                        message.max_allocable_memory_in_mb = reader.uint32();
                        break;
                    }
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a ResourcesSettings message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vmm.ResourcesSettings
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vmm.ResourcesSettings} ResourcesSettings
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourcesSettings.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a ResourcesSettings message.
         * @function verify
         * @memberof vmm.ResourcesSettings
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourcesSettings.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.max_cvm_number != null && message.hasOwnProperty("max_cvm_number"))
                if (!$util.isInteger(message.max_cvm_number))
                    return "max_cvm_number: integer expected";
            if (message.max_allocable_vcpu != null && message.hasOwnProperty("max_allocable_vcpu"))
                if (!$util.isInteger(message.max_allocable_vcpu))
                    return "max_allocable_vcpu: integer expected";
            if (message.max_allocable_memory_in_mb != null && message.hasOwnProperty("max_allocable_memory_in_mb"))
                if (!$util.isInteger(message.max_allocable_memory_in_mb))
                    return "max_allocable_memory_in_mb: integer expected";
            return null;
        };
        /**
         * Creates a ResourcesSettings message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vmm.ResourcesSettings
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vmm.ResourcesSettings} ResourcesSettings
         */
        ResourcesSettings.fromObject = function fromObject(object) {
            if (object instanceof $root.vmm.ResourcesSettings)
                return object;
            var message = new $root.vmm.ResourcesSettings();
            if (object.max_cvm_number != null)
                message.max_cvm_number = object.max_cvm_number >>> 0;
            if (object.max_allocable_vcpu != null)
                message.max_allocable_vcpu = object.max_allocable_vcpu >>> 0;
            if (object.max_allocable_memory_in_mb != null)
                message.max_allocable_memory_in_mb = object.max_allocable_memory_in_mb >>> 0;
            return message;
        };
        /**
         * Creates a plain object from a ResourcesSettings message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vmm.ResourcesSettings
         * @static
         * @param {vmm.ResourcesSettings} message ResourcesSettings
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourcesSettings.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.max_cvm_number = 0;
                object.max_allocable_vcpu = 0;
                object.max_allocable_memory_in_mb = 0;
            }
            if (message.max_cvm_number != null && message.hasOwnProperty("max_cvm_number"))
                object.max_cvm_number = message.max_cvm_number;
            if (message.max_allocable_vcpu != null && message.hasOwnProperty("max_allocable_vcpu"))
                object.max_allocable_vcpu = message.max_allocable_vcpu;
            if (message.max_allocable_memory_in_mb != null && message.hasOwnProperty("max_allocable_memory_in_mb"))
                object.max_allocable_memory_in_mb = message.max_allocable_memory_in_mb;
            return object;
        };
        /**
         * Converts this ResourcesSettings to JSON.
         * @function toJSON
         * @memberof vmm.ResourcesSettings
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourcesSettings.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * Gets the default type url for ResourcesSettings
         * @function getTypeUrl
         * @memberof vmm.ResourcesSettings
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ResourcesSettings.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/vmm.ResourcesSettings";
        };
        return ResourcesSettings;
    })();
    vmm.GetMetaResponse = (function () {
        /**
         * Properties of a GetMetaResponse.
         * @memberof vmm
         * @interface IGetMetaResponse
         * @property {vmm.IKmsSettings|null} [kms] GetMetaResponse kms
         * @property {vmm.IGatewaySettings|null} [gateway] GetMetaResponse gateway
         * @property {vmm.IResourcesSettings|null} [resources] GetMetaResponse resources
         */
        /**
         * Constructs a new GetMetaResponse.
         * @memberof vmm
         * @classdesc Represents a GetMetaResponse.
         * @implements IGetMetaResponse
         * @constructor
         * @param {vmm.IGetMetaResponse=} [properties] Properties to set
         */
        function GetMetaResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * GetMetaResponse kms.
         * @member {vmm.IKmsSettings|null|undefined} kms
         * @memberof vmm.GetMetaResponse
         * @instance
         */
        GetMetaResponse.prototype.kms = null;
        /**
         * GetMetaResponse gateway.
         * @member {vmm.IGatewaySettings|null|undefined} gateway
         * @memberof vmm.GetMetaResponse
         * @instance
         */
        GetMetaResponse.prototype.gateway = null;
        /**
         * GetMetaResponse resources.
         * @member {vmm.IResourcesSettings|null|undefined} resources
         * @memberof vmm.GetMetaResponse
         * @instance
         */
        GetMetaResponse.prototype.resources = null;
        /**
         * Creates a new GetMetaResponse instance using the specified properties.
         * @function create
         * @memberof vmm.GetMetaResponse
         * @static
         * @param {vmm.IGetMetaResponse=} [properties] Properties to set
         * @returns {vmm.GetMetaResponse} GetMetaResponse instance
         */
        GetMetaResponse.create = function create(properties) {
            return new GetMetaResponse(properties);
        };
        /**
         * Encodes the specified GetMetaResponse message. Does not implicitly {@link vmm.GetMetaResponse.verify|verify} messages.
         * @function encode
         * @memberof vmm.GetMetaResponse
         * @static
         * @param {vmm.IGetMetaResponse} message GetMetaResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetMetaResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.kms != null && Object.hasOwnProperty.call(message, "kms"))
                $root.vmm.KmsSettings.encode(message.kms, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.gateway != null && Object.hasOwnProperty.call(message, "gateway"))
                $root.vmm.GatewaySettings.encode(message.gateway, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.resources != null && Object.hasOwnProperty.call(message, "resources"))
                $root.vmm.ResourcesSettings.encode(message.resources, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified GetMetaResponse message, length delimited. Does not implicitly {@link vmm.GetMetaResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vmm.GetMetaResponse
         * @static
         * @param {vmm.IGetMetaResponse} message GetMetaResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetMetaResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a GetMetaResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vmm.GetMetaResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vmm.GetMetaResponse} GetMetaResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetMetaResponse.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vmm.GetMetaResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                    case 1: {
                        message.kms = $root.vmm.KmsSettings.decode(reader, reader.uint32());
                        break;
                    }
                    case 2: {
                        message.gateway = $root.vmm.GatewaySettings.decode(reader, reader.uint32());
                        break;
                    }
                    case 3: {
                        message.resources = $root.vmm.ResourcesSettings.decode(reader, reader.uint32());
                        break;
                    }
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a GetMetaResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vmm.GetMetaResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vmm.GetMetaResponse} GetMetaResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetMetaResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a GetMetaResponse message.
         * @function verify
         * @memberof vmm.GetMetaResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetMetaResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.kms != null && message.hasOwnProperty("kms")) {
                var error = $root.vmm.KmsSettings.verify(message.kms);
                if (error)
                    return "kms." + error;
            }
            if (message.gateway != null && message.hasOwnProperty("gateway")) {
                var error = $root.vmm.GatewaySettings.verify(message.gateway);
                if (error)
                    return "gateway." + error;
            }
            if (message.resources != null && message.hasOwnProperty("resources")) {
                var error = $root.vmm.ResourcesSettings.verify(message.resources);
                if (error)
                    return "resources." + error;
            }
            return null;
        };
        /**
         * Creates a GetMetaResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vmm.GetMetaResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vmm.GetMetaResponse} GetMetaResponse
         */
        GetMetaResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vmm.GetMetaResponse)
                return object;
            var message = new $root.vmm.GetMetaResponse();
            if (object.kms != null) {
                if (typeof object.kms !== "object")
                    throw TypeError(".vmm.GetMetaResponse.kms: object expected");
                message.kms = $root.vmm.KmsSettings.fromObject(object.kms);
            }
            if (object.gateway != null) {
                if (typeof object.gateway !== "object")
                    throw TypeError(".vmm.GetMetaResponse.gateway: object expected");
                message.gateway = $root.vmm.GatewaySettings.fromObject(object.gateway);
            }
            if (object.resources != null) {
                if (typeof object.resources !== "object")
                    throw TypeError(".vmm.GetMetaResponse.resources: object expected");
                message.resources = $root.vmm.ResourcesSettings.fromObject(object.resources);
            }
            return message;
        };
        /**
         * Creates a plain object from a GetMetaResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vmm.GetMetaResponse
         * @static
         * @param {vmm.GetMetaResponse} message GetMetaResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetMetaResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.kms = null;
                object.gateway = null;
                object.resources = null;
            }
            if (message.kms != null && message.hasOwnProperty("kms"))
                object.kms = $root.vmm.KmsSettings.toObject(message.kms, options);
            if (message.gateway != null && message.hasOwnProperty("gateway"))
                object.gateway = $root.vmm.GatewaySettings.toObject(message.gateway, options);
            if (message.resources != null && message.hasOwnProperty("resources"))
                object.resources = $root.vmm.ResourcesSettings.toObject(message.resources, options);
            return object;
        };
        /**
         * Converts this GetMetaResponse to JSON.
         * @function toJSON
         * @memberof vmm.GetMetaResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetMetaResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * Gets the default type url for GetMetaResponse
         * @function getTypeUrl
         * @memberof vmm.GetMetaResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetMetaResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/vmm.GetMetaResponse";
        };
        return GetMetaResponse;
    })();
    vmm.VersionResponse = (function () {
        /**
         * Properties of a VersionResponse.
         * @memberof vmm
         * @interface IVersionResponse
         * @property {string|null} [version] VersionResponse version
         * @property {string|null} [rev] VersionResponse rev
         */
        /**
         * Constructs a new VersionResponse.
         * @memberof vmm
         * @classdesc Represents a VersionResponse.
         * @implements IVersionResponse
         * @constructor
         * @param {vmm.IVersionResponse=} [properties] Properties to set
         */
        function VersionResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * VersionResponse version.
         * @member {string} version
         * @memberof vmm.VersionResponse
         * @instance
         */
        VersionResponse.prototype.version = "";
        /**
         * VersionResponse rev.
         * @member {string} rev
         * @memberof vmm.VersionResponse
         * @instance
         */
        VersionResponse.prototype.rev = "";
        /**
         * Creates a new VersionResponse instance using the specified properties.
         * @function create
         * @memberof vmm.VersionResponse
         * @static
         * @param {vmm.IVersionResponse=} [properties] Properties to set
         * @returns {vmm.VersionResponse} VersionResponse instance
         */
        VersionResponse.create = function create(properties) {
            return new VersionResponse(properties);
        };
        /**
         * Encodes the specified VersionResponse message. Does not implicitly {@link vmm.VersionResponse.verify|verify} messages.
         * @function encode
         * @memberof vmm.VersionResponse
         * @static
         * @param {vmm.IVersionResponse} message VersionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VersionResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.version);
            if (message.rev != null && Object.hasOwnProperty.call(message, "rev"))
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.rev);
            return writer;
        };
        /**
         * Encodes the specified VersionResponse message, length delimited. Does not implicitly {@link vmm.VersionResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vmm.VersionResponse
         * @static
         * @param {vmm.IVersionResponse} message VersionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VersionResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a VersionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vmm.VersionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vmm.VersionResponse} VersionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VersionResponse.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vmm.VersionResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                    case 1: {
                        message.version = reader.string();
                        break;
                    }
                    case 2: {
                        message.rev = reader.string();
                        break;
                    }
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a VersionResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vmm.VersionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vmm.VersionResponse} VersionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VersionResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a VersionResponse message.
         * @function verify
         * @memberof vmm.VersionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VersionResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isString(message.version))
                    return "version: string expected";
            if (message.rev != null && message.hasOwnProperty("rev"))
                if (!$util.isString(message.rev))
                    return "rev: string expected";
            return null;
        };
        /**
         * Creates a VersionResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vmm.VersionResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vmm.VersionResponse} VersionResponse
         */
        VersionResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vmm.VersionResponse)
                return object;
            var message = new $root.vmm.VersionResponse();
            if (object.version != null)
                message.version = String(object.version);
            if (object.rev != null)
                message.rev = String(object.rev);
            return message;
        };
        /**
         * Creates a plain object from a VersionResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vmm.VersionResponse
         * @static
         * @param {vmm.VersionResponse} message VersionResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VersionResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.version = "";
                object.rev = "";
            }
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.rev != null && message.hasOwnProperty("rev"))
                object.rev = message.rev;
            return object;
        };
        /**
         * Converts this VersionResponse to JSON.
         * @function toJSON
         * @memberof vmm.VersionResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VersionResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * Gets the default type url for VersionResponse
         * @function getTypeUrl
         * @memberof vmm.VersionResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        VersionResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/vmm.VersionResponse";
        };
        return VersionResponse;
    })();
    vmm.ListGpusResponse = (function () {
        /**
         * Properties of a ListGpusResponse.
         * @memberof vmm
         * @interface IListGpusResponse
         * @property {Array.<vmm.IGpuInfo>|null} [gpus] ListGpusResponse gpus
         * @property {boolean|null} [allow_attach_all] ListGpusResponse allow_attach_all
         */
        /**
         * Constructs a new ListGpusResponse.
         * @memberof vmm
         * @classdesc Represents a ListGpusResponse.
         * @implements IListGpusResponse
         * @constructor
         * @param {vmm.IListGpusResponse=} [properties] Properties to set
         */
        function ListGpusResponse(properties) {
            this.gpus = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ListGpusResponse gpus.
         * @member {Array.<vmm.IGpuInfo>} gpus
         * @memberof vmm.ListGpusResponse
         * @instance
         */
        ListGpusResponse.prototype.gpus = $util.emptyArray;
        /**
         * ListGpusResponse allow_attach_all.
         * @member {boolean} allow_attach_all
         * @memberof vmm.ListGpusResponse
         * @instance
         */
        ListGpusResponse.prototype.allow_attach_all = false;
        /**
         * Creates a new ListGpusResponse instance using the specified properties.
         * @function create
         * @memberof vmm.ListGpusResponse
         * @static
         * @param {vmm.IListGpusResponse=} [properties] Properties to set
         * @returns {vmm.ListGpusResponse} ListGpusResponse instance
         */
        ListGpusResponse.create = function create(properties) {
            return new ListGpusResponse(properties);
        };
        /**
         * Encodes the specified ListGpusResponse message. Does not implicitly {@link vmm.ListGpusResponse.verify|verify} messages.
         * @function encode
         * @memberof vmm.ListGpusResponse
         * @static
         * @param {vmm.IListGpusResponse} message ListGpusResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListGpusResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gpus != null && message.gpus.length)
                for (var i = 0; i < message.gpus.length; ++i)
                    $root.vmm.GpuInfo.encode(message.gpus[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.allow_attach_all != null && Object.hasOwnProperty.call(message, "allow_attach_all"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message.allow_attach_all);
            return writer;
        };
        /**
         * Encodes the specified ListGpusResponse message, length delimited. Does not implicitly {@link vmm.ListGpusResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vmm.ListGpusResponse
         * @static
         * @param {vmm.IListGpusResponse} message ListGpusResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListGpusResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a ListGpusResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vmm.ListGpusResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vmm.ListGpusResponse} ListGpusResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListGpusResponse.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vmm.ListGpusResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                    case 1: {
                        if (!(message.gpus && message.gpus.length))
                            message.gpus = [];
                        message.gpus.push($root.vmm.GpuInfo.decode(reader, reader.uint32()));
                        break;
                    }
                    case 2: {
                        message.allow_attach_all = reader.bool();
                        break;
                    }
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a ListGpusResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vmm.ListGpusResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vmm.ListGpusResponse} ListGpusResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListGpusResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a ListGpusResponse message.
         * @function verify
         * @memberof vmm.ListGpusResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListGpusResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gpus != null && message.hasOwnProperty("gpus")) {
                if (!Array.isArray(message.gpus))
                    return "gpus: array expected";
                for (var i = 0; i < message.gpus.length; ++i) {
                    var error = $root.vmm.GpuInfo.verify(message.gpus[i]);
                    if (error)
                        return "gpus." + error;
                }
            }
            if (message.allow_attach_all != null && message.hasOwnProperty("allow_attach_all"))
                if (typeof message.allow_attach_all !== "boolean")
                    return "allow_attach_all: boolean expected";
            return null;
        };
        /**
         * Creates a ListGpusResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vmm.ListGpusResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vmm.ListGpusResponse} ListGpusResponse
         */
        ListGpusResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vmm.ListGpusResponse)
                return object;
            var message = new $root.vmm.ListGpusResponse();
            if (object.gpus) {
                if (!Array.isArray(object.gpus))
                    throw TypeError(".vmm.ListGpusResponse.gpus: array expected");
                message.gpus = [];
                for (var i = 0; i < object.gpus.length; ++i) {
                    if (typeof object.gpus[i] !== "object")
                        throw TypeError(".vmm.ListGpusResponse.gpus: object expected");
                    message.gpus[i] = $root.vmm.GpuInfo.fromObject(object.gpus[i]);
                }
            }
            if (object.allow_attach_all != null)
                message.allow_attach_all = Boolean(object.allow_attach_all);
            return message;
        };
        /**
         * Creates a plain object from a ListGpusResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vmm.ListGpusResponse
         * @static
         * @param {vmm.ListGpusResponse} message ListGpusResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListGpusResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.gpus = [];
            if (options.defaults)
                object.allow_attach_all = false;
            if (message.gpus && message.gpus.length) {
                object.gpus = [];
                for (var j = 0; j < message.gpus.length; ++j)
                    object.gpus[j] = $root.vmm.GpuInfo.toObject(message.gpus[j], options);
            }
            if (message.allow_attach_all != null && message.hasOwnProperty("allow_attach_all"))
                object.allow_attach_all = message.allow_attach_all;
            return object;
        };
        /**
         * Converts this ListGpusResponse to JSON.
         * @function toJSON
         * @memberof vmm.ListGpusResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListGpusResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * Gets the default type url for ListGpusResponse
         * @function getTypeUrl
         * @memberof vmm.ListGpusResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ListGpusResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/vmm.ListGpusResponse";
        };
        return ListGpusResponse;
    })();
    vmm.ReloadVmsResponse = (function () {
        /**
         * Properties of a ReloadVmsResponse.
         * @memberof vmm
         * @interface IReloadVmsResponse
         * @property {number|null} [loaded] ReloadVmsResponse loaded
         * @property {number|null} [updated] ReloadVmsResponse updated
         * @property {number|null} [removed] ReloadVmsResponse removed
         */
        /**
         * Constructs a new ReloadVmsResponse.
         * @memberof vmm
         * @classdesc Represents a ReloadVmsResponse.
         * @implements IReloadVmsResponse
         * @constructor
         * @param {vmm.IReloadVmsResponse=} [properties] Properties to set
         */
        function ReloadVmsResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ReloadVmsResponse loaded.
         * @member {number} loaded
         * @memberof vmm.ReloadVmsResponse
         * @instance
         */
        ReloadVmsResponse.prototype.loaded = 0;
        /**
         * ReloadVmsResponse updated.
         * @member {number} updated
         * @memberof vmm.ReloadVmsResponse
         * @instance
         */
        ReloadVmsResponse.prototype.updated = 0;
        /**
         * ReloadVmsResponse removed.
         * @member {number} removed
         * @memberof vmm.ReloadVmsResponse
         * @instance
         */
        ReloadVmsResponse.prototype.removed = 0;
        /**
         * Creates a new ReloadVmsResponse instance using the specified properties.
         * @function create
         * @memberof vmm.ReloadVmsResponse
         * @static
         * @param {vmm.IReloadVmsResponse=} [properties] Properties to set
         * @returns {vmm.ReloadVmsResponse} ReloadVmsResponse instance
         */
        ReloadVmsResponse.create = function create(properties) {
            return new ReloadVmsResponse(properties);
        };
        /**
         * Encodes the specified ReloadVmsResponse message. Does not implicitly {@link vmm.ReloadVmsResponse.verify|verify} messages.
         * @function encode
         * @memberof vmm.ReloadVmsResponse
         * @static
         * @param {vmm.IReloadVmsResponse} message ReloadVmsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReloadVmsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.loaded != null && Object.hasOwnProperty.call(message, "loaded"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).uint32(message.loaded);
            if (message.updated != null && Object.hasOwnProperty.call(message, "updated"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).uint32(message.updated);
            if (message.removed != null && Object.hasOwnProperty.call(message, "removed"))
                writer.uint32(/* id 3, wireType 0 =*/ 24).uint32(message.removed);
            return writer;
        };
        /**
         * Encodes the specified ReloadVmsResponse message, length delimited. Does not implicitly {@link vmm.ReloadVmsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vmm.ReloadVmsResponse
         * @static
         * @param {vmm.IReloadVmsResponse} message ReloadVmsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReloadVmsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a ReloadVmsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vmm.ReloadVmsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vmm.ReloadVmsResponse} ReloadVmsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReloadVmsResponse.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vmm.ReloadVmsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                    case 1: {
                        message.loaded = reader.uint32();
                        break;
                    }
                    case 2: {
                        message.updated = reader.uint32();
                        break;
                    }
                    case 3: {
                        message.removed = reader.uint32();
                        break;
                    }
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a ReloadVmsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vmm.ReloadVmsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vmm.ReloadVmsResponse} ReloadVmsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReloadVmsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a ReloadVmsResponse message.
         * @function verify
         * @memberof vmm.ReloadVmsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReloadVmsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.loaded != null && message.hasOwnProperty("loaded"))
                if (!$util.isInteger(message.loaded))
                    return "loaded: integer expected";
            if (message.updated != null && message.hasOwnProperty("updated"))
                if (!$util.isInteger(message.updated))
                    return "updated: integer expected";
            if (message.removed != null && message.hasOwnProperty("removed"))
                if (!$util.isInteger(message.removed))
                    return "removed: integer expected";
            return null;
        };
        /**
         * Creates a ReloadVmsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vmm.ReloadVmsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vmm.ReloadVmsResponse} ReloadVmsResponse
         */
        ReloadVmsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vmm.ReloadVmsResponse)
                return object;
            var message = new $root.vmm.ReloadVmsResponse();
            if (object.loaded != null)
                message.loaded = object.loaded >>> 0;
            if (object.updated != null)
                message.updated = object.updated >>> 0;
            if (object.removed != null)
                message.removed = object.removed >>> 0;
            return message;
        };
        /**
         * Creates a plain object from a ReloadVmsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vmm.ReloadVmsResponse
         * @static
         * @param {vmm.ReloadVmsResponse} message ReloadVmsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReloadVmsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.loaded = 0;
                object.updated = 0;
                object.removed = 0;
            }
            if (message.loaded != null && message.hasOwnProperty("loaded"))
                object.loaded = message.loaded;
            if (message.updated != null && message.hasOwnProperty("updated"))
                object.updated = message.updated;
            if (message.removed != null && message.hasOwnProperty("removed"))
                object.removed = message.removed;
            return object;
        };
        /**
         * Converts this ReloadVmsResponse to JSON.
         * @function toJSON
         * @memberof vmm.ReloadVmsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReloadVmsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * Gets the default type url for ReloadVmsResponse
         * @function getTypeUrl
         * @memberof vmm.ReloadVmsResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ReloadVmsResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/vmm.ReloadVmsResponse";
        };
        return ReloadVmsResponse;
    })();
    vmm.GpuInfo = (function () {
        /**
         * Properties of a GpuInfo.
         * @memberof vmm
         * @interface IGpuInfo
         * @property {string|null} [slot] GpuInfo slot
         * @property {string|null} [product_id] GpuInfo product_id
         * @property {string|null} [description] GpuInfo description
         * @property {boolean|null} [is_free] GpuInfo is_free
         */
        /**
         * Constructs a new GpuInfo.
         * @memberof vmm
         * @classdesc Represents a GpuInfo.
         * @implements IGpuInfo
         * @constructor
         * @param {vmm.IGpuInfo=} [properties] Properties to set
         */
        function GpuInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * GpuInfo slot.
         * @member {string} slot
         * @memberof vmm.GpuInfo
         * @instance
         */
        GpuInfo.prototype.slot = "";
        /**
         * GpuInfo product_id.
         * @member {string} product_id
         * @memberof vmm.GpuInfo
         * @instance
         */
        GpuInfo.prototype.product_id = "";
        /**
         * GpuInfo description.
         * @member {string} description
         * @memberof vmm.GpuInfo
         * @instance
         */
        GpuInfo.prototype.description = "";
        /**
         * GpuInfo is_free.
         * @member {boolean} is_free
         * @memberof vmm.GpuInfo
         * @instance
         */
        GpuInfo.prototype.is_free = false;
        /**
         * Creates a new GpuInfo instance using the specified properties.
         * @function create
         * @memberof vmm.GpuInfo
         * @static
         * @param {vmm.IGpuInfo=} [properties] Properties to set
         * @returns {vmm.GpuInfo} GpuInfo instance
         */
        GpuInfo.create = function create(properties) {
            return new GpuInfo(properties);
        };
        /**
         * Encodes the specified GpuInfo message. Does not implicitly {@link vmm.GpuInfo.verify|verify} messages.
         * @function encode
         * @memberof vmm.GpuInfo
         * @static
         * @param {vmm.IGpuInfo} message GpuInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GpuInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.slot != null && Object.hasOwnProperty.call(message, "slot"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.slot);
            if (message.product_id != null && Object.hasOwnProperty.call(message, "product_id"))
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.product_id);
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.description);
            if (message.is_free != null && Object.hasOwnProperty.call(message, "is_free"))
                writer.uint32(/* id 4, wireType 0 =*/ 32).bool(message.is_free);
            return writer;
        };
        /**
         * Encodes the specified GpuInfo message, length delimited. Does not implicitly {@link vmm.GpuInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vmm.GpuInfo
         * @static
         * @param {vmm.IGpuInfo} message GpuInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GpuInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a GpuInfo message from the specified reader or buffer.
         * @function decode
         * @memberof vmm.GpuInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vmm.GpuInfo} GpuInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GpuInfo.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vmm.GpuInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                    case 1: {
                        message.slot = reader.string();
                        break;
                    }
                    case 2: {
                        message.product_id = reader.string();
                        break;
                    }
                    case 3: {
                        message.description = reader.string();
                        break;
                    }
                    case 4: {
                        message.is_free = reader.bool();
                        break;
                    }
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a GpuInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vmm.GpuInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vmm.GpuInfo} GpuInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GpuInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a GpuInfo message.
         * @function verify
         * @memberof vmm.GpuInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GpuInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.slot != null && message.hasOwnProperty("slot"))
                if (!$util.isString(message.slot))
                    return "slot: string expected";
            if (message.product_id != null && message.hasOwnProperty("product_id"))
                if (!$util.isString(message.product_id))
                    return "product_id: string expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.is_free != null && message.hasOwnProperty("is_free"))
                if (typeof message.is_free !== "boolean")
                    return "is_free: boolean expected";
            return null;
        };
        /**
         * Creates a GpuInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vmm.GpuInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vmm.GpuInfo} GpuInfo
         */
        GpuInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.vmm.GpuInfo)
                return object;
            var message = new $root.vmm.GpuInfo();
            if (object.slot != null)
                message.slot = String(object.slot);
            if (object.product_id != null)
                message.product_id = String(object.product_id);
            if (object.description != null)
                message.description = String(object.description);
            if (object.is_free != null)
                message.is_free = Boolean(object.is_free);
            return message;
        };
        /**
         * Creates a plain object from a GpuInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vmm.GpuInfo
         * @static
         * @param {vmm.GpuInfo} message GpuInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GpuInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.slot = "";
                object.product_id = "";
                object.description = "";
                object.is_free = false;
            }
            if (message.slot != null && message.hasOwnProperty("slot"))
                object.slot = message.slot;
            if (message.product_id != null && message.hasOwnProperty("product_id"))
                object.product_id = message.product_id;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.is_free != null && message.hasOwnProperty("is_free"))
                object.is_free = message.is_free;
            return object;
        };
        /**
         * Converts this GpuInfo to JSON.
         * @function toJSON
         * @memberof vmm.GpuInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GpuInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * Gets the default type url for GpuInfo
         * @function getTypeUrl
         * @memberof vmm.GpuInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GpuInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/vmm.GpuInfo";
        };
        return GpuInfo;
    })();
    vmm.Vmm = (function () {
        /**
         * Constructs a new Vmm service.
         * @memberof vmm
         * @classdesc Represents a Vmm
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function Vmm(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }
        (Vmm.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Vmm;
        /**
         * Creates new Vmm service using the specified rpc implementation.
         * @function create
         * @memberof vmm.Vmm
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {Vmm} RPC service. Useful where requests and/or responses are streamed.
         */
        Vmm.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };
        /**
         * Callback as used by {@link vmm.Vmm#createVm}.
         * @memberof vmm.Vmm
         * @typedef CreateVmCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {vmm.Id} [response] Id
         */
        /**
         * Calls CreateVm.
         * @function createVm
         * @memberof vmm.Vmm
         * @instance
         * @param {vmm.IVmConfiguration} request VmConfiguration message or plain object
         * @param {vmm.Vmm.CreateVmCallback} callback Node-style callback called with the error, if any, and Id
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Vmm.prototype.createVm = function createVm(request, callback) {
            return this.rpcCall(createVm, $root.vmm.VmConfiguration, $root.vmm.Id, request, callback);
        }, "name", { value: "CreateVm" });
        /**
         * Calls CreateVm.
         * @function createVm
         * @memberof vmm.Vmm
         * @instance
         * @param {vmm.IVmConfiguration} request VmConfiguration message or plain object
         * @returns {Promise<vmm.Id>} Promise
         * @variation 2
         */
        /**
         * Callback as used by {@link vmm.Vmm#startVm}.
         * @memberof vmm.Vmm
         * @typedef StartVmCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {google.protobuf.Empty} [response] Empty
         */
        /**
         * Calls StartVm.
         * @function startVm
         * @memberof vmm.Vmm
         * @instance
         * @param {vmm.IId} request Id message or plain object
         * @param {vmm.Vmm.StartVmCallback} callback Node-style callback called with the error, if any, and Empty
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Vmm.prototype.startVm = function startVm(request, callback) {
            return this.rpcCall(startVm, $root.vmm.Id, $root.google.protobuf.Empty, request, callback);
        }, "name", { value: "StartVm" });
        /**
         * Calls StartVm.
         * @function startVm
         * @memberof vmm.Vmm
         * @instance
         * @param {vmm.IId} request Id message or plain object
         * @returns {Promise<google.protobuf.Empty>} Promise
         * @variation 2
         */
        /**
         * Callback as used by {@link vmm.Vmm#stopVm}.
         * @memberof vmm.Vmm
         * @typedef StopVmCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {google.protobuf.Empty} [response] Empty
         */
        /**
         * Calls StopVm.
         * @function stopVm
         * @memberof vmm.Vmm
         * @instance
         * @param {vmm.IId} request Id message or plain object
         * @param {vmm.Vmm.StopVmCallback} callback Node-style callback called with the error, if any, and Empty
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Vmm.prototype.stopVm = function stopVm(request, callback) {
            return this.rpcCall(stopVm, $root.vmm.Id, $root.google.protobuf.Empty, request, callback);
        }, "name", { value: "StopVm" });
        /**
         * Calls StopVm.
         * @function stopVm
         * @memberof vmm.Vmm
         * @instance
         * @param {vmm.IId} request Id message or plain object
         * @returns {Promise<google.protobuf.Empty>} Promise
         * @variation 2
         */
        /**
         * Callback as used by {@link vmm.Vmm#removeVm}.
         * @memberof vmm.Vmm
         * @typedef RemoveVmCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {google.protobuf.Empty} [response] Empty
         */
        /**
         * Calls RemoveVm.
         * @function removeVm
         * @memberof vmm.Vmm
         * @instance
         * @param {vmm.IId} request Id message or plain object
         * @param {vmm.Vmm.RemoveVmCallback} callback Node-style callback called with the error, if any, and Empty
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Vmm.prototype.removeVm = function removeVm(request, callback) {
            return this.rpcCall(removeVm, $root.vmm.Id, $root.google.protobuf.Empty, request, callback);
        }, "name", { value: "RemoveVm" });
        /**
         * Calls RemoveVm.
         * @function removeVm
         * @memberof vmm.Vmm
         * @instance
         * @param {vmm.IId} request Id message or plain object
         * @returns {Promise<google.protobuf.Empty>} Promise
         * @variation 2
         */
        /**
         * Callback as used by {@link vmm.Vmm#upgradeApp}.
         * @memberof vmm.Vmm
         * @typedef UpgradeAppCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {vmm.Id} [response] Id
         */
        /**
         * Calls UpgradeApp.
         * @function upgradeApp
         * @memberof vmm.Vmm
         * @instance
         * @param {vmm.IUpdateVmRequest} request UpdateVmRequest message or plain object
         * @param {vmm.Vmm.UpgradeAppCallback} callback Node-style callback called with the error, if any, and Id
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Vmm.prototype.upgradeApp = function upgradeApp(request, callback) {
            return this.rpcCall(upgradeApp, $root.vmm.UpdateVmRequest, $root.vmm.Id, request, callback);
        }, "name", { value: "UpgradeApp" });
        /**
         * Calls UpgradeApp.
         * @function upgradeApp
         * @memberof vmm.Vmm
         * @instance
         * @param {vmm.IUpdateVmRequest} request UpdateVmRequest message or plain object
         * @returns {Promise<vmm.Id>} Promise
         * @variation 2
         */
        /**
         * Callback as used by {@link vmm.Vmm#updateVm}.
         * @memberof vmm.Vmm
         * @typedef UpdateVmCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {vmm.Id} [response] Id
         */
        /**
         * Calls UpdateVm.
         * @function updateVm
         * @memberof vmm.Vmm
         * @instance
         * @param {vmm.IUpdateVmRequest} request UpdateVmRequest message or plain object
         * @param {vmm.Vmm.UpdateVmCallback} callback Node-style callback called with the error, if any, and Id
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Vmm.prototype.updateVm = function updateVm(request, callback) {
            return this.rpcCall(updateVm, $root.vmm.UpdateVmRequest, $root.vmm.Id, request, callback);
        }, "name", { value: "UpdateVm" });
        /**
         * Calls UpdateVm.
         * @function updateVm
         * @memberof vmm.Vmm
         * @instance
         * @param {vmm.IUpdateVmRequest} request UpdateVmRequest message or plain object
         * @returns {Promise<vmm.Id>} Promise
         * @variation 2
         */
        /**
         * Callback as used by {@link vmm.Vmm#shutdownVm}.
         * @memberof vmm.Vmm
         * @typedef ShutdownVmCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {google.protobuf.Empty} [response] Empty
         */
        /**
         * Calls ShutdownVm.
         * @function shutdownVm
         * @memberof vmm.Vmm
         * @instance
         * @param {vmm.IId} request Id message or plain object
         * @param {vmm.Vmm.ShutdownVmCallback} callback Node-style callback called with the error, if any, and Empty
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Vmm.prototype.shutdownVm = function shutdownVm(request, callback) {
            return this.rpcCall(shutdownVm, $root.vmm.Id, $root.google.protobuf.Empty, request, callback);
        }, "name", { value: "ShutdownVm" });
        /**
         * Calls ShutdownVm.
         * @function shutdownVm
         * @memberof vmm.Vmm
         * @instance
         * @param {vmm.IId} request Id message or plain object
         * @returns {Promise<google.protobuf.Empty>} Promise
         * @variation 2
         */
        /**
         * Callback as used by {@link vmm.Vmm#resizeVm}.
         * @memberof vmm.Vmm
         * @typedef ResizeVmCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {google.protobuf.Empty} [response] Empty
         */
        /**
         * Calls ResizeVm.
         * @function resizeVm
         * @memberof vmm.Vmm
         * @instance
         * @param {vmm.IResizeVmRequest} request ResizeVmRequest message or plain object
         * @param {vmm.Vmm.ResizeVmCallback} callback Node-style callback called with the error, if any, and Empty
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Vmm.prototype.resizeVm = function resizeVm(request, callback) {
            return this.rpcCall(resizeVm, $root.vmm.ResizeVmRequest, $root.google.protobuf.Empty, request, callback);
        }, "name", { value: "ResizeVm" });
        /**
         * Calls ResizeVm.
         * @function resizeVm
         * @memberof vmm.Vmm
         * @instance
         * @param {vmm.IResizeVmRequest} request ResizeVmRequest message or plain object
         * @returns {Promise<google.protobuf.Empty>} Promise
         * @variation 2
         */
        /**
         * Callback as used by {@link vmm.Vmm#getComposeHash}.
         * @memberof vmm.Vmm
         * @typedef GetComposeHashCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {vmm.ComposeHash} [response] ComposeHash
         */
        /**
         * Calls GetComposeHash.
         * @function getComposeHash
         * @memberof vmm.Vmm
         * @instance
         * @param {vmm.IVmConfiguration} request VmConfiguration message or plain object
         * @param {vmm.Vmm.GetComposeHashCallback} callback Node-style callback called with the error, if any, and ComposeHash
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Vmm.prototype.getComposeHash = function getComposeHash(request, callback) {
            return this.rpcCall(getComposeHash, $root.vmm.VmConfiguration, $root.vmm.ComposeHash, request, callback);
        }, "name", { value: "GetComposeHash" });
        /**
         * Calls GetComposeHash.
         * @function getComposeHash
         * @memberof vmm.Vmm
         * @instance
         * @param {vmm.IVmConfiguration} request VmConfiguration message or plain object
         * @returns {Promise<vmm.ComposeHash>} Promise
         * @variation 2
         */
        /**
         * Callback as used by {@link vmm.Vmm#status}.
         * @memberof vmm.Vmm
         * @typedef StatusCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {vmm.StatusResponse} [response] StatusResponse
         */
        /**
         * Calls Status.
         * @function status
         * @memberof vmm.Vmm
         * @instance
         * @param {vmm.IStatusRequest} request StatusRequest message or plain object
         * @param {vmm.Vmm.StatusCallback} callback Node-style callback called with the error, if any, and StatusResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Vmm.prototype.status = function status(request, callback) {
            return this.rpcCall(status, $root.vmm.StatusRequest, $root.vmm.StatusResponse, request, callback);
        }, "name", { value: "Status" });
        /**
         * Calls Status.
         * @function status
         * @memberof vmm.Vmm
         * @instance
         * @param {vmm.IStatusRequest} request StatusRequest message or plain object
         * @returns {Promise<vmm.StatusResponse>} Promise
         * @variation 2
         */
        /**
         * Callback as used by {@link vmm.Vmm#listImages}.
         * @memberof vmm.Vmm
         * @typedef ListImagesCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {vmm.ImageListResponse} [response] ImageListResponse
         */
        /**
         * Calls ListImages.
         * @function listImages
         * @memberof vmm.Vmm
         * @instance
         * @param {google.protobuf.IEmpty} request Empty message or plain object
         * @param {vmm.Vmm.ListImagesCallback} callback Node-style callback called with the error, if any, and ImageListResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Vmm.prototype.listImages = function listImages(request, callback) {
            return this.rpcCall(listImages, $root.google.protobuf.Empty, $root.vmm.ImageListResponse, request, callback);
        }, "name", { value: "ListImages" });
        /**
         * Calls ListImages.
         * @function listImages
         * @memberof vmm.Vmm
         * @instance
         * @param {google.protobuf.IEmpty} request Empty message or plain object
         * @returns {Promise<vmm.ImageListResponse>} Promise
         * @variation 2
         */
        /**
         * Callback as used by {@link vmm.Vmm#getAppEnvEncryptPubKey}.
         * @memberof vmm.Vmm
         * @typedef GetAppEnvEncryptPubKeyCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {vmm.PublicKeyResponse} [response] PublicKeyResponse
         */
        /**
         * Calls GetAppEnvEncryptPubKey.
         * @function getAppEnvEncryptPubKey
         * @memberof vmm.Vmm
         * @instance
         * @param {vmm.IAppId} request AppId message or plain object
         * @param {vmm.Vmm.GetAppEnvEncryptPubKeyCallback} callback Node-style callback called with the error, if any, and PublicKeyResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Vmm.prototype.getAppEnvEncryptPubKey = function getAppEnvEncryptPubKey(request, callback) {
            return this.rpcCall(getAppEnvEncryptPubKey, $root.vmm.AppId, $root.vmm.PublicKeyResponse, request, callback);
        }, "name", { value: "GetAppEnvEncryptPubKey" });
        /**
         * Calls GetAppEnvEncryptPubKey.
         * @function getAppEnvEncryptPubKey
         * @memberof vmm.Vmm
         * @instance
         * @param {vmm.IAppId} request AppId message or plain object
         * @returns {Promise<vmm.PublicKeyResponse>} Promise
         * @variation 2
         */
        /**
         * Callback as used by {@link vmm.Vmm#getInfo}.
         * @memberof vmm.Vmm
         * @typedef GetInfoCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {vmm.GetInfoResponse} [response] GetInfoResponse
         */
        /**
         * Calls GetInfo.
         * @function getInfo
         * @memberof vmm.Vmm
         * @instance
         * @param {vmm.IId} request Id message or plain object
         * @param {vmm.Vmm.GetInfoCallback} callback Node-style callback called with the error, if any, and GetInfoResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Vmm.prototype.getInfo = function getInfo(request, callback) {
            return this.rpcCall(getInfo, $root.vmm.Id, $root.vmm.GetInfoResponse, request, callback);
        }, "name", { value: "GetInfo" });
        /**
         * Calls GetInfo.
         * @function getInfo
         * @memberof vmm.Vmm
         * @instance
         * @param {vmm.IId} request Id message or plain object
         * @returns {Promise<vmm.GetInfoResponse>} Promise
         * @variation 2
         */
        /**
         * Callback as used by {@link vmm.Vmm#version}.
         * @memberof vmm.Vmm
         * @typedef VersionCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {vmm.VersionResponse} [response] VersionResponse
         */
        /**
         * Calls Version.
         * @function version
         * @memberof vmm.Vmm
         * @instance
         * @param {google.protobuf.IEmpty} request Empty message or plain object
         * @param {vmm.Vmm.VersionCallback} callback Node-style callback called with the error, if any, and VersionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Vmm.prototype.version = function version(request, callback) {
            return this.rpcCall(version, $root.google.protobuf.Empty, $root.vmm.VersionResponse, request, callback);
        }, "name", { value: "Version" });
        /**
         * Calls Version.
         * @function version
         * @memberof vmm.Vmm
         * @instance
         * @param {google.protobuf.IEmpty} request Empty message or plain object
         * @returns {Promise<vmm.VersionResponse>} Promise
         * @variation 2
         */
        /**
         * Callback as used by {@link vmm.Vmm#getMeta}.
         * @memberof vmm.Vmm
         * @typedef GetMetaCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {vmm.GetMetaResponse} [response] GetMetaResponse
         */
        /**
         * Calls GetMeta.
         * @function getMeta
         * @memberof vmm.Vmm
         * @instance
         * @param {google.protobuf.IEmpty} request Empty message or plain object
         * @param {vmm.Vmm.GetMetaCallback} callback Node-style callback called with the error, if any, and GetMetaResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Vmm.prototype.getMeta = function getMeta(request, callback) {
            return this.rpcCall(getMeta, $root.google.protobuf.Empty, $root.vmm.GetMetaResponse, request, callback);
        }, "name", { value: "GetMeta" });
        /**
         * Calls GetMeta.
         * @function getMeta
         * @memberof vmm.Vmm
         * @instance
         * @param {google.protobuf.IEmpty} request Empty message or plain object
         * @returns {Promise<vmm.GetMetaResponse>} Promise
         * @variation 2
         */
        /**
         * Callback as used by {@link vmm.Vmm#listGpus}.
         * @memberof vmm.Vmm
         * @typedef ListGpusCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {vmm.ListGpusResponse} [response] ListGpusResponse
         */
        /**
         * Calls ListGpus.
         * @function listGpus
         * @memberof vmm.Vmm
         * @instance
         * @param {google.protobuf.IEmpty} request Empty message or plain object
         * @param {vmm.Vmm.ListGpusCallback} callback Node-style callback called with the error, if any, and ListGpusResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Vmm.prototype.listGpus = function listGpus(request, callback) {
            return this.rpcCall(listGpus, $root.google.protobuf.Empty, $root.vmm.ListGpusResponse, request, callback);
        }, "name", { value: "ListGpus" });
        /**
         * Calls ListGpus.
         * @function listGpus
         * @memberof vmm.Vmm
         * @instance
         * @param {google.protobuf.IEmpty} request Empty message or plain object
         * @returns {Promise<vmm.ListGpusResponse>} Promise
         * @variation 2
         */
        /**
         * Callback as used by {@link vmm.Vmm#reloadVms}.
         * @memberof vmm.Vmm
         * @typedef ReloadVmsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {vmm.ReloadVmsResponse} [response] ReloadVmsResponse
         */
        /**
         * Calls ReloadVms.
         * @function reloadVms
         * @memberof vmm.Vmm
         * @instance
         * @param {google.protobuf.IEmpty} request Empty message or plain object
         * @param {vmm.Vmm.ReloadVmsCallback} callback Node-style callback called with the error, if any, and ReloadVmsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Vmm.prototype.reloadVms = function reloadVms(request, callback) {
            return this.rpcCall(reloadVms, $root.google.protobuf.Empty, $root.vmm.ReloadVmsResponse, request, callback);
        }, "name", { value: "ReloadVms" });
        /**
         * Calls ReloadVms.
         * @function reloadVms
         * @memberof vmm.Vmm
         * @instance
         * @param {google.protobuf.IEmpty} request Empty message or plain object
         * @returns {Promise<vmm.ReloadVmsResponse>} Promise
         * @variation 2
         */
        return Vmm;
    })();
    return vmm;
})();
$root.google = (function () {
    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    var google = {};
    google.protobuf = (function () {
        /**
         * Namespace protobuf.
         * @memberof google
         * @namespace
         */
        var protobuf = {};
        protobuf.Empty = (function () {
            /**
             * Properties of an Empty.
             * @memberof google.protobuf
             * @interface IEmpty
             */
            /**
             * Constructs a new Empty.
             * @memberof google.protobuf
             * @classdesc Represents an Empty.
             * @implements IEmpty
             * @constructor
             * @param {google.protobuf.IEmpty=} [properties] Properties to set
             */
            function Empty(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * Creates a new Empty instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.IEmpty=} [properties] Properties to set
             * @returns {google.protobuf.Empty} Empty instance
             */
            Empty.create = function create(properties) {
                return new Empty(properties);
            };
            /**
             * Encodes the specified Empty message. Does not implicitly {@link google.protobuf.Empty.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.IEmpty} message Empty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Empty.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
            /**
             * Encodes the specified Empty message, length delimited. Does not implicitly {@link google.protobuf.Empty.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.IEmpty} message Empty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Empty.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes an Empty message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Empty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Empty} Empty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Empty.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Empty();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes an Empty message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Empty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Empty} Empty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Empty.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies an Empty message.
             * @function verify
             * @memberof google.protobuf.Empty
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Empty.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
            /**
             * Creates an Empty message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Empty
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Empty} Empty
             */
            Empty.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Empty)
                    return object;
                return new $root.google.protobuf.Empty();
            };
            /**
             * Creates a plain object from an Empty message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.Empty} message Empty
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Empty.toObject = function toObject() {
                return {};
            };
            /**
             * Converts this Empty to JSON.
             * @function toJSON
             * @memberof google.protobuf.Empty
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Empty.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
             * Gets the default type url for Empty
             * @function getTypeUrl
             * @memberof google.protobuf.Empty
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Empty.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.Empty";
            };
            return Empty;
        })();
        return protobuf;
    })();
    return google;
})();
module.exports = $root;

}, map: {"protobufjs/minimal":"node_modules/protobufjs/minimal.js"} },
'node_modules/protobufjs/minimal.js': { factory: function(module, exports, require) {
// minimal library entry point.

"use strict";
module.exports = require("./src/index-minimal");

}, map: {"./src/index-minimal":"node_modules/protobufjs/src/index-minimal.js"} },
'node_modules/protobufjs/src/index-minimal.js': { factory: function(module, exports, require) {
"use strict";
var protobuf = exports;

/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */
protobuf.build = "minimal";

// Serialization
protobuf.Writer       = require("./writer");
protobuf.BufferWriter = require("./writer_buffer");
protobuf.Reader       = require("./reader");
protobuf.BufferReader = require("./reader_buffer");

// Utility
protobuf.util         = require("./util/minimal");
protobuf.rpc          = require("./rpc");
protobuf.roots        = require("./roots");
protobuf.configure    = configure;

/* istanbul ignore next */
/**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */
function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
}

// Set up buffer utility according to the environment
configure();

}, map: {"./writer":"node_modules/protobufjs/src/writer.js","./writer_buffer":"node_modules/protobufjs/src/writer_buffer.js","./reader":"node_modules/protobufjs/src/reader.js","./reader_buffer":"node_modules/protobufjs/src/reader_buffer.js","./util/minimal":"node_modules/protobufjs/src/util/minimal.js","./rpc":"node_modules/protobufjs/src/rpc.js","./roots":"node_modules/protobufjs/src/roots.js"} },
'node_modules/protobufjs/src/writer.js': { factory: function(module, exports, require) {
"use strict";
module.exports = Writer;

var util      = require("./util/minimal");

var BufferWriter; // cyclic

var LongBits  = util.LongBits,
    base64    = util.base64,
    utf8      = util.utf8;

/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */
function Op(fn, len, val) {

    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */
    this.fn = fn;

    /**
     * Value byte length.
     * @type {number}
     */
    this.len = len;

    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */
    this.next = undefined;

    /**
     * Value to write.
     * @type {*}
     */
    this.val = val; // type varies
}

/* istanbul ignore next */
function noop() {} // eslint-disable-line no-empty-function

/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */
function State(writer) {

    /**
     * Current head.
     * @type {Writer.Op}
     */
    this.head = writer.head;

    /**
     * Current tail.
     * @type {Writer.Op}
     */
    this.tail = writer.tail;

    /**
     * Current buffer length.
     * @type {number}
     */
    this.len = writer.len;

    /**
     * Next state.
     * @type {State|null}
     */
    this.next = writer.states;
}

/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */
function Writer() {

    /**
     * Current length.
     * @type {number}
     */
    this.len = 0;

    /**
     * Operations head.
     * @type {Object}
     */
    this.head = new Op(noop, 0, 0);

    /**
     * Operations tail
     * @type {Object}
     */
    this.tail = this.head;

    /**
     * Linked forked states.
     * @type {Object|null}
     */
    this.states = null;

    // When a value is written, the writer calculates its byte length and puts it into a linked
    // list of operations to perform when finish() is called. This both allows us to allocate
    // buffers of the exact required size and reduces the amount of work we have to do compared
    // to first calculating over objects and then encoding over objects. In our case, the encoding
    // part is just a linked list walk calling operations with already prepared values.
}

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup() {
            return (Writer.create = function create_buffer() {
                return new BufferWriter();
            })();
        }
        /* istanbul ignore next */
        : function create_array() {
            return new Writer();
        };
};

/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */
Writer.create = create();

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */
Writer.alloc = function alloc(size) {
    return new util.Array(size);
};

// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */
if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */
Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};

function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}

function writeVarint32(val, buf, pos) {
    while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}

/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */
function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}

VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;

/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0)
                < 128       ? 1
        : value < 16384     ? 2
        : value < 2097152   ? 3
        : value < 268435456 ? 4
        :                     5,
    value)).len;
    return this;
};

/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.int32 = function write_int32(value) {
    return value < 0
        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
        : this.uint32(value);
};

/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};

function writeVarint64(val, buf, pos) {
    while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}

/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.int64 = Writer.prototype.uint64;

/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};

function writeFixed32(val, buf, pos) {
    buf[pos    ] =  val         & 255;
    buf[pos + 1] =  val >>> 8   & 255;
    buf[pos + 2] =  val >>> 16  & 255;
    buf[pos + 3] =  val >>> 24;
}

/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};

/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sfixed32 = Writer.prototype.fixed32;

/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};

/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sfixed64 = Writer.prototype.fixed64;

/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
};

/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
};

var writeBytes = util.Array.prototype.set
    ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos); // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytes_for(val, buf, pos) {
        for (var i = 0; i < val.length; ++i)
            buf[pos + i] = val[i];
    };

/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */
Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
        return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};

/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len
        ? this.uint32(len)._push(utf8.write, len, value)
        : this._push(writeByte, 1, 0);
};

/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */
Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};

/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */
Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head   = this.states.head;
        this.tail   = this.states.tail;
        this.len    = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len  = 0;
    }
    return this;
};

/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */
Writer.prototype.ldelim = function ldelim() {
    var head = this.head,
        tail = this.tail,
        len  = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};

/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */
Writer.prototype.finish = function finish() {
    var head = this.head.next, // skip noop
        buf  = this.constructor.alloc(this.len),
        pos  = 0;
    while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};

Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
    Writer.create = create();
    BufferWriter._configure();
};

}, map: {"./util/minimal":"node_modules/protobufjs/src/util/minimal.js"} },
'node_modules/protobufjs/src/util/minimal.js': { factory: function(module, exports, require) {
"use strict";
var util = exports;

// used to return a Promise where callback is omitted
util.asPromise = require("@protobufjs/aspromise");

// converts to / from base64 encoded strings
util.base64 = require("@protobufjs/base64");

// base class of rpc.Service
util.EventEmitter = require("@protobufjs/eventemitter");

// float handling accross browsers
util.float = require("@protobufjs/float");

// requires modules optionally and hides the call from bundlers
util.inquire = require("@protobufjs/inquire");

// converts to / from utf8 encoded strings
util.utf8 = require("@protobufjs/utf8");

// provides a node-like buffer pool in the browser
util.pool = require("@protobufjs/pool");

// utility to work with the low and high bits of a 64 bit value
util.LongBits = require("./longbits");

/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 */
util.isNode = Boolean(typeof global !== "undefined"
                   && global
                   && global.process
                   && global.process.versions
                   && global.process.versions.node);

/**
 * Global object reference.
 * @memberof util
 * @type {Object}
 */
util.global = util.isNode && global
           || typeof window !== "undefined" && window
           || typeof self   !== "undefined" && self
           || this; // eslint-disable-line no-invalid-this

/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */
util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */
util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */
util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};

/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */
util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};

/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */
util.isObject = function isObject(value) {
    return value && typeof value === "object";
};

/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isset =

/**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};

/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */

/**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */
util.Buffer = (function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */
        return null;
    }
})();

// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;

// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;

/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */
util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */
    return typeof sizeOrArray === "number"
        ? util.Buffer
            ? util._Buffer_allocUnsafe(sizeOrArray)
            : new util.Array(sizeOrArray)
        : util.Buffer
            ? util._Buffer_from(sizeOrArray)
            : typeof Uint8Array === "undefined"
                ? sizeOrArray
                : new Uint8Array(sizeOrArray);
};

/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */
util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */

/**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */
util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
         || /* istanbul ignore next */ util.global.Long
         || util.inquire("long");

/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */
util.key2Re = /^true|false|0|1$/;

/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */
util.longToHash = function longToHash(value) {
    return value
        ? util.LongBits.from(value).toHash()
        : util.LongBits.zeroHash;
};

/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */
util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};

/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */
function merge(dst, src, ifNotSet) { // used by converters
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
    return dst;
}

util.merge = merge;

/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};

/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */
function newError(name) {

    function CustomError(message, properties) {

        if (!(this instanceof CustomError))
            return new CustomError(message, properties);

        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function

        Object.defineProperty(this, "message", { get: function() { return message; } });

        /* istanbul ignore next */
        if (Error.captureStackTrace) // node
            Error.captureStackTrace(this, CustomError);
        else
            Object.defineProperty(this, "stack", { value: new Error().stack || "" });

        if (properties)
            merge(this, properties);
    }

    CustomError.prototype = Object.create(Error.prototype, {
        constructor: {
            value: CustomError,
            writable: true,
            enumerable: false,
            configurable: true,
        },
        name: {
            get: function get() { return name; },
            set: undefined,
            enumerable: false,
            // configurable: false would accurately preserve the behavior of
            // the original, but I'm guessing that was not intentional.
            // For an actual error subclass, this property would
            // be configurable.
            configurable: true,
        },
        toString: {
            value: function value() { return this.name + ": " + this.message; },
            writable: true,
            enumerable: false,
            configurable: true,
        },
    });

    return CustomError;
}

util.newError = newError;

/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */
util.ProtocolError = newError("ProtocolError");

/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */

/**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */

/**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */
util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;

    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */
    return function() { // eslint-disable-line consistent-return
        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
                return keys[i];
    };
};

/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */

/**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */
util.oneOfSetter = function setOneOf(fieldNames) {

    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */
    return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name)
                delete this[fieldNames[i]];
    };
};

/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */
util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};

// Sets up buffer utility according to the environment (called in index-minimal)
util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */
    if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
        /* istanbul ignore next */
        function Buffer_from(value, encoding) {
            return new Buffer(value, encoding);
        };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
        /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
            return new Buffer(size);
        };
};

}, map: {"@protobufjs/aspromise":"node_modules/@protobufjs/aspromise/index.js","@protobufjs/base64":"node_modules/@protobufjs/base64/index.js","@protobufjs/eventemitter":"node_modules/@protobufjs/eventemitter/index.js","@protobufjs/float":"node_modules/@protobufjs/float/index.js","@protobufjs/inquire":"node_modules/@protobufjs/inquire/index.js","@protobufjs/utf8":"node_modules/@protobufjs/utf8/index.js","@protobufjs/pool":"node_modules/@protobufjs/pool/index.js","./longbits":"node_modules/protobufjs/src/util/longbits.js"} },
'node_modules/@protobufjs/aspromise/index.js': { factory: function(module, exports, require) {
"use strict";
module.exports = asPromise;

/**
 * Callback as used by {@link util.asPromise}.
 * @typedef asPromiseCallback
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {...*} params Additional arguments
 * @returns {undefined}
 */

/**
 * Returns a promise from a node-style callback function.
 * @memberof util
 * @param {asPromiseCallback} fn Function to call
 * @param {*} ctx Function context
 * @param {...*} params Function arguments
 * @returns {Promise<*>} Promisified function
 */
function asPromise(fn, ctx/*, varargs */) {
    var params  = new Array(arguments.length - 1),
        offset  = 0,
        index   = 2,
        pending = true;
    while (index < arguments.length)
        params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err/*, varargs */) {
            if (pending) {
                pending = false;
                if (err)
                    reject(err);
                else {
                    var params = new Array(arguments.length - 1),
                        offset = 0;
                    while (offset < params.length)
                        params[offset++] = arguments[offset];
                    resolve.apply(null, params);
                }
            }
        };
        try {
            fn.apply(ctx || null, params);
        } catch (err) {
            if (pending) {
                pending = false;
                reject(err);
            }
        }
    });
}

}, map: {} },
'node_modules/@protobufjs/base64/index.js': { factory: function(module, exports, require) {
"use strict";

/**
 * A minimal base64 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var base64 = exports;

/**
 * Calculates the byte length of a base64 encoded string.
 * @param {string} string Base64 encoded string
 * @returns {number} Byte length
 */
base64.length = function length(string) {
    var p = string.length;
    if (!p)
        return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
    return Math.ceil(string.length * 3) / 4 - n;
};

// Base64 encoding table
var b64 = new Array(64);

// Base64 decoding table
var s64 = new Array(123);

// 65..90, 97..122, 48..57, 43, 47
for (var i = 0; i < 64;)
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

/**
 * Encodes a buffer to a base64 encoded string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} Base64 encoded string
 */
base64.encode = function encode(buffer, start, end) {
    var parts = null,
        chunk = [];
    var i = 0, // output index
        j = 0, // goto index
        t;     // temporary
    while (start < end) {
        var b = buffer[start++];
        switch (j) {
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        }
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (j) {
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1)
            chunk[i++] = 61;
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

var invalidEncoding = "invalid encoding";

/**
 * Decodes a base64 encoded string to a buffer.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Number of bytes written
 * @throws {Error} If encoding is invalid
 */
base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, // goto index
        t;     // temporary
    for (var i = 0; i < string.length;) {
        var c = string.charCodeAt(i++);
        if (c === 61 && j > 1)
            break;
        if ((c = s64[c]) === undefined)
            throw Error(invalidEncoding);
        switch (j) {
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1)
        throw Error(invalidEncoding);
    return offset - start;
};

/**
 * Tests if the specified string appears to be base64 encoded.
 * @param {string} string String to test
 * @returns {boolean} `true` if probably base64 encoded, otherwise false
 */
base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
};

}, map: {} },
'node_modules/@protobufjs/eventemitter/index.js': { factory: function(module, exports, require) {
"use strict";
module.exports = EventEmitter;

/**
 * Constructs a new event emitter instance.
 * @classdesc A minimal event emitter.
 * @memberof util
 * @constructor
 */
function EventEmitter() {

    /**
     * Registered listeners.
     * @type {Object.<string,*>}
     * @private
     */
    this._listeners = {};
}

/**
 * Registers an event listener.
 * @param {string} evt Event name
 * @param {function} fn Listener
 * @param {*} [ctx] Listener context
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn  : fn,
        ctx : ctx || this
    });
    return this;
};

/**
 * Removes an event listener or any matching listeners if arguments are omitted.
 * @param {string} [evt] Event name. Removes all listeners if omitted.
 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === undefined)
        this._listeners = {};
    else {
        if (fn === undefined)
            this._listeners[evt] = [];
        else {
            var listeners = this._listeners[evt];
            for (var i = 0; i < listeners.length;)
                if (listeners[i].fn === fn)
                    listeners.splice(i, 1);
                else
                    ++i;
        }
    }
    return this;
};

/**
 * Emits an event by calling its listeners with the specified arguments.
 * @param {string} evt Event name
 * @param {...*} args Arguments
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
        var args = [],
            i = 1;
        for (; i < arguments.length;)
            args.push(arguments[i++]);
        for (i = 0; i < listeners.length;)
            listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
};

}, map: {} },
'node_modules/@protobufjs/float/index.js': { factory: function(module, exports, require) {
"use strict";

module.exports = factory(factory);

/**
 * Reads / writes floats / doubles from / to buffers.
 * @name util.float
 * @namespace
 */

/**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @name util.float.writeFloatLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @name util.float.writeFloatBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @name util.float.readFloatLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @name util.float.readFloatBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @name util.float.writeDoubleLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @name util.float.writeDoubleBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @name util.float.readDoubleLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @name util.float.readDoubleBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

// Factory function for the purpose of node-based testing in modified global environments
function factory(exports) {

    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {

        var f32 = new Float32Array([ -0 ]),
            f8b = new Uint8Array(f32.buffer),
            le  = f8b[3] === 128;

        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }

        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */
        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }

        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos    ];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }

        /* istanbul ignore next */
        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */
        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

    // float: ieee754
    })(); else (function() {

        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0)
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val))
                writeUint(2143289344, buf, pos);
            else if (val > 3.4028234663852886e+38) // +-Infinity
                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 1.1754943508222875e-38) // denormal
                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2),
                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
        }

        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos),
                sign = (uint >> 31) * 2 + 1,
                exponent = uint >>> 23 & 255,
                mantissa = uint & 8388607;
            return exponent === 255
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 1.401298464324817e-45 * mantissa
                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }

        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

    })();

    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {

        var f64 = new Float64Array([-0]),
            f8b = new Uint8Array(f64.buffer),
            le  = f8b[7] === 128;

        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
        }

        function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        /* istanbul ignore next */
        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

        function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
        }

        function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos    ];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
        }

        /* istanbul ignore next */
        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        /* istanbul ignore next */
        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

    // double: ieee754
    })(); else (function() {

        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
            } else if (val > 1.7976931348623157e+308) { // +-Infinity
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
                var mantissa;
                if (val < 2.2250738585072014e-308) { // denormal
                    mantissa = val / 5e-324;
                    writeUint(mantissa >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                    var exponent = Math.floor(Math.log(val) / Math.LN2);
                    if (exponent === 1024)
                        exponent = 1023;
                    mantissa = val * Math.pow(2, -exponent);
                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
            }
        }

        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0),
                hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1,
                exponent = hi >>> 20 & 2047,
                mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 5e-324 * mantissa
                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }

        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

    })();

    return exports;
}

// uint helpers

function writeUintLE(val, buf, pos) {
    buf[pos    ] =  val        & 255;
    buf[pos + 1] =  val >>> 8  & 255;
    buf[pos + 2] =  val >>> 16 & 255;
    buf[pos + 3] =  val >>> 24;
}

function writeUintBE(val, buf, pos) {
    buf[pos    ] =  val >>> 24;
    buf[pos + 1] =  val >>> 16 & 255;
    buf[pos + 2] =  val >>> 8  & 255;
    buf[pos + 3] =  val        & 255;
}

function readUintLE(buf, pos) {
    return (buf[pos    ]
          | buf[pos + 1] << 8
          | buf[pos + 2] << 16
          | buf[pos + 3] << 24) >>> 0;
}

function readUintBE(buf, pos) {
    return (buf[pos    ] << 24
          | buf[pos + 1] << 16
          | buf[pos + 2] << 8
          | buf[pos + 3]) >>> 0;
}

}, map: {} },
'node_modules/@protobufjs/inquire/index.js': { factory: function(module, exports, require) {
"use strict";
module.exports = inquire;

/**
 * Requires a module only if available.
 * @memberof util
 * @param {string} moduleName Module to require
 * @returns {?Object} Required module if available and not empty, otherwise `null`
 */
function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
        if (mod && (mod.length || Object.keys(mod).length))
            return mod;
    } catch (e) {} // eslint-disable-line no-empty
    return null;
}

}, map: {} },
'node_modules/@protobufjs/utf8/index.js': { factory: function(module, exports, require) {
"use strict";

/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var utf8 = exports;

/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */
utf8.length = function utf8_length(string) {
    var len = 0,
        c = 0;
    for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
            len += 1;
        else if (c < 2048)
            len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else
            len += 3;
    }
    return len;
};

/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */
utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1)
        return "";
    var parts = null,
        chunk = [],
        i = 0, // char offset
        t;     // temporary
    while (start < end) {
        t = buffer[start++];
        if (t < 128)
            chunk[i++] = t;
        else if (t > 191 && t < 224)
            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        } else
            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */
utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset,
        c1, // character 1
        c2; // character 2
    for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
            buffer[offset++] = c1;
        } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6       | 192;
            buffer[offset++] = c1       & 63 | 128;
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18      | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12      | 224;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        }
    }
    return offset - start;
};

}, map: {} },
'node_modules/@protobufjs/pool/index.js': { factory: function(module, exports, require) {
"use strict";
module.exports = pool;

/**
 * An allocator as used by {@link util.pool}.
 * @typedef PoolAllocator
 * @type {function}
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */

/**
 * A slicer as used by {@link util.pool}.
 * @typedef PoolSlicer
 * @type {function}
 * @param {number} start Start offset
 * @param {number} end End offset
 * @returns {Uint8Array} Buffer slice
 * @this {Uint8Array}
 */

/**
 * A general purpose buffer pool.
 * @memberof util
 * @function
 * @param {PoolAllocator} alloc Allocator
 * @param {PoolSlicer} slice Slicer
 * @param {number} [size=8192] Slab size
 * @returns {PoolAllocator} Pooled allocator
 */
function pool(alloc, slice, size) {
    var SIZE   = size || 8192;
    var MAX    = SIZE >>> 1;
    var slab   = null;
    var offset = SIZE;
    return function pool_alloc(size) {
        if (size < 1 || size > MAX)
            return alloc(size);
        if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size);
        if (offset & 7) // align to 32 bit
            offset = (offset | 7) + 1;
        return buf;
    };
}

}, map: {} },
'node_modules/protobufjs/src/util/longbits.js': { factory: function(module, exports, require) {
"use strict";
module.exports = LongBits;

var util = require("../util/minimal");

/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */
function LongBits(lo, hi) {

    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.

    /**
     * Low bits.
     * @type {number}
     */
    this.lo = lo >>> 0;

    /**
     * High bits.
     * @type {number}
     */
    this.hi = hi >>> 0;
}

/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */
var zero = LongBits.zero = new LongBits(0, 0);

zero.toNumber = function() { return 0; };
zero.zzEncode = zero.zzDecode = function() { return this; };
zero.length = function() { return 1; };

/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */
var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
        return zero;
    var sign = value < 0;
    if (sign)
        value = -value;
    var lo = value >>> 0,
        hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
                hi = 0;
        }
    }
    return new LongBits(lo, hi);
};

/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.from = function from(value) {
    if (typeof value === "number")
        return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */
        if (util.Long)
            value = util.Long.fromString(value);
        else
            return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};

/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */
LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0,
            hi = ~this.hi     >>> 0;
        if (!lo)
            hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};

/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */
LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long
        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
        /* istanbul ignore next */
        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
};

var charCodeAt = String.prototype.charCodeAt;

/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */
LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
        return zero;
    return new LongBits(
        ( charCodeAt.call(hash, 0)
        | charCodeAt.call(hash, 1) << 8
        | charCodeAt.call(hash, 2) << 16
        | charCodeAt.call(hash, 3) << 24) >>> 0
    ,
        ( charCodeAt.call(hash, 4)
        | charCodeAt.call(hash, 5) << 8
        | charCodeAt.call(hash, 6) << 16
        | charCodeAt.call(hash, 7) << 24) >>> 0
    );
};

/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */
LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(
        this.lo        & 255,
        this.lo >>> 8  & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24      ,
        this.hi        & 255,
        this.hi >>> 8  & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
    );
};

/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzEncode = function zzEncode() {
    var mask =   this.hi >> 31;
    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
    return this;
};

/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
    return this;
};

/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */
LongBits.prototype.length = function length() {
    var part0 =  this.lo,
        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
        part2 =  this.hi >>> 24;
    return part2 === 0
         ? part1 === 0
           ? part0 < 16384
             ? part0 < 128 ? 1 : 2
             : part0 < 2097152 ? 3 : 4
           : part1 < 16384
             ? part1 < 128 ? 5 : 6
             : part1 < 2097152 ? 7 : 8
         : part2 < 128 ? 9 : 10;
};

}, map: {"../util/minimal":"node_modules/protobufjs/src/util/minimal.js"} },
'node_modules/protobufjs/src/writer_buffer.js': { factory: function(module, exports, require) {
"use strict";
module.exports = BufferWriter;

// extends Writer
var Writer = require("./writer");
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

var util = require("./util/minimal");

/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */
function BufferWriter() {
    Writer.call(this);
}

BufferWriter._configure = function () {
    /**
     * Allocates a buffer of the specified size.
     * @function
     * @param {number} size Buffer size
     * @returns {Buffer} Buffer
     */
    BufferWriter.alloc = util._Buffer_allocUnsafe;

    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set"
        ? function writeBytesBuffer_set(val, buf, pos) {
          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
          // also works for plain array values
        }
        /* istanbul ignore next */
        : function writeBytesBuffer_copy(val, buf, pos) {
          if (val.copy) // Buffer values
            val.copy(buf, pos, 0, val.length);
          else for (var i = 0; i < val.length;) // plain array values
            buf[pos++] = val[i++];
        };
};


/**
 * @override
 */
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value))
        value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
    return this;
};

function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
        util.utf8.write(val, buf, pos);
    else if (buf.utf8Write)
        buf.utf8Write(val, pos);
    else
        buf.write(val, pos);
}

/**
 * @override
 */
BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = util.Buffer.byteLength(value);
    this.uint32(len);
    if (len)
        this._push(writeStringBuffer, len, value);
    return this;
};


/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */

BufferWriter._configure();

}, map: {"./writer":"node_modules/protobufjs/src/writer.js","./util/minimal":"node_modules/protobufjs/src/util/minimal.js"} },
'node_modules/protobufjs/src/reader.js': { factory: function(module, exports, require) {
"use strict";
module.exports = Reader;

var util      = require("./util/minimal");

var BufferReader; // cyclic

var LongBits  = util.LongBits,
    utf8      = util.utf8;

/* istanbul ignore next */
function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}

/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */
function Reader(buffer) {

    /**
     * Read buffer.
     * @type {Uint8Array}
     */
    this.buf = buffer;

    /**
     * Read buffer position.
     * @type {number}
     */
    this.pos = 0;

    /**
     * Read buffer length.
     * @type {number}
     */
    this.len = buffer.length;
}

var create_array = typeof Uint8Array !== "undefined"
    ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    }
    /* istanbul ignore next */
    : function create_array(buffer) {
        if (Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    };

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup(buffer) {
            return (Reader.create = function create_buffer(buffer) {
                return util.Buffer.isBuffer(buffer)
                    ? new BufferReader(buffer)
                    /* istanbul ignore next */
                    : create_array(buffer);
            })(buffer);
        }
        /* istanbul ignore next */
        : create_array;
};

/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */
Reader.create = create();

Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.uint32 = (function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

        /* istanbul ignore if */
        if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
})();

/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};

/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};

/* eslint-disable no-invalid-this */

function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) { // fast route (lo)
        for (; i < 4; ++i) {
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
        if (this.buf[this.pos++] < 128)
            return bits;
        i = 0;
    } else {
        for (; i < 3; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) { // fast route (hi)
        for (; i < 5; ++i) {
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    } else {
        for (; i < 5; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    }
    /* istanbul ignore next */
    throw Error("invalid varint encoding");
}

/* eslint-enable no-invalid-this */

/**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */
Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};

function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
    return (buf[end - 4]
          | buf[end - 3] << 8
          | buf[end - 2] << 16
          | buf[end - 1] << 24) >>> 0;
}

/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.fixed32 = function read_fixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4);
};

/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.sfixed32 = function read_sfixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4) | 0;
};

/* eslint-disable no-invalid-this */

function readFixed64(/* this: Reader */) {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);

    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}

/* eslint-enable no-invalid-this */

/**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.float = function read_float() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};

/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.double = function read_double() {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */
Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(),
        start  = this.pos,
        end    = this.pos + length;

    /* istanbul ignore if */
    if (end > this.len)
        throw indexOutOfRange(this, length);

    this.pos += length;
    if (Array.isArray(this.buf)) // plain array
        return this.buf.slice(start, end);

    if (start === end) { // fix for IE 10/Win8 and others' subarray returning array of size 1
        var nativeBuffer = util.Buffer;
        return nativeBuffer
            ? nativeBuffer.alloc(0)
            : new this.buf.constructor(0);
    }
    return this._slice.call(this.buf, start, end);
};

/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */
Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};

/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */
Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */
        if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
    }
    return this;
};

/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */
Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
                this.skipType(wireType);
            }
            break;
        case 5:
            this.skip(4);
            break;

        /* istanbul ignore next */
        default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};

Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;
    Reader.create = create();
    BufferReader._configure();

    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {

        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },

        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },

        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },

        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },

        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }

    });
};

}, map: {"./util/minimal":"node_modules/protobufjs/src/util/minimal.js"} },
'node_modules/protobufjs/src/reader_buffer.js': { factory: function(module, exports, require) {
"use strict";
module.exports = BufferReader;

// extends Reader
var Reader = require("./reader");
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

var util = require("./util/minimal");

/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */
function BufferReader(buffer) {
    Reader.call(this, buffer);

    /**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */
}

BufferReader._configure = function () {
    /* istanbul ignore else */
    if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
};


/**
 * @override
 */
BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice
        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))
        : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */

BufferReader._configure();

}, map: {"./reader":"node_modules/protobufjs/src/reader.js","./util/minimal":"node_modules/protobufjs/src/util/minimal.js"} },
'node_modules/protobufjs/src/rpc.js': { factory: function(module, exports, require) {
"use strict";

/**
 * Streaming RPC helpers.
 * @namespace
 */
var rpc = exports;

/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */

/**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */

rpc.Service = require("./rpc/service");

}, map: {"./rpc/service":"node_modules/protobufjs/src/rpc/service.js"} },
'node_modules/protobufjs/src/rpc/service.js': { factory: function(module, exports, require) {
"use strict";
module.exports = Service;

var util = require("../util/minimal");

// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */

/**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */

/**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */
function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}

/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

    if (!request)
        throw TypeError("request must be specified");

    var self = this;
    if (!callback)
        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

    if (!self.rpcImpl) {
        setTimeout(function() { callback(Error("already ended")); }, 0);
        return undefined;
    }

    try {
        return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {

                if (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }

                if (response === null) {
                    self.end(/* endedByRPC */ true);
                    return undefined;
                }

                if (!(response instanceof responseCtor)) {
                    try {
                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                    } catch (err) {
                        self.emit("error", err, method);
                        return callback(err);
                    }
                }

                self.emit("data", response, method);
                return callback(null, response);
            }
        );
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() { callback(err); }, 0);
        return undefined;
    }
};

/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */
Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) // signal end to rpcImpl
            this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};

}, map: {"../util/minimal":"node_modules/protobufjs/src/util/minimal.js"} },
'node_modules/protobufjs/src/roots.js': { factory: function(module, exports, require) {
"use strict";
module.exports = {};

/**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available across modules.
 * @name roots
 * @type {Object.<string,Root>}
 * @example
 * // pbjs -r myroot -o compiled.js ...
 *
 * // in another module:
 * require("./compiled.js");
 *
 * // in any subsequent module:
 * var root = protobuf.roots["myroot"];
 */

}, map: {} },
'build/ts/proto/prpc.js': { factory: function(module, exports, require) {
/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";
var $protobuf = require("protobufjs/minimal");
// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
$root.prpc = (function () {
    /**
     * Namespace prpc.
     * @exports prpc
     * @namespace
     */
    var prpc = {};
    prpc.PrpcError = (function () {
        /**
         * Properties of a PrpcError.
         * @memberof prpc
         * @interface IPrpcError
         * @property {string|null} [message] PrpcError message
         */
        /**
         * Constructs a new PrpcError.
         * @memberof prpc
         * @classdesc RPC error payload returned by prpc endpoints.
         * @implements IPrpcError
         * @constructor
         * @param {prpc.IPrpcError=} [properties] Properties to set
         */
        function PrpcError(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * PrpcError message.
         * @member {string} message
         * @memberof prpc.PrpcError
         * @instance
         */
        PrpcError.prototype.message = "";
        /**
         * Creates a new PrpcError instance using the specified properties.
         * @function create
         * @memberof prpc.PrpcError
         * @static
         * @param {prpc.IPrpcError=} [properties] Properties to set
         * @returns {prpc.PrpcError} PrpcError instance
         */
        PrpcError.create = function create(properties) {
            return new PrpcError(properties);
        };
        /**
         * Encodes the specified PrpcError message. Does not implicitly {@link prpc.PrpcError.verify|verify} messages.
         * @function encode
         * @memberof prpc.PrpcError
         * @static
         * @param {prpc.IPrpcError} message PrpcError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrpcError.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.message);
            return writer;
        };
        /**
         * Encodes the specified PrpcError message, length delimited. Does not implicitly {@link prpc.PrpcError.verify|verify} messages.
         * @function encodeDelimited
         * @memberof prpc.PrpcError
         * @static
         * @param {prpc.IPrpcError} message PrpcError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrpcError.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a PrpcError message from the specified reader or buffer.
         * @function decode
         * @memberof prpc.PrpcError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {prpc.PrpcError} PrpcError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrpcError.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.prpc.PrpcError();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                    case 1: {
                        message.message = reader.string();
                        break;
                    }
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a PrpcError message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof prpc.PrpcError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {prpc.PrpcError} PrpcError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrpcError.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a PrpcError message.
         * @function verify
         * @memberof prpc.PrpcError
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PrpcError.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            return null;
        };
        /**
         * Creates a PrpcError message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof prpc.PrpcError
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {prpc.PrpcError} PrpcError
         */
        PrpcError.fromObject = function fromObject(object) {
            if (object instanceof $root.prpc.PrpcError)
                return object;
            var message = new $root.prpc.PrpcError();
            if (object.message != null)
                message.message = String(object.message);
            return message;
        };
        /**
         * Creates a plain object from a PrpcError message. Also converts values to other types if specified.
         * @function toObject
         * @memberof prpc.PrpcError
         * @static
         * @param {prpc.PrpcError} message PrpcError
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PrpcError.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.message = "";
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            return object;
        };
        /**
         * Converts this PrpcError to JSON.
         * @function toJSON
         * @memberof prpc.PrpcError
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PrpcError.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * Gets the default type url for PrpcError
         * @function getTypeUrl
         * @memberof prpc.PrpcError
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PrpcError.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/prpc.PrpcError";
        };
        return PrpcError;
    })();
    return prpc;
})();
module.exports = $root;

}, map: {"protobufjs/minimal":"node_modules/protobufjs/minimal.js"} },
'build/ts/templates/app.html': { factory: function(module, exports, require) {
module.exports = "<!--\nSPDX-FileCopyrightText: © 2025 Phala Network <dstack@phala.network>\nSPDX-License-Identifier: Apache-2.0\n-->\n\n<div class=\"console-root\">\n  <header class=\"app-header\">\n    <div class=\"header-content\">\n      <div class=\"header-left\">\n        <h1 class=\"app-title\">dstack-vmm</h1>\n        <span class=\"version-badge\">\n          v{{ version.version }}\n          <template v-if=\"version.rev\">\n            ({{ version.rev.slice(0, 14) }})\n          </template>\n        </span>\n      </div>\n      <div class=\"header-right\">\n        <button class=\"btn-primary\" @click=\"showDeployDialog()\">\n          <svg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\">\n            <path d=\"M8 3V13M3 8H13\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\"/>\n          </svg>\n          Deploy Instance\n        </button>\n        <div class=\"system-menu\">\n          <button class=\"btn-icon system-menu-btn\" @click=\"toggleSystemMenu($event)\" title=\"System Menu\">\n            <svg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\">\n              <path d=\"M2 4h12M2 8h12M2 12h12\" stroke=\"currentColor\" stroke-width=\"1.5\" stroke-linecap=\"round\"/>\n            </svg>\n          </button>\n          <div class=\"dropdown-menu system-dropdown\" :class=\"{ 'show': systemMenu.show }\" @click.stop>\n            <button class=\"dropdown-item\" @click=\"reloadVMs(); closeSystemMenu()\">\n              <svg width=\"14\" height=\"14\" viewBox=\"0 0 14 14\" fill=\"none\">\n                <path d=\"M1 7a6 6 0 1 0 6-6M7 1v6l3 3\" stroke=\"currentColor\" stroke-width=\"1.5\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n              </svg>\n              Reload VMs\n            </button>\n            <button class=\"dropdown-item\" @click=\"openApiDocs()\">\n              <svg width=\"14\" height=\"14\" viewBox=\"0 0 14 14\" fill=\"none\">\n                <path d=\"M3 3h8v8H3z\" stroke=\"currentColor\" stroke-width=\"1.3\" stroke-linejoin=\"round\"/>\n                <path d=\"M5 5h4M5 7h4M5 9h2\" stroke=\"currentColor\" stroke-width=\"1.3\" stroke-linecap=\"round\"/>\n              </svg>\n              API Docs\n            </button>\n            <button class=\"dropdown-item\" @click=\"openLegacyUi()\">\n              <svg width=\"14\" height=\"14\" viewBox=\"0 0 14 14\" fill=\"none\">\n                <path d=\"M3 3h8v8H3z\" stroke=\"currentColor\" stroke-width=\"1.3\" stroke-linejoin=\"round\"/>\n                <path d=\"M4.5 6.5l1.5 1.5 3.5-3.5\" stroke=\"currentColor\" stroke-width=\"1.3\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n              </svg>\n              Legacy UI\n            </button>\n            <button class=\"dropdown-item\" @click=\"toggleDevMode()\">\n              <svg width=\"14\" height=\"14\" viewBox=\"0 0 14 14\" fill=\"none\">\n                <path d=\"M7 2v3M7 9v3M4 7H2M12 7h-2\" stroke=\"currentColor\" stroke-width=\"1.3\" stroke-linecap=\"round\"/>\n                <circle cx=\"7\" cy=\"7\" r=\"2.5\" stroke=\"currentColor\" stroke-width=\"1.3\"/>\n              </svg>\n              Dev Mode: <strong>{{ devMode ? 'On' : 'Off' }}</strong>\n            </button>\n          </div>\n        </div>\n      </div>\n    </div>\n  </header>\n\n  <create-vm-dialog\n    :visible=\"showCreateDialog\"\n    :form=\"vmForm\"\n    :available-images=\"availableImages\"\n    :available-gpus=\"availableGpus\"\n    :allow-attach-all-gpus=\"allowAttachAllGpus\"\n    :kms-available=\"vmForm.kms_enabled\"\n    :port-mapping-enabled=\"config.portMappingEnabled\"\n    @close=\"showCreateDialog = false\"\n    @submit=\"createVm\"\n    @load-compose=\"loadComposeFile\"\n  />\n\n  <update-vm-dialog\n    :visible=\"updateDialog.show\"\n    :dialog=\"updateDialog\"\n    :available-images=\"availableImages\"\n    :available-gpus=\"availableGpus\"\n    :allow-attach-all-gpus=\"allowAttachAllGpus\"\n    :port-mapping-enabled=\"config.portMappingEnabled\"\n    :kms-enabled=\"kmsEnabled(updateDialog.vm || {})\"\n    :compose-hash-preview=\"updateComposeHashPreview\"\n    @close=\"updateDialog.show = false\"\n    @submit=\"updateVM\"\n    @load-compose=\"loadUpdateFile\"\n  />\n\n  <fork-vm-dialog\n    :visible=\"cloneConfigDialog.show\"\n    :dialog=\"cloneConfigDialog\"\n    :available-images=\"availableImages\"\n    @close=\"cloneConfigDialog.show = false\"\n    @submit=\"cloneConfig\"\n  />\n\n  <div class=\"toolbar\">\n    <div class=\"toolbar-section\">\n      <div class=\"search-box\">\n        <svg class=\"search-icon\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\">\n          <circle cx=\"7\" cy=\"7\" r=\"5\" stroke=\"currentColor\" stroke-width=\"1.5\"/>\n          <path d=\"M11 11L14 14\" stroke=\"currentColor\" stroke-width=\"1.5\" stroke-linecap=\"round\"/>\n        </svg>\n        <input type=\"text\" v-model=\"searchQuery\" placeholder=\"Search instances...\" @keyup.enter=\"loadVMList()\">\n        <button class=\"btn-search\" @click=\"loadVMList()\">Search</button>\n      </div>\n      <div class=\"vm-count\">\n        <span class=\"count-label\">Total Instances:</span>\n        <span class=\"count-value\">{{ totalVMs }}</span>\n      </div>\n    </div>\n    <div class=\"toolbar-section\">\n      <div class=\"pagination-controls\">\n        <button class=\"btn-pagination\" @click=\"prevPage()\" :disabled=\"currentPage === 1\">\n          <svg width=\"14\" height=\"14\" viewBox=\"0 0 14 14\" fill=\"none\">\n            <path d=\"M9 3L5 7L9 11\" stroke=\"currentColor\" stroke-width=\"1.5\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n          </svg>\n        </button>\n        <div class=\"page-display\">\n          <input type=\"number\" v-model.number=\"pageInput\" min=\"1\" :max=\"maxPage\" @keyup.enter=\"goToPage()\" class=\"page-input\">\n          <span class=\"page-separator\">/</span>\n          <span class=\"page-total\">{{ maxPage || 1 }}</span>\n        </div>\n        <button class=\"btn-pagination\" @click=\"nextPage()\" :disabled=\"!hasMorePages\">\n          <svg width=\"14\" height=\"14\" viewBox=\"0 0 14 14\" fill=\"none\">\n            <path d=\"M5 3L9 7L5 11\" stroke=\"currentColor\" stroke-width=\"1.5\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n          </svg>\n        </button>\n        <select v-model=\"pageSize\" @change=\"onPageSizeChange()\" class=\"page-size-select\">\n          <option :value=\"10\">10 / page</option>\n          <option :value=\"25\">25 / page</option>\n          <option :value=\"50\">50 / page</option>\n          <option :value=\"100\">100 / page</option>\n        </select>\n      </div>\n    </div>\n  </div>\n\n  <div class=\"vm-table\">\n    <div class=\"vm-table-header\">\n      <div class=\"vm-col-expand\"></div>\n      <div class=\"vm-col-name\">Name</div>\n      <div class=\"vm-col-status\">Status</div>\n      <div class=\"vm-col-uptime\">Uptime</div>\n      <div class=\"vm-col-view\">View</div>\n      <div class=\"vm-col-actions\">Actions</div>\n    </div>\n\n    <div v-for=\"vm in vms\" :key=\"vm.id\" class=\"vm-row\">\n      <div class=\"vm-row-main\" @click=\"toggleDetails(vm)\">\n        <div class=\"vm-col-expand\" @click.stop>\n          <button class=\"btn-expand\" @click=\"toggleDetails(vm)\" :class=\"{ expanded: expandedVMs.has(vm.id) }\">\n            <svg width=\"14\" height=\"14\" viewBox=\"0 0 14 14\" fill=\"none\">\n              <path :d=\"expandedVMs.has(vm.id) ? 'M3 9L7 5L11 9' : 'M3 5L7 9L11 5'\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n            </svg>\n          </button>\n        </div>\n        <div class=\"vm-col-name\">\n          <span class=\"vm-name\">{{ vm.name }}</span>\n        </div>\n        <div class=\"vm-col-status\">\n          <span class=\"status-badge\" :class=\"'status-' + vmStatus(vm).replace(/\\s+/g, '-')\">\n            <span class=\"status-dot\"></span>\n            {{ vmStatus(vm) }}\n          </span>\n        </div>\n        <div class=\"vm-col-uptime\">{{ vm.status !== 'stopped' ? shortUptime(vm.uptime) : '-' }}</div>\n        <div class=\"vm-col-view\" @click.stop>\n          <a class=\"view-link\" @click.prevent=\"showLogs(vm.id, 'serial')\" href=\"#\">Logs</a>\n          <a class=\"view-link\" @click.prevent=\"showLogs(vm.id, 'stderr')\" href=\"#\">Stderr</a>\n          <a class=\"view-link\" @click.prevent=\"showDashboard(vm)\" href=\"#\">Board</a>\n        </div>\n        <div class=\"vm-col-actions\" @click.stop>\n          <div class=\"dropdown\">\n            <button class=\"btn-actions\" @click=\"toggleDropdown($event, vm)\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\">\n                <circle cx=\"8\" cy=\"4\" r=\"1.5\" fill=\"currentColor\"/>\n                <circle cx=\"8\" cy=\"8\" r=\"1.5\" fill=\"currentColor\"/>\n                <circle cx=\"8\" cy=\"12\" r=\"1.5\" fill=\"currentColor\"/>\n              </svg>\n            </button>\n            <div class=\"dropdown-content\" :id=\"'dropdown-' + vm.id\">\n              <button @click=\"startVm(vm.id); closeAllDropdowns()\">\n                <svg width=\"14\" height=\"14\" viewBox=\"0 0 14 14\" fill=\"none\">\n                  <path d=\"M4 2L11 7L4 12V2Z\" fill=\"currentColor\"/>\n                </svg>\n                Start\n              </button>\n              <button @click=\"shutdownVm(vm.id); closeAllDropdowns()\">\n                <svg width=\"14\" height=\"14\" viewBox=\"0 0 14 14\" fill=\"none\">\n                  <rect x=\"3\" y=\"3\" width=\"8\" height=\"8\" fill=\"currentColor\"/>\n                </svg>\n                Shutdown\n              </button>\n              <button @click=\"stopVm(vm); closeAllDropdowns()\">\n                <svg width=\"14\" height=\"14\" viewBox=\"0 0 14 14\" fill=\"none\">\n                  <path d=\"M2 2L12 12M12 2L2 12\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\"/>\n                </svg>\n                Kill\n              </button>\n              <button @click=\"removeVm(vm); closeAllDropdowns()\">\n                <svg width=\"14\" height=\"14\" viewBox=\"0 0 14 14\" fill=\"none\">\n                  <path d=\"M5 1h4M1 3h12M11 3l-.5 8.5c-.1.8-.7 1.5-1.5 1.5H5c-.8 0-1.4-.7-1.5-1.5L3 3M5.5 5.5v5M8.5 5.5v5\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\"/>\n                </svg>\n                Remove\n              </button>\n              <button @click=\"showUpdateDialog(vm); closeAllDropdowns()\">\n                <svg width=\"14\" height=\"14\" viewBox=\"0 0 14 14\" fill=\"none\">\n                  <path d=\"M7 11V3M7 3L4 6M7 3l3 3\" stroke=\"currentColor\" stroke-width=\"1.5\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n                  <path d=\"M2 13h10\" stroke=\"currentColor\" stroke-width=\"1.5\" stroke-linecap=\"round\"/>\n                </svg>\n                Update\n              </button>\n              <button @click=\"showCloneConfig(vm); closeAllDropdowns()\">\n                <svg width=\"14\" height=\"14\" viewBox=\"0 0 14 14\" fill=\"none\">\n                  <rect x=\"4\" y=\"4\" width=\"8\" height=\"8\" rx=\"1\" stroke=\"currentColor\" stroke-width=\"1.5\"/>\n                  <path d=\"M10 2H3c-.6 0-1 .4-1 1v7\" stroke=\"currentColor\" stroke-width=\"1.5\" stroke-linecap=\"round\"/>\n                </svg>\n                Clone Config\n              </button>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <div v-if=\"expandedVMs.has(vm.id)\" class=\"vm-details\">\n        <div class=\"details-grid\">\n          <div class=\"detail-item\">\n            <span class=\"detail-label\">VM ID</span>\n            <div class=\"detail-value-with-copy\">\n              <span class=\"detail-value\" :title=\"vm.id\">{{ vm.id }}</span>\n              <button class=\"copy-btn\" @click=\"copyToClipboard(vm.id)\" title=\"Copy\">\n                <svg width=\"14\" height=\"14\" viewBox=\"0 0 14 14\" fill=\"none\">\n                  <rect x=\"4\" y=\"4\" width=\"8\" height=\"8\" rx=\"1\" stroke=\"currentColor\" stroke-width=\"1.2\"/>\n                  <path d=\"M10 2H3c-.6 0-1 .4-1 1v7\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\"/>\n                </svg>\n              </button>\n            </div>\n          </div>\n          <div class=\"detail-item\">\n            <span class=\"detail-label\">Instance ID</span>\n            <div class=\"detail-value-with-copy\" v-if=\"vm.instance_id\">\n              <span class=\"detail-value\" :title=\"vm.instance_id\">{{ vm.instance_id }}</span>\n              <button class=\"copy-btn\" @click=\"copyToClipboard(vm.instance_id)\" title=\"Copy\">\n                <svg width=\"14\" height=\"14\" viewBox=\"0 0 14 14\" fill=\"none\">\n                  <rect x=\"4\" y=\"4\" width=\"8\" height=\"8\" rx=\"1\" stroke=\"currentColor\" stroke-width=\"1.2\"/>\n                  <path d=\"M10 2H3c-.6 0-1 .4-1 1v7\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\"/>\n                </svg>\n              </button>\n            </div>\n            <span class=\"detail-value\" v-else>-</span>\n          </div>\n          <div class=\"detail-item\">\n            <span class=\"detail-label\">App ID</span>\n            <div class=\"detail-value-with-copy\" v-if=\"vm.app_id\">\n              <span class=\"detail-value\" :title=\"vm.app_id\">{{ vm.app_id }}</span>\n              <button class=\"copy-btn\" @click=\"copyToClipboard(vm.app_id)\" title=\"Copy\">\n                <svg width=\"14\" height=\"14\" viewBox=\"0 0 14 14\" fill=\"none\">\n                  <rect x=\"4\" y=\"4\" width=\"8\" height=\"8\" rx=\"1\" stroke=\"currentColor\" stroke-width=\"1.2\"/>\n                  <path d=\"M10 2H3c-.6 0-1 .4-1 1v7\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\"/>\n                </svg>\n              </button>\n            </div>\n            <span class=\"detail-value\" v-else>-</span>\n          </div>\n          <div class=\"detail-item\">\n            <span class=\"detail-label\">Image</span>\n            <span class=\"detail-value\">{{ vm.configuration?.image }}</span>\n          </div>\n          <div class=\"detail-item\">\n            <span class=\"detail-label\">vCPUs</span>\n            <span class=\"detail-value\">{{ vm.configuration?.vcpu }}</span>\n          </div>\n          <div class=\"detail-item\">\n            <span class=\"detail-label\">Memory</span>\n            <span class=\"detail-value\">{{ formatMemory(vm.configuration?.memory) }}</span>\n          </div>\n          <div class=\"detail-item\" v-if=\"vm.configuration?.swap_size\">\n            <span class=\"detail-label\">Swap</span>\n            <span class=\"detail-value\">{{ formatMemory(bytesToMB(vm.configuration.swap_size)) }}</span>\n          </div>\n          <div class=\"detail-item\">\n            <span class=\"detail-label\">Disk Size</span>\n            <span class=\"detail-value\">{{ vm.configuration?.disk_size }} GB</span>\n          </div>\n          <div class=\"detail-item\">\n            <span class=\"detail-label\">Disk Type</span>\n            <span class=\"detail-value\">{{ vm.configuration?.disk_type || 'virtio-pci' }}</span>\n          </div>\n          <div class=\"detail-item\">\n            <span class=\"detail-label\">TEE</span>\n            <span class=\"detail-value\">{{ vm.configuration?.no_tee ? 'Disabled' : 'Enabled' }}</span>\n          </div>\n          <div class=\"detail-item detail-item--gpus\" v-if=\"vm.configuration?.gpus\">\n            <span class=\"detail-label\">GPUs</span>\n            <div v-if=\"vm.configuration.gpus.attach_mode === 'all'\" class=\"gpu-chip-list\">\n              <span class=\"gpu-chip gpu-chip--all\" title=\"All available GPUs and NVSwitches are attached\">\n                All GPUs\n              </span>\n            </div>\n            <div v-else-if=\"vm.configuration.gpus?.gpus?.length\" class=\"gpu-chip-list\">\n              <span\n                class=\"gpu-chip\"\n                v-for=\"(gpu, index) in vm.configuration.gpus.gpus\"\n                :key=\"gpu.slot || gpu.product_id || index\"\n                :title=\"gpu.description || gpu.slot || gpu.product_id || ('GPU #' + (index + 1))\"\n              >\n                {{ gpu.slot || gpu.product_id || ('GPU #' + (index + 1)) }}\n              </span>\n            </div>\n            <div v-else class=\"detail-value\">\n              None\n            </div>\n          </div>\n        </div>\n\n        <div v-if=\"vm.configuration?.ports?.length\" class=\"port-mappings\">\n          <h4>Port Mappings</h4>\n          <div v-for=\"(port, index) in vm.configuration.ports\" :key=\"index\" class=\"port-item\">\n            <span>{{ port.host_address === '127.0.0.1' ? 'Local' : 'Public' }}</span>\n            <span>{{ port.protocol.toUpperCase() }}: {{ port.host_port }} → {{ port.vm_port }}</span>\n          </div>\n        </div>\n\n        <div class=\"features-section\">\n          <h4>Features</h4>\n          <span class=\"features-text\">{{ getVmFeatures(vm) }}</span>\n        </div>\n\n        <div v-if=\"networkInfo[vm.id]\" class=\"network-section\">\n          <h4 class=\"section-title\">Network Interfaces</h4>\n          <div class=\"network-interfaces\">\n            <div v-for=\"iface in networkInfo[vm.id].interfaces\" :key=\"iface.name\" class=\"network-interface-card\">\n              <div class=\"interface-header\">\n                <div class=\"interface-name\">\n                  <svg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\">\n                    <rect x=\"2\" y=\"3\" width=\"12\" height=\"10\" rx=\"1\" stroke=\"currentColor\" stroke-width=\"1.5\"/>\n                    <path d=\"M2 6h12M5 3v3M11 3v3\" stroke=\"currentColor\" stroke-width=\"1.5\"/>\n                  </svg>\n                  <span>{{ iface.name }}</span>\n                </div>\n              </div>\n              <div class=\"interface-details\">\n                <div class=\"interface-detail-row\">\n                  <span class=\"detail-label\">MAC Address</span>\n                  <span class=\"detail-value\">{{ iface.mac || '-' }}</span>\n                </div>\n                <div class=\"interface-detail-row\">\n                  <span class=\"detail-label\">IP Address</span>\n                  <span class=\"detail-value\">{{ iface.addresses.map(addr => addr.address + '/' + addr.prefix).join(', ') || '-' }}</span>\n                </div>\n                <div class=\"interface-stats\">\n                  <div class=\"stat-item\">\n                    <div class=\"stat-icon rx\">\n                      <svg width=\"12\" height=\"12\" viewBox=\"0 0 12 12\" fill=\"none\">\n                        <path d=\"M6 2v8M3 7l3 3 3-3\" stroke=\"currentColor\" stroke-width=\"1.5\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n                      </svg>\n                    </div>\n                    <div class=\"stat-content\">\n                      <span class=\"stat-label\">RX</span>\n                      <span class=\"stat-value\">{{ iface.rx_bytes }} bytes</span>\n                      <span class=\"stat-errors\" v-if=\"iface.rx_errors > 0\">({{ iface.rx_errors }} errors)</span>\n                    </div>\n                  </div>\n                  <div class=\"stat-item\">\n                    <div class=\"stat-icon tx\">\n                      <svg width=\"12\" height=\"12\" viewBox=\"0 0 12 12\" fill=\"none\">\n                        <path d=\"M6 10V2M3 5l3-3 3 3\" stroke=\"currentColor\" stroke-width=\"1.5\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n                      </svg>\n                    </div>\n                    <div class=\"stat-content\">\n                      <span class=\"stat-label\">TX</span>\n                      <span class=\"stat-value\">{{ iface.tx_bytes }} bytes</span>\n                      <span class=\"stat-errors\" v-if=\"iface.tx_errors > 0\">({{ iface.tx_errors }} errors)</span>\n                    </div>\n                  </div>\n                </div>\n              </div>\n            </div>\n          </div>\n          <div v-if=\"networkInfo[vm.id].wg_info\" class=\"wireguard-section\">\n            <h4 class=\"section-title\">\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\">\n                <circle cx=\"8\" cy=\"8\" r=\"6\" stroke=\"currentColor\" stroke-width=\"1.5\"/>\n                <path d=\"M8 5v3l2 2\" stroke=\"currentColor\" stroke-width=\"1.5\" stroke-linecap=\"round\"/>\n              </svg>\n              WireGuard Info\n            </h4>\n            <pre class=\"wireguard-info-text\">{{ networkInfo[vm.id].wg_info }}</pre>\n          </div>\n        </div>\n\n        <div v-if=\"vm.configuration?.compose_file\" class=\"compose-section\">\n          <div class=\"section-header\">\n            <h4>App Compose</h4>\n            <div class=\"section-actions\">\n              <button class=\"copy-btn-small\" @click=\"copyToClipboard(vm.appCompose?.docker_compose_file || '')\" title=\"Copy Docker Compose\">\n                <svg width=\"14\" height=\"14\" viewBox=\"0 0 14 14\" fill=\"none\">\n                  <rect x=\"4\" y=\"4\" width=\"8\" height=\"8\" rx=\"1\" stroke=\"currentColor\" stroke-width=\"1.2\"/>\n                  <path d=\"M10 2H3c-.6 0-1 .4-1 1v7\" stroke=\"currentColor\" stroke-width=\"1.2\" stroke-linecap=\"round\"/>\n                </svg>\n              </button>\n              <button class=\"action-btn\" @click=\"downloadAppCompose(vm)\">\n                <svg width=\"14\" height=\"14\" viewBox=\"0 0 14 14\" fill=\"none\">\n                  <path d=\"M7 2v8M7 10l3-3M7 10L4 7\" stroke=\"currentColor\" stroke-width=\"1.5\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n                  <path d=\"M2 12h10\" stroke=\"currentColor\" stroke-width=\"1.5\" stroke-linecap=\"round\"/>\n                </svg>\n                Download\n              </button>\n            </div>\n          </div>\n          <div class=\"compose-content\">\n            <pre>{{ vm.appCompose?.docker_compose_file || 'Docker Compose content not available' }}</pre>\n          </div>\n        </div>\n\n        <div v-if=\"vm.configuration?.user_config\" class=\"user-config-section\">\n          <div class=\"section-header\">\n            <h4>User Config</h4>\n            <button class=\"action-btn\" @click=\"downloadUserConfig(vm)\">\n              <svg width=\"14\" height=\"14\" viewBox=\"0 0 14 14\" fill=\"none\">\n                <path d=\"M7 2v8M7 10l3-3M7 10L4 7\" stroke=\"currentColor\" stroke-width=\"1.5\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n                <path d=\"M2 12h10\" stroke=\"currentColor\" stroke-width=\"1.5\" stroke-linecap=\"round\"/>\n              </svg>\n              Download\n            </button>\n          </div>\n          <pre class=\"user-config-content\">{{ vm.configuration.user_config }}</pre>\n        </div>\n\n        <div class=\"vm-log-tabs\">\n          <button class=\"vm-log-button\" @click=\"showLogs(vm.id, 'serial')\">Serial Logs</button>\n          <button class=\"vm-log-button\" @click=\"showLogs(vm.id, 'stdout')\">Stdout</button>\n          <button class=\"vm-log-button\" @click=\"showLogs(vm.id, 'stderr')\">Stderr</button>\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <div class=\"message-container\">\n    <div v-if=\"updateMessage\" class=\"message success-message\">\n      <button class=\"close-btn\" @click=\"updateMessage = ''\">×</button>\n      <div v-html=\"updateMessage\"></div>\n    </div>\n    <div v-if=\"successMessage\" class=\"message success-message\">\n      <button class=\"close-btn\" @click=\"successMessage = ''\">×</button>\n      <div v-html=\"successMessage\"></div>\n    </div>\n    <div v-if=\"errorMessage\" class=\"message error-message\">\n      {{ errorMessage }}\n      <button class=\"close-btn\" @click=\"errorMessage = ''\">×</button>\n    </div>\n  </div>\n</div>\n";
}, map: {} }
  };
  const cache = {};
  function load(id) {
    if (cache[id]) {
      return cache[id];
    }
    const entry = modules[id];
    if (!entry) {
      throw new Error('Unknown module ' + id);
    }
    const module = { exports: {} };
    cache[id] = module.exports;
    entry.factory(module, module.exports, createRequire(id));
    cache[id] = module.exports;
    return cache[id];
  }
  function createRequire(parentId) {
    return function(request) {
      const parent = modules[parentId];
      if (!parent) {
        throw new Error('Unknown parent module ' + parentId);
      }
      const resolved = parent.map && parent.map[request];
      if (!resolved) {
        throw new Error('Cannot resolve module ' + request + ' from ' + parentId);
      }
      return load(resolved);
    };
  }
  load('build/ts/main.js');
})();
</script>
</body>

</html>
