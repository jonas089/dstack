// This file is @generated by prost-build.
/// RegisterCvmRequest is the request for RegisterCvm.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct RegisterCvmRequest {
    /// The public key of the WireGuard interface of the CVM.
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub client_public_key: ::prost::alloc::string::String,
}
/// RegisterCvmResponse is the response for RegisterCvm.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct RegisterCvmResponse {
    /// WireGuard configuration
    #[prost(message, optional, tag = "1")]
    #[serde(default)]
    pub wg: ::core::option::Option<WireGuardConfig>,
    /// Agent configuration
    #[prost(message, optional, tag = "2")]
    #[serde(default)]
    pub agent: ::core::option::Option<GuestAgentConfig>,
}
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct WireGuardPeer {
    /// The wireguard peer public key.
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub pk: ::prost::alloc::string::String,
    /// The wireguard peer IP address.
    #[prost(string, tag = "2")]
    #[serde(default)]
    pub ip: ::prost::alloc::string::String,
    /// The wireguard peer endpoint.
    #[prost(string, tag = "3")]
    #[serde(default)]
    pub endpoint: ::prost::alloc::string::String,
}
/// WireGuardConfig is the configuration of the WireGuard.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct WireGuardConfig {
    /// The IP address of the CVM.
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub client_ip: ::prost::alloc::string::String,
    /// List of proxy nodes.
    #[prost(message, repeated, tag = "2")]
    #[serde(default)]
    pub servers: ::prost::alloc::vec::Vec<WireGuardPeer>,
}
/// GuestAgentConfig is the configuration of the guest agent.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GuestAgentConfig {
    /// The external port of the guest agent.
    #[prost(uint32, tag = "1")]
    #[serde(default)]
    pub external_port: u32,
    /// The in CVM port of the guest agent.
    #[prost(uint32, tag = "2")]
    #[serde(default)]
    pub internal_port: u32,
    /// The base domain of the zt-https
    #[prost(string, tag = "3")]
    #[serde(default)]
    pub domain: ::prost::alloc::string::String,
    /// The app address namespace prefix
    #[prost(string, tag = "4")]
    #[serde(default)]
    pub app_address_ns_prefix: ::prost::alloc::string::String,
}
/// StatusResponse is the response for Status.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct StatusResponse {
    /// Peer id
    #[prost(bytes = "vec", tag = "1")]
    #[serde(default)]
    pub id: ::prost::alloc::vec::Vec<u8>,
    /// My URL.
    #[prost(string, tag = "2")]
    #[serde(default)]
    pub url: ::prost::alloc::string::String,
    /// The bootnode URL.
    #[prost(string, tag = "3")]
    #[serde(default)]
    pub bootnode_url: ::prost::alloc::string::String,
    /// Number of established proxy connections.
    #[prost(uint64, tag = "4")]
    #[serde(default)]
    pub num_connections: u64,
    /// The list of proxied CVMs.
    #[prost(message, repeated, tag = "5")]
    #[serde(default)]
    pub hosts: ::prost::alloc::vec::Vec<HostInfo>,
    /// The list of proxy nodes.
    #[prost(message, repeated, tag = "6")]
    #[serde(default)]
    pub nodes: ::prost::alloc::vec::Vec<GatewayNodeInfo>,
}
/// HostInfo is the information of a host.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct HostInfo {
    /// The Instance id
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub instance_id: ::prost::alloc::string::String,
    /// The IP address of the host.
    #[prost(string, tag = "2")]
    #[serde(default)]
    pub ip: ::prost::alloc::string::String,
    /// The app id of the host.
    #[prost(string, tag = "3")]
    #[serde(default)]
    pub app_id: ::prost::alloc::string::String,
    /// The base domain of the HTTPS endpoint of the host.
    #[prost(string, tag = "4")]
    #[serde(default)]
    pub base_domain: ::prost::alloc::string::String,
    /// The external port of the host.
    #[prost(uint32, tag = "5")]
    #[serde(default)]
    pub port: u32,
    /// The latest handshake time of the host.
    #[prost(uint64, tag = "6")]
    #[serde(default)]
    pub latest_handshake: u64,
    /// The number of connections of the host.
    #[prost(uint64, tag = "7")]
    #[serde(default)]
    pub num_connections: u64,
}
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct QuotedPublicKey {
    #[prost(bytes = "vec", tag = "1")]
    #[serde(default)]
    pub public_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "2")]
    #[serde(default)]
    pub quote: ::prost::alloc::string::String,
}
/// AcmeInfoResponse is the response for AcmeInfo.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct AcmeInfoResponse {
    /// The ACME account URI.
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub account_uri: ::prost::alloc::string::String,
    /// The public key history of the certificate.
    #[prost(bytes = "vec", repeated, tag = "2")]
    #[serde(default)]
    pub hist_keys: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// The quoted public key of the certificate.
    #[prost(message, repeated, tag = "3")]
    #[serde(default)]
    pub quoted_hist_keys: ::prost::alloc::vec::Vec<QuotedPublicKey>,
    /// The quote of the ACME account URI.
    #[prost(string, tag = "4")]
    #[serde(default)]
    pub account_quote: ::prost::alloc::string::String,
    /// Active certificate
    #[prost(string, tag = "5")]
    #[serde(default)]
    pub active_cert: ::prost::alloc::string::String,
    /// The domain that serves ZT-HTTPS
    #[prost(string, tag = "6")]
    #[serde(default)]
    pub base_domain: ::prost::alloc::string::String,
}
/// Get HostInfo for associated instance id.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetInfoRequest {
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub id: ::prost::alloc::string::String,
}
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetInfoResponse {
    #[prost(bool, tag = "1")]
    #[serde(default)]
    pub found: bool,
    #[prost(message, optional, tag = "2")]
    #[serde(default)]
    pub info: ::core::option::Option<HostInfo>,
}
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetMetaResponse {
    #[prost(uint32, tag = "1")]
    #[serde(default)]
    pub registered: u32,
    #[prost(uint32, tag = "2")]
    #[serde(default)]
    pub online: u32,
}
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GatewayNodeInfo {
    /// The ID of the node.
    #[prost(bytes = "vec", tag = "1")]
    #[serde(default)]
    pub id: ::prost::alloc::vec::Vec<u8>,
    /// The RPC URL of the node.
    #[prost(string, tag = "2")]
    #[serde(default)]
    pub url: ::prost::alloc::string::String,
    /// The last seen time of the node.
    #[prost(uint64, tag = "3")]
    #[serde(default)]
    pub last_seen: u64,
    /// The wireguard peer info.
    #[prost(message, optional, tag = "4")]
    #[serde(default)]
    pub wg_peer: ::core::option::Option<WireGuardPeer>,
}
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct AppInstanceInfo {
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub app_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    #[serde(default)]
    pub instance_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    #[serde(default)]
    pub ip: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    #[serde(default)]
    pub public_key: ::prost::alloc::string::String,
    #[prost(uint64, tag = "5")]
    #[serde(default)]
    pub reg_time: u64,
    #[prost(uint64, tag = "6")]
    #[serde(default)]
    pub last_seen: u64,
    #[prost(uint64, tag = "7")]
    #[serde(default)]
    pub num_connections: u64,
}
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GatewayState {
    #[prost(message, repeated, tag = "1")]
    #[serde(default)]
    pub nodes: ::prost::alloc::vec::Vec<GatewayNodeInfo>,
    #[prost(message, repeated, tag = "2")]
    #[serde(default)]
    pub apps: ::prost::alloc::vec::Vec<AppInstanceInfo>,
}
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct InfoResponse {
    /// The base domain of the ZT-HTTPS
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub base_domain: ::prost::alloc::string::String,
    /// The external port of the ZT-HTTPS
    #[prost(uint32, tag = "2")]
    #[serde(default)]
    pub external_port: u32,
    /// The app address namespace prefix
    #[prost(string, tag = "3")]
    #[serde(default)]
    pub app_address_ns_prefix: ::prost::alloc::string::String,
}
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct RenewCertResponse {
    /// True if the certificate was renewed.
    #[prost(bool, tag = "1")]
    #[serde(default)]
    pub renewed: bool,
}
/// Generated client implementations.
pub mod gateway_client {
    #[derive(Debug)]
    pub struct GatewayClient<Client> {
        pub client: Client,
    }
    impl<Client> GatewayClient<Client>
    where
        Client: ::prpc::client::RequestClient,
    {
        pub fn new(client: Client) -> Self {
            Self { client }
        }
        /// Register a new proxied CVM.
        pub async fn register_cvm(
            &self,
            request: super::RegisterCvmRequest,
        ) -> Result<super::RegisterCvmResponse, ::prpc::client::Error> {
            self.client.request("RegisterCvm", request).await
        }
        /// List all ACME account URIs and the public key history of the certificates for the Content Addressable HTTPS.
        pub async fn acme_info(&self) -> Result<super::AcmeInfoResponse, ::prpc::client::Error> {
            let request = ();
            self.client.request("AcmeInfo", request).await
        }
        /// Merge state from other Gateway instances.
        pub async fn update_state(
            &self,
            request: super::GatewayState,
        ) -> Result<(), ::prpc::client::Error> {
            self.client.request("UpdateState", request).await
        }
        /// Get the gateway info
        pub async fn info(&self) -> Result<super::InfoResponse, ::prpc::client::Error> {
            let request = ();
            self.client.request("Info", request).await
        }
    }
}
/// Generated client implementations.
pub mod admin_client {
    #[derive(Debug)]
    pub struct AdminClient<Client> {
        pub client: Client,
    }
    impl<Client> AdminClient<Client>
    where
        Client: ::prpc::client::RequestClient,
    {
        pub fn new(client: Client) -> Self {
            Self { client }
        }
        /// Get the status of the gateway.
        pub async fn status(&self) -> Result<super::StatusResponse, ::prpc::client::Error> {
            let request = ();
            self.client.request("Status", request).await
        }
        /// Find Proxied HostInfo by instance ID
        pub async fn get_info(
            &self,
            request: super::GetInfoRequest,
        ) -> Result<super::GetInfoResponse, ::prpc::client::Error> {
            self.client.request("GetInfo", request).await
        }
        /// Exit the Gateway process.
        pub async fn exit(&self) -> Result<(), ::prpc::client::Error> {
            let request = ();
            self.client.request("Exit", request).await
        }
        /// Renew the proxy TLS certificate if certbot is enabled
        pub async fn renew_cert(&self) -> Result<super::RenewCertResponse, ::prpc::client::Error> {
            let request = ();
            self.client.request("RenewCert", request).await
        }
        /// Reload the proxy TLS certificate from files
        pub async fn reload_cert(&self) -> Result<(), ::prpc::client::Error> {
            let request = ();
            self.client.request("ReloadCert", request).await
        }
        /// Set CAA records
        pub async fn set_caa(&self) -> Result<(), ::prpc::client::Error> {
            let request = ();
            self.client.request("SetCaa", request).await
        }
        /// Summary API for inspect.
        pub async fn get_meta(&self) -> Result<super::GetMetaResponse, ::prpc::client::Error> {
            let request = ();
            self.client.request("GetMeta", request).await
        }
    }
}
/// Generated server implementations.
pub mod gateway_server {
    use alloc::vec::Vec;
    pub enum GatewayMethod {
        RegisterCvm,
        AcmeInfo,
        UpdateState,
        Info,
    }
    impl GatewayMethod {
        #[allow(clippy::should_implement_trait)]
        pub fn from_str(path: &str) -> Option<Self> {
            match path {
                "RegisterCvm" => Some(Self::RegisterCvm),
                "AcmeInfo" => Some(Self::AcmeInfo),
                "UpdateState" => Some(Self::UpdateState),
                "Info" => Some(Self::Info),
                _ => None,
            }
        }
    }
    ///Generated trait containing RPC methods that should be implemented for use with GatewayServer.
    pub trait GatewayRpc {
        /// Register a new proxied CVM.
        async fn register_cvm(
            self,
            request: super::RegisterCvmRequest,
        ) -> ::anyhow::Result<super::RegisterCvmResponse>;
        /// List all ACME account URIs and the public key history of the certificates for the Content Addressable HTTPS.
        async fn acme_info(self) -> ::anyhow::Result<super::AcmeInfoResponse>;
        /// Merge state from other Gateway instances.
        async fn update_state(self, request: super::GatewayState) -> ::anyhow::Result<()>;
        /// Get the gateway info
        async fn info(self) -> ::anyhow::Result<super::InfoResponse>;
    }
    #[derive(Debug)]
    pub struct GatewayServer<T: GatewayRpc> {
        inner: T,
    }
    impl<T: GatewayRpc> GatewayServer<T> {
        pub fn new(inner: T) -> Self {
            Self { inner }
        }
        pub async fn dispatch_request(
            self,
            path: &str,
            _data: impl AsRef<[u8]>,
        ) -> Result<Vec<u8>, ::prpc::server::Error> {
            #![allow(clippy::let_unit_value)]
            match path {
                "RegisterCvm" => {
                    let input: super::RegisterCvmRequest = ::prpc::Message::decode(_data.as_ref())?;
                    let response = self.inner.register_cvm(input).await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "AcmeInfo" => {
                    let response = self.inner.acme_info().await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "UpdateState" => {
                    let input: super::GatewayState = ::prpc::Message::decode(_data.as_ref())?;
                    let response = self.inner.update_state(input).await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "Info" => {
                    let response = self.inner.info().await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                _ => anyhow::bail!("Service not found: {path}"),
            }
        }
        pub async fn dispatch_json_request(
            self,
            path: &str,
            _data: impl AsRef<[u8]>,
            _query: bool,
        ) -> Result<Vec<u8>, ::prpc::server::Error> {
            #![allow(clippy::let_unit_value)]
            match path {
                "RegisterCvm" => {
                    let data = _data.as_ref();
                    let input: super::RegisterCvmRequest = if data.is_empty() {
                        Default::default()
                    } else if _query {
                        ::prpc::serde_qs::from_bytes(data)?
                    } else {
                        ::prpc::serde_json::from_slice(data)?
                    };
                    let response = self.inner.register_cvm(input).await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "AcmeInfo" => {
                    let response = self.inner.acme_info().await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "UpdateState" => {
                    let data = _data.as_ref();
                    let input: super::GatewayState = if data.is_empty() {
                        Default::default()
                    } else if _query {
                        ::prpc::serde_qs::from_bytes(data)?
                    } else {
                        ::prpc::serde_json::from_slice(data)?
                    };
                    let response = self.inner.update_state(input).await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "Info" => {
                    let response = self.inner.info().await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                _ => anyhow::bail!("Service not found: {path}"),
            }
        }
        pub fn supported_methods() -> &'static [&'static str] {
            &["RegisterCvm", "AcmeInfo", "UpdateState", "Info"]
        }
    }
    impl<T: GatewayRpc> ::prpc::server::NamedService for GatewayServer<T> {
        const NAME: &'static str = "Gateway";
    }
    impl<T: GatewayRpc> ::prpc::server::Service for GatewayServer<T> {
        type Methods = &'static [&'static str];
        fn methods() -> Self::Methods {
            Self::supported_methods()
        }
        async fn dispatch_request(
            self,
            path: &str,
            data: impl AsRef<[u8]>,
            json: bool,
            query: bool,
        ) -> Result<Vec<u8>, ::prpc::server::Error> {
            if json {
                self.dispatch_json_request(path, data, query).await
            } else {
                self.dispatch_request(path, data).await
            }
        }
    }
    impl<T: GatewayRpc> From<T> for GatewayServer<T> {
        fn from(inner: T) -> Self {
            Self::new(inner)
        }
    }
}
/// Generated server implementations.
pub mod admin_server {
    use alloc::vec::Vec;
    pub enum AdminMethod {
        Status,
        GetInfo,
        Exit,
        RenewCert,
        ReloadCert,
        SetCaa,
        GetMeta,
    }
    impl AdminMethod {
        #[allow(clippy::should_implement_trait)]
        pub fn from_str(path: &str) -> Option<Self> {
            match path {
                "Status" => Some(Self::Status),
                "GetInfo" => Some(Self::GetInfo),
                "Exit" => Some(Self::Exit),
                "RenewCert" => Some(Self::RenewCert),
                "ReloadCert" => Some(Self::ReloadCert),
                "SetCaa" => Some(Self::SetCaa),
                "GetMeta" => Some(Self::GetMeta),
                _ => None,
            }
        }
    }
    ///Generated trait containing RPC methods that should be implemented for use with AdminServer.
    pub trait AdminRpc {
        /// Get the status of the gateway.
        async fn status(self) -> ::anyhow::Result<super::StatusResponse>;
        /// Find Proxied HostInfo by instance ID
        async fn get_info(
            self,
            request: super::GetInfoRequest,
        ) -> ::anyhow::Result<super::GetInfoResponse>;
        /// Exit the Gateway process.
        async fn exit(self) -> ::anyhow::Result<()>;
        /// Renew the proxy TLS certificate if certbot is enabled
        async fn renew_cert(self) -> ::anyhow::Result<super::RenewCertResponse>;
        /// Reload the proxy TLS certificate from files
        async fn reload_cert(self) -> ::anyhow::Result<()>;
        /// Set CAA records
        async fn set_caa(self) -> ::anyhow::Result<()>;
        /// Summary API for inspect.
        async fn get_meta(self) -> ::anyhow::Result<super::GetMetaResponse>;
    }
    #[derive(Debug)]
    pub struct AdminServer<T: AdminRpc> {
        inner: T,
    }
    impl<T: AdminRpc> AdminServer<T> {
        pub fn new(inner: T) -> Self {
            Self { inner }
        }
        pub async fn dispatch_request(
            self,
            path: &str,
            _data: impl AsRef<[u8]>,
        ) -> Result<Vec<u8>, ::prpc::server::Error> {
            #![allow(clippy::let_unit_value)]
            match path {
                "Status" => {
                    let response = self.inner.status().await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "GetInfo" => {
                    let input: super::GetInfoRequest = ::prpc::Message::decode(_data.as_ref())?;
                    let response = self.inner.get_info(input).await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "Exit" => {
                    let response = self.inner.exit().await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "RenewCert" => {
                    let response = self.inner.renew_cert().await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "ReloadCert" => {
                    let response = self.inner.reload_cert().await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "SetCaa" => {
                    let response = self.inner.set_caa().await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "GetMeta" => {
                    let response = self.inner.get_meta().await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                _ => anyhow::bail!("Service not found: {path}"),
            }
        }
        pub async fn dispatch_json_request(
            self,
            path: &str,
            _data: impl AsRef<[u8]>,
            _query: bool,
        ) -> Result<Vec<u8>, ::prpc::server::Error> {
            #![allow(clippy::let_unit_value)]
            match path {
                "Status" => {
                    let response = self.inner.status().await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "GetInfo" => {
                    let data = _data.as_ref();
                    let input: super::GetInfoRequest = if data.is_empty() {
                        Default::default()
                    } else if _query {
                        ::prpc::serde_qs::from_bytes(data)?
                    } else {
                        ::prpc::serde_json::from_slice(data)?
                    };
                    let response = self.inner.get_info(input).await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "Exit" => {
                    let response = self.inner.exit().await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "RenewCert" => {
                    let response = self.inner.renew_cert().await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "ReloadCert" => {
                    let response = self.inner.reload_cert().await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "SetCaa" => {
                    let response = self.inner.set_caa().await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "GetMeta" => {
                    let response = self.inner.get_meta().await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                _ => anyhow::bail!("Service not found: {path}"),
            }
        }
        pub fn supported_methods() -> &'static [&'static str] {
            &[
                "Status",
                "GetInfo",
                "Exit",
                "RenewCert",
                "ReloadCert",
                "SetCaa",
                "GetMeta",
            ]
        }
    }
    impl<T: AdminRpc> ::prpc::server::NamedService for AdminServer<T> {
        const NAME: &'static str = "Admin";
    }
    impl<T: AdminRpc> ::prpc::server::Service for AdminServer<T> {
        type Methods = &'static [&'static str];
        fn methods() -> Self::Methods {
            Self::supported_methods()
        }
        async fn dispatch_request(
            self,
            path: &str,
            data: impl AsRef<[u8]>,
            json: bool,
            query: bool,
        ) -> Result<Vec<u8>, ::prpc::server::Error> {
            if json {
                self.dispatch_json_request(path, data, query).await
            } else {
                self.dispatch_request(path, data).await
            }
        }
    }
    impl<T: AdminRpc> From<T> for AdminServer<T> {
        fn from(inner: T) -> Self {
            Self::new(inner)
        }
    }
}
