// This file is @generated by prost-build.
/// The request to derive a key
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetTlsKeyArgs {
    /// Subject of the certificate to request
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub subject: ::prost::alloc::string::String,
    /// DNS alternative names for the certificate
    #[prost(string, repeated, tag = "2")]
    #[serde(default)]
    pub alt_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Includes quote in the certificate
    #[prost(bool, tag = "3")]
    #[serde(default)]
    pub usage_ra_tls: bool,
    /// Key usage server auth
    #[prost(bool, tag = "4")]
    #[serde(default)]
    pub usage_server_auth: bool,
    /// Key usage client auth
    #[prost(bool, tag = "5")]
    #[serde(default)]
    pub usage_client_auth: bool,
}
/// The request to derive a key
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct DeriveKeyArgs {
    /// Path used to derive the private key
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub path: ::prost::alloc::string::String,
    /// Bellow fields are used to generate the certificate
    /// Subject of the certificate to request
    #[prost(string, tag = "2")]
    #[serde(default)]
    pub subject: ::prost::alloc::string::String,
    /// DNS alternative names for the certificate
    #[prost(string, repeated, tag = "3")]
    #[serde(default)]
    pub alt_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Includes quote in the certificate
    #[prost(bool, tag = "4")]
    #[serde(default)]
    pub usage_ra_tls: bool,
    /// Key usage server auth
    #[prost(bool, tag = "5")]
    #[serde(default)]
    pub usage_server_auth: bool,
    /// Key usage client auth
    #[prost(bool, tag = "6")]
    #[serde(default)]
    pub usage_client_auth: bool,
    /// Derive from random seed
    #[prost(bool, tag = "7")]
    #[serde(default)]
    pub random_seed: bool,
}
/// The response to a DeriveKey request
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetTlsKeyResponse {
    /// Derived key
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub key: ::prost::alloc::string::String,
    /// Certificate chain
    #[prost(string, repeated, tag = "2")]
    #[serde(default)]
    pub certificate_chain: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// The request to derive a new key
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetKeyArgs {
    /// Path to the key to derive
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub path: ::prost::alloc::string::String,
    /// Purpose of the key
    #[prost(string, tag = "2")]
    #[serde(default)]
    pub purpose: ::prost::alloc::string::String,
    /// Algorithm of the key. Either `secp256k1` or `ed25519`. Defaults to `secp256k1`
    #[prost(string, tag = "3")]
    #[serde(default)]
    pub algorithm: ::prost::alloc::string::String,
}
/// The response to a DeriveK256Key request
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct DeriveK256KeyResponse {
    /// Derived k256 key
    #[prost(bytes = "vec", tag = "1")]
    #[serde(default)]
    pub k256_key: ::prost::alloc::vec::Vec<u8>,
    /// Derived k256 signature chain
    #[prost(bytes = "vec", repeated, tag = "2")]
    #[serde(default)]
    pub k256_signature_chain: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
/// The response to a GetEthKey request
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetKeyResponse {
    /// Derived key
    #[prost(bytes = "vec", tag = "1")]
    #[serde(default)]
    pub key: ::prost::alloc::vec::Vec<u8>,
    /// The signature chain consists of the following signatures:
    /// \[0\] - the k256 signature of the derived pK signed by the app root key
    /// \[1\] - the k256 signature of the app root pK signed by the KMS root key
    #[prost(bytes = "vec", repeated, tag = "2")]
    #[serde(default)]
    pub signature_chain: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
/// The request to get a TDX quote
/// The report data is prefixed with `app-data:` before hashing unless the algorithm is `raw`.
/// Final report data is hash(`app-data:` + report_data) if the algorithm is not `raw`.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct TdxQuoteArgs {
    /// Report data
    #[prost(bytes = "vec", tag = "1")]
    #[serde(default)]
    pub report_data: ::prost::alloc::vec::Vec<u8>,
    /// The hash algorithm to use to process the report data. Default is `sha512`.
    /// Supported algorithms are:
    /// - `sha256`
    /// - `sha384`
    /// - `sha512`
    /// - `sha3-256`
    /// - `sha3-384`
    /// - `sha3-512`
    /// - `keccak256`
    /// - `keccak384`
    /// - `keccak512`
    /// - `raw`: Passes the report_data directly to the driver without any processing
    #[prost(string, tag = "2")]
    #[serde(default)]
    pub hash_algorithm: ::prost::alloc::string::String,
    /// Custom prefix to prepend to report data before hashing.
    /// Defaults to 'app-data:' when hash_algorithm is not 'raw'.
    #[prost(string, tag = "3")]
    #[serde(default)]
    pub prefix: ::prost::alloc::string::String,
}
/// The request to get a raw TDX quote
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct RawQuoteArgs {
    /// 64 bytes of report data
    #[prost(bytes = "vec", tag = "1")]
    #[serde(default)]
    pub report_data: ::prost::alloc::vec::Vec<u8>,
}
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct TdxQuoteResponse {
    /// TDX quote
    #[prost(bytes = "vec", tag = "1")]
    #[serde(default)]
    pub quote: ::prost::alloc::vec::Vec<u8>,
    /// Event log
    #[prost(string, tag = "2")]
    #[serde(default)]
    pub event_log: ::prost::alloc::string::String,
    /// The following fields might be used for app debugging purposes
    /// Hash algorithm used to hash the caller passed in report data
    #[prost(string, tag = "3")]
    #[serde(default)]
    pub hash_algorithm: ::prost::alloc::string::String,
    /// Prefix added to the report data before hashing
    #[prost(string, tag = "4")]
    #[serde(default)]
    pub prefix: ::prost::alloc::string::String,
}
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetQuoteResponse {
    /// TDX quote
    #[prost(bytes = "vec", tag = "1")]
    #[serde(default)]
    pub quote: ::prost::alloc::vec::Vec<u8>,
    /// Event log
    #[prost(string, tag = "2")]
    #[serde(default)]
    pub event_log: ::prost::alloc::string::String,
    /// Report data
    #[prost(bytes = "vec", tag = "3")]
    #[serde(default)]
    pub report_data: ::prost::alloc::vec::Vec<u8>,
    /// Hw config
    #[prost(string, tag = "4")]
    #[serde(default)]
    pub vm_config: ::prost::alloc::string::String,
}
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct EmitEventArgs {
    /// The event name
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub event: ::prost::alloc::string::String,
    /// The event data
    #[prost(bytes = "vec", tag = "2")]
    #[serde(default)]
    pub payload: ::prost::alloc::vec::Vec<u8>,
}
/// The request to derive a key
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct AppInfo {
    /// App ID
    #[prost(bytes = "vec", tag = "1")]
    #[serde(default)]
    pub app_id: ::prost::alloc::vec::Vec<u8>,
    /// App Instance ID
    #[prost(bytes = "vec", tag = "2")]
    #[serde(default)]
    pub instance_id: ::prost::alloc::vec::Vec<u8>,
    /// App certificate
    #[prost(string, tag = "3")]
    #[serde(default)]
    pub app_cert: ::prost::alloc::string::String,
    /// TCB info
    #[prost(string, tag = "4")]
    #[serde(default)]
    pub tcb_info: ::prost::alloc::string::String,
    /// App name
    #[prost(string, tag = "5")]
    #[serde(default)]
    pub app_name: ::prost::alloc::string::String,
    /// Device ID
    #[prost(bytes = "vec", tag = "8")]
    #[serde(default)]
    pub device_id: ::prost::alloc::vec::Vec<u8>,
    /// MR Aggregated
    #[prost(bytes = "vec", tag = "9")]
    #[serde(default)]
    pub mr_aggregated: ::prost::alloc::vec::Vec<u8>,
    /// OS Image hash
    #[prost(bytes = "vec", tag = "10")]
    #[serde(default)]
    pub os_image_hash: ::prost::alloc::vec::Vec<u8>,
    /// Key provider info
    #[prost(string, tag = "12")]
    #[serde(default)]
    pub key_provider_info: ::prost::alloc::string::String,
    /// Compose hash
    #[prost(bytes = "vec", tag = "13")]
    #[serde(default)]
    pub compose_hash: ::prost::alloc::vec::Vec<u8>,
    /// VM config
    #[prost(string, tag = "14")]
    #[serde(default)]
    pub vm_config: ::prost::alloc::string::String,
}
/// The response to a Version request
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct WorkerVersion {
    /// dstack version
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub version: ::prost::alloc::string::String,
    /// Git revision
    #[prost(string, tag = "2")]
    #[serde(default)]
    pub rev: ::prost::alloc::string::String,
}
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SignRequest {
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub algorithm: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    #[serde(default)]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SignResponse {
    /// the signature of the data
    #[prost(bytes = "vec", tag = "1")]
    #[serde(default)]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The signature chain consists of the following signatures:
    /// \[0\] - the signature of the data
    /// \[1\] - the k256 signature of the message signing pubkey signed by the app root key
    /// \[2\] - the k256 signature of the app root pubkey signed by the KMS root key
    #[prost(bytes = "vec", repeated, tag = "2")]
    #[serde(default)]
    pub signature_chain: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// The public key signing the data
    #[prost(bytes = "vec", tag = "3")]
    #[serde(default)]
    pub public_key: ::prost::alloc::vec::Vec<u8>,
}
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct VerifyRequest {
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub algorithm: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    #[serde(default)]
    pub data: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    #[serde(default)]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "4")]
    #[serde(default)]
    pub public_key: ::prost::alloc::vec::Vec<u8>,
}
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct VerifyResponse {
    #[prost(bool, tag = "1")]
    #[serde(default)]
    pub valid: bool,
}
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetAttestationForAppKeyRequest {
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub algorithm: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod tappd_client {
    /// For backwards compatibility with tappd
    #[derive(Debug)]
    pub struct TappdClient<Client> {
        pub client: Client,
    }
    impl<Client> TappdClient<Client>
    where
        Client: ::prpc::client::RequestClient,
    {
        pub fn new(client: Client) -> Self {
            Self { client }
        }
        /// Derives a cryptographic key from the specified key path.
        /// Returns the derived key along with its certificate chain.
        pub async fn derive_key(
            &self,
            request: super::DeriveKeyArgs,
        ) -> Result<super::GetTlsKeyResponse, ::prpc::client::Error> {
            self.client.request("DeriveKey", request).await
        }
        /// Derives a new ECDSA key with k256 EC curve.
        pub async fn derive_k256_key(
            &self,
            request: super::GetKeyArgs,
        ) -> Result<super::DeriveK256KeyResponse, ::prpc::client::Error> {
            self.client.request("DeriveK256Key", request).await
        }
        /// Generates a TDX quote
        pub async fn tdx_quote(
            &self,
            request: super::TdxQuoteArgs,
        ) -> Result<super::TdxQuoteResponse, ::prpc::client::Error> {
            self.client.request("TdxQuote", request).await
        }
        /// Generates a TDX quote with raw report data.
        /// This is a low-level API that should be used with caution.
        /// When using quotes in multiple locations within your application,
        /// ensure proper quote differentiation by including a content type
        /// identifier in the report_data to avoid Quote Repurposing Attacks.
        pub async fn raw_quote(
            &self,
            request: super::RawQuoteArgs,
        ) -> Result<super::TdxQuoteResponse, ::prpc::client::Error> {
            self.client.request("RawQuote", request).await
        }
        /// Get app info
        pub async fn info(&self) -> Result<super::AppInfo, ::prpc::client::Error> {
            let request = ();
            self.client.request("Info", request).await
        }
    }
}
/// Generated client implementations.
pub mod dstack_guest_client {
    /// The service for the dstack guest agent
    #[derive(Debug)]
    pub struct DstackGuestClient<Client> {
        pub client: Client,
    }
    impl<Client> DstackGuestClient<Client>
    where
        Client: ::prpc::client::RequestClient,
    {
        pub fn new(client: Client) -> Self {
            Self { client }
        }
        /// Derives a cryptographic key from the specified key path.
        /// Returns the derived key along with its TLS certificate chain.
        pub async fn get_tls_key(
            &self,
            request: super::GetTlsKeyArgs,
        ) -> Result<super::GetTlsKeyResponse, ::prpc::client::Error> {
            self.client.request("GetTlsKey", request).await
        }
        /// Derives a new key.
        pub async fn get_key(
            &self,
            request: super::GetKeyArgs,
        ) -> Result<super::GetKeyResponse, ::prpc::client::Error> {
            self.client.request("GetKey", request).await
        }
        /// Generates a TDX quote with given report data.
        pub async fn get_quote(
            &self,
            request: super::RawQuoteArgs,
        ) -> Result<super::GetQuoteResponse, ::prpc::client::Error> {
            self.client.request("GetQuote", request).await
        }
        /// Emit an event. This extends the event to RTMR3 on TDX platform.
        pub async fn emit_event(
            &self,
            request: super::EmitEventArgs,
        ) -> Result<(), ::prpc::client::Error> {
            self.client.request("EmitEvent", request).await
        }
        /// Get app info
        pub async fn info(&self) -> Result<super::AppInfo, ::prpc::client::Error> {
            let request = ();
            self.client.request("Info", request).await
        }
        /// Sign a payload
        pub async fn sign(
            &self,
            request: super::SignRequest,
        ) -> Result<super::SignResponse, ::prpc::client::Error> {
            self.client.request("Sign", request).await
        }
        /// Verify a signature
        pub async fn verify(
            &self,
            request: super::VerifyRequest,
        ) -> Result<super::VerifyResponse, ::prpc::client::Error> {
            self.client.request("Verify", request).await
        }
    }
}
/// Generated client implementations.
pub mod worker_client {
    #[derive(Debug)]
    pub struct WorkerClient<Client> {
        pub client: Client,
    }
    impl<Client> WorkerClient<Client>
    where
        Client: ::prpc::client::RequestClient,
    {
        pub fn new(client: Client) -> Self {
            Self { client }
        }
        /// Get app info
        pub async fn info(&self) -> Result<super::AppInfo, ::prpc::client::Error> {
            let request = ();
            self.client.request("Info", request).await
        }
        /// Get the guest agent version
        pub async fn version(&self) -> Result<super::WorkerVersion, ::prpc::client::Error> {
            let request = ();
            self.client.request("Version", request).await
        }
        /// Get attestation
        pub async fn get_attestation_for_app_key(
            &self,
            request: super::GetAttestationForAppKeyRequest,
        ) -> Result<super::GetQuoteResponse, ::prpc::client::Error> {
            self.client
                .request("GetAttestationForAppKey", request)
                .await
        }
    }
}
/// Generated server implementations.
pub mod tappd_server {
    use alloc::vec::Vec;
    pub enum TappdMethod {
        DeriveKey,
        DeriveK256Key,
        TdxQuote,
        RawQuote,
        Info,
    }
    impl TappdMethod {
        #[allow(clippy::should_implement_trait)]
        pub fn from_str(path: &str) -> Option<Self> {
            match path {
                "DeriveKey" => Some(Self::DeriveKey),
                "DeriveK256Key" => Some(Self::DeriveK256Key),
                "TdxQuote" => Some(Self::TdxQuote),
                "RawQuote" => Some(Self::RawQuote),
                "Info" => Some(Self::Info),
                _ => None,
            }
        }
    }
    ///Generated trait containing RPC methods that should be implemented for use with TappdServer.
    pub trait TappdRpc {
        /// Derives a cryptographic key from the specified key path.
        /// Returns the derived key along with its certificate chain.
        async fn derive_key(
            self,
            request: super::DeriveKeyArgs,
        ) -> ::anyhow::Result<super::GetTlsKeyResponse>;
        /// Derives a new ECDSA key with k256 EC curve.
        async fn derive_k256_key(
            self,
            request: super::GetKeyArgs,
        ) -> ::anyhow::Result<super::DeriveK256KeyResponse>;
        /// Generates a TDX quote
        async fn tdx_quote(
            self,
            request: super::TdxQuoteArgs,
        ) -> ::anyhow::Result<super::TdxQuoteResponse>;
        /// Generates a TDX quote with raw report data.
        /// This is a low-level API that should be used with caution.
        /// When using quotes in multiple locations within your application,
        /// ensure proper quote differentiation by including a content type
        /// identifier in the report_data to avoid Quote Repurposing Attacks.
        async fn raw_quote(
            self,
            request: super::RawQuoteArgs,
        ) -> ::anyhow::Result<super::TdxQuoteResponse>;
        /// Get app info
        async fn info(self) -> ::anyhow::Result<super::AppInfo>;
    }
    /// For backwards compatibility with tappd
    #[derive(Debug)]
    pub struct TappdServer<T: TappdRpc> {
        inner: T,
    }
    impl<T: TappdRpc> TappdServer<T> {
        pub fn new(inner: T) -> Self {
            Self { inner }
        }
        pub async fn dispatch_request(
            self,
            path: &str,
            _data: impl AsRef<[u8]>,
        ) -> Result<Vec<u8>, ::prpc::server::Error> {
            #![allow(clippy::let_unit_value)]
            match path {
                "DeriveKey" => {
                    let input: super::DeriveKeyArgs = ::prpc::Message::decode(_data.as_ref())?;
                    let response = self.inner.derive_key(input).await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "DeriveK256Key" => {
                    let input: super::GetKeyArgs = ::prpc::Message::decode(_data.as_ref())?;
                    let response = self.inner.derive_k256_key(input).await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "TdxQuote" => {
                    let input: super::TdxQuoteArgs = ::prpc::Message::decode(_data.as_ref())?;
                    let response = self.inner.tdx_quote(input).await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "RawQuote" => {
                    let input: super::RawQuoteArgs = ::prpc::Message::decode(_data.as_ref())?;
                    let response = self.inner.raw_quote(input).await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "Info" => {
                    let response = self.inner.info().await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                _ => anyhow::bail!("Service not found: {path}"),
            }
        }
        pub async fn dispatch_json_request(
            self,
            path: &str,
            _data: impl AsRef<[u8]>,
            _query: bool,
        ) -> Result<Vec<u8>, ::prpc::server::Error> {
            #![allow(clippy::let_unit_value)]
            match path {
                "DeriveKey" => {
                    let data = _data.as_ref();
                    let input: super::DeriveKeyArgs = if data.is_empty() {
                        Default::default()
                    } else if _query {
                        ::prpc::serde_qs::from_bytes(data)?
                    } else {
                        ::prpc::serde_json::from_slice(data)?
                    };
                    let response = self.inner.derive_key(input).await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "DeriveK256Key" => {
                    let data = _data.as_ref();
                    let input: super::GetKeyArgs = if data.is_empty() {
                        Default::default()
                    } else if _query {
                        ::prpc::serde_qs::from_bytes(data)?
                    } else {
                        ::prpc::serde_json::from_slice(data)?
                    };
                    let response = self.inner.derive_k256_key(input).await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "TdxQuote" => {
                    let data = _data.as_ref();
                    let input: super::TdxQuoteArgs = if data.is_empty() {
                        Default::default()
                    } else if _query {
                        ::prpc::serde_qs::from_bytes(data)?
                    } else {
                        ::prpc::serde_json::from_slice(data)?
                    };
                    let response = self.inner.tdx_quote(input).await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "RawQuote" => {
                    let data = _data.as_ref();
                    let input: super::RawQuoteArgs = if data.is_empty() {
                        Default::default()
                    } else if _query {
                        ::prpc::serde_qs::from_bytes(data)?
                    } else {
                        ::prpc::serde_json::from_slice(data)?
                    };
                    let response = self.inner.raw_quote(input).await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "Info" => {
                    let response = self.inner.info().await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                _ => anyhow::bail!("Service not found: {path}"),
            }
        }
        pub fn supported_methods() -> &'static [&'static str] {
            &["DeriveKey", "DeriveK256Key", "TdxQuote", "RawQuote", "Info"]
        }
    }
    impl<T: TappdRpc> ::prpc::server::NamedService for TappdServer<T> {
        const NAME: &'static str = "Tappd";
    }
    impl<T: TappdRpc> ::prpc::server::Service for TappdServer<T> {
        type Methods = &'static [&'static str];
        fn methods() -> Self::Methods {
            Self::supported_methods()
        }
        async fn dispatch_request(
            self,
            path: &str,
            data: impl AsRef<[u8]>,
            json: bool,
            query: bool,
        ) -> Result<Vec<u8>, ::prpc::server::Error> {
            if json {
                self.dispatch_json_request(path, data, query).await
            } else {
                self.dispatch_request(path, data).await
            }
        }
    }
    impl<T: TappdRpc> From<T> for TappdServer<T> {
        fn from(inner: T) -> Self {
            Self::new(inner)
        }
    }
}
/// Generated server implementations.
pub mod dstack_guest_server {
    use alloc::vec::Vec;
    pub enum DstackGuestMethod {
        GetTlsKey,
        GetKey,
        GetQuote,
        EmitEvent,
        Info,
        Sign,
        Verify,
    }
    impl DstackGuestMethod {
        #[allow(clippy::should_implement_trait)]
        pub fn from_str(path: &str) -> Option<Self> {
            match path {
                "GetTlsKey" => Some(Self::GetTlsKey),
                "GetKey" => Some(Self::GetKey),
                "GetQuote" => Some(Self::GetQuote),
                "EmitEvent" => Some(Self::EmitEvent),
                "Info" => Some(Self::Info),
                "Sign" => Some(Self::Sign),
                "Verify" => Some(Self::Verify),
                _ => None,
            }
        }
    }
    ///Generated trait containing RPC methods that should be implemented for use with DstackGuestServer.
    pub trait DstackGuestRpc {
        /// Derives a cryptographic key from the specified key path.
        /// Returns the derived key along with its TLS certificate chain.
        async fn get_tls_key(
            self,
            request: super::GetTlsKeyArgs,
        ) -> ::anyhow::Result<super::GetTlsKeyResponse>;
        /// Derives a new key.
        async fn get_key(
            self,
            request: super::GetKeyArgs,
        ) -> ::anyhow::Result<super::GetKeyResponse>;
        /// Generates a TDX quote with given report data.
        async fn get_quote(
            self,
            request: super::RawQuoteArgs,
        ) -> ::anyhow::Result<super::GetQuoteResponse>;
        /// Emit an event. This extends the event to RTMR3 on TDX platform.
        async fn emit_event(self, request: super::EmitEventArgs) -> ::anyhow::Result<()>;
        /// Get app info
        async fn info(self) -> ::anyhow::Result<super::AppInfo>;
        /// Sign a payload
        async fn sign(self, request: super::SignRequest) -> ::anyhow::Result<super::SignResponse>;
        /// Verify a signature
        async fn verify(
            self,
            request: super::VerifyRequest,
        ) -> ::anyhow::Result<super::VerifyResponse>;
    }
    /// The service for the dstack guest agent
    #[derive(Debug)]
    pub struct DstackGuestServer<T: DstackGuestRpc> {
        inner: T,
    }
    impl<T: DstackGuestRpc> DstackGuestServer<T> {
        pub fn new(inner: T) -> Self {
            Self { inner }
        }
        pub async fn dispatch_request(
            self,
            path: &str,
            _data: impl AsRef<[u8]>,
        ) -> Result<Vec<u8>, ::prpc::server::Error> {
            #![allow(clippy::let_unit_value)]
            match path {
                "GetTlsKey" => {
                    let input: super::GetTlsKeyArgs = ::prpc::Message::decode(_data.as_ref())?;
                    let response = self.inner.get_tls_key(input).await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "GetKey" => {
                    let input: super::GetKeyArgs = ::prpc::Message::decode(_data.as_ref())?;
                    let response = self.inner.get_key(input).await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "GetQuote" => {
                    let input: super::RawQuoteArgs = ::prpc::Message::decode(_data.as_ref())?;
                    let response = self.inner.get_quote(input).await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "EmitEvent" => {
                    let input: super::EmitEventArgs = ::prpc::Message::decode(_data.as_ref())?;
                    let response = self.inner.emit_event(input).await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "Info" => {
                    let response = self.inner.info().await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "Sign" => {
                    let input: super::SignRequest = ::prpc::Message::decode(_data.as_ref())?;
                    let response = self.inner.sign(input).await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "Verify" => {
                    let input: super::VerifyRequest = ::prpc::Message::decode(_data.as_ref())?;
                    let response = self.inner.verify(input).await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                _ => anyhow::bail!("Service not found: {path}"),
            }
        }
        pub async fn dispatch_json_request(
            self,
            path: &str,
            _data: impl AsRef<[u8]>,
            _query: bool,
        ) -> Result<Vec<u8>, ::prpc::server::Error> {
            #![allow(clippy::let_unit_value)]
            match path {
                "GetTlsKey" => {
                    let data = _data.as_ref();
                    let input: super::GetTlsKeyArgs = if data.is_empty() {
                        Default::default()
                    } else if _query {
                        ::prpc::serde_qs::from_bytes(data)?
                    } else {
                        ::prpc::serde_json::from_slice(data)?
                    };
                    let response = self.inner.get_tls_key(input).await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "GetKey" => {
                    let data = _data.as_ref();
                    let input: super::GetKeyArgs = if data.is_empty() {
                        Default::default()
                    } else if _query {
                        ::prpc::serde_qs::from_bytes(data)?
                    } else {
                        ::prpc::serde_json::from_slice(data)?
                    };
                    let response = self.inner.get_key(input).await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "GetQuote" => {
                    let data = _data.as_ref();
                    let input: super::RawQuoteArgs = if data.is_empty() {
                        Default::default()
                    } else if _query {
                        ::prpc::serde_qs::from_bytes(data)?
                    } else {
                        ::prpc::serde_json::from_slice(data)?
                    };
                    let response = self.inner.get_quote(input).await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "EmitEvent" => {
                    let data = _data.as_ref();
                    let input: super::EmitEventArgs = if data.is_empty() {
                        Default::default()
                    } else if _query {
                        ::prpc::serde_qs::from_bytes(data)?
                    } else {
                        ::prpc::serde_json::from_slice(data)?
                    };
                    let response = self.inner.emit_event(input).await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "Info" => {
                    let response = self.inner.info().await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "Sign" => {
                    let data = _data.as_ref();
                    let input: super::SignRequest = if data.is_empty() {
                        Default::default()
                    } else if _query {
                        ::prpc::serde_qs::from_bytes(data)?
                    } else {
                        ::prpc::serde_json::from_slice(data)?
                    };
                    let response = self.inner.sign(input).await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "Verify" => {
                    let data = _data.as_ref();
                    let input: super::VerifyRequest = if data.is_empty() {
                        Default::default()
                    } else if _query {
                        ::prpc::serde_qs::from_bytes(data)?
                    } else {
                        ::prpc::serde_json::from_slice(data)?
                    };
                    let response = self.inner.verify(input).await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                _ => anyhow::bail!("Service not found: {path}"),
            }
        }
        pub fn supported_methods() -> &'static [&'static str] {
            &[
                "GetTlsKey",
                "GetKey",
                "GetQuote",
                "EmitEvent",
                "Info",
                "Sign",
                "Verify",
            ]
        }
    }
    impl<T: DstackGuestRpc> ::prpc::server::NamedService for DstackGuestServer<T> {
        const NAME: &'static str = "DstackGuest";
    }
    impl<T: DstackGuestRpc> ::prpc::server::Service for DstackGuestServer<T> {
        type Methods = &'static [&'static str];
        fn methods() -> Self::Methods {
            Self::supported_methods()
        }
        async fn dispatch_request(
            self,
            path: &str,
            data: impl AsRef<[u8]>,
            json: bool,
            query: bool,
        ) -> Result<Vec<u8>, ::prpc::server::Error> {
            if json {
                self.dispatch_json_request(path, data, query).await
            } else {
                self.dispatch_request(path, data).await
            }
        }
    }
    impl<T: DstackGuestRpc> From<T> for DstackGuestServer<T> {
        fn from(inner: T) -> Self {
            Self::new(inner)
        }
    }
}
/// Generated server implementations.
pub mod worker_server {
    use alloc::vec::Vec;
    pub enum WorkerMethod {
        Info,
        Version,
        GetAttestationForAppKey,
    }
    impl WorkerMethod {
        #[allow(clippy::should_implement_trait)]
        pub fn from_str(path: &str) -> Option<Self> {
            match path {
                "Info" => Some(Self::Info),
                "Version" => Some(Self::Version),
                "GetAttestationForAppKey" => Some(Self::GetAttestationForAppKey),
                _ => None,
            }
        }
    }
    ///Generated trait containing RPC methods that should be implemented for use with WorkerServer.
    pub trait WorkerRpc {
        /// Get app info
        async fn info(self) -> ::anyhow::Result<super::AppInfo>;
        /// Get the guest agent version
        async fn version(self) -> ::anyhow::Result<super::WorkerVersion>;
        /// Get attestation
        async fn get_attestation_for_app_key(
            self,
            request: super::GetAttestationForAppKeyRequest,
        ) -> ::anyhow::Result<super::GetQuoteResponse>;
    }
    #[derive(Debug)]
    pub struct WorkerServer<T: WorkerRpc> {
        inner: T,
    }
    impl<T: WorkerRpc> WorkerServer<T> {
        pub fn new(inner: T) -> Self {
            Self { inner }
        }
        pub async fn dispatch_request(
            self,
            path: &str,
            _data: impl AsRef<[u8]>,
        ) -> Result<Vec<u8>, ::prpc::server::Error> {
            #![allow(clippy::let_unit_value)]
            match path {
                "Info" => {
                    let response = self.inner.info().await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "Version" => {
                    let response = self.inner.version().await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "GetAttestationForAppKey" => {
                    let input: super::GetAttestationForAppKeyRequest =
                        ::prpc::Message::decode(_data.as_ref())?;
                    let response = self.inner.get_attestation_for_app_key(input).await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                _ => anyhow::bail!("Service not found: {path}"),
            }
        }
        pub async fn dispatch_json_request(
            self,
            path: &str,
            _data: impl AsRef<[u8]>,
            _query: bool,
        ) -> Result<Vec<u8>, ::prpc::server::Error> {
            #![allow(clippy::let_unit_value)]
            match path {
                "Info" => {
                    let response = self.inner.info().await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "Version" => {
                    let response = self.inner.version().await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "GetAttestationForAppKey" => {
                    let data = _data.as_ref();
                    let input: super::GetAttestationForAppKeyRequest = if data.is_empty() {
                        Default::default()
                    } else if _query {
                        ::prpc::serde_qs::from_bytes(data)?
                    } else {
                        ::prpc::serde_json::from_slice(data)?
                    };
                    let response = self.inner.get_attestation_for_app_key(input).await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                _ => anyhow::bail!("Service not found: {path}"),
            }
        }
        pub fn supported_methods() -> &'static [&'static str] {
            &["Info", "Version", "GetAttestationForAppKey"]
        }
    }
    impl<T: WorkerRpc> ::prpc::server::NamedService for WorkerServer<T> {
        const NAME: &'static str = "Worker";
    }
    impl<T: WorkerRpc> ::prpc::server::Service for WorkerServer<T> {
        type Methods = &'static [&'static str];
        fn methods() -> Self::Methods {
            Self::supported_methods()
        }
        async fn dispatch_request(
            self,
            path: &str,
            data: impl AsRef<[u8]>,
            json: bool,
            query: bool,
        ) -> Result<Vec<u8>, ::prpc::server::Error> {
            if json {
                self.dispatch_json_request(path, data, query).await
            } else {
                self.dispatch_request(path, data).await
            }
        }
    }
    impl<T: WorkerRpc> From<T> for WorkerServer<T> {
        fn from(inner: T) -> Self {
            Self::new(inner)
        }
    }
}
