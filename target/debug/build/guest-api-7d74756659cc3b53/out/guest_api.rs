// This file is @generated by prost-build.
/// Identifies a running guest worker instance.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct Id {
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub id: ::prost::alloc::string::String,
}
/// Static attestation and registration info reported by the guest agent.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GuestInfo {
    /// Guest software version
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub version: ::prost::alloc::string::String,
    /// App ID
    #[prost(bytes = "vec", tag = "2")]
    #[serde(default)]
    pub app_id: ::prost::alloc::vec::Vec<u8>,
    /// App Instance ID
    #[prost(bytes = "vec", tag = "3")]
    #[serde(default)]
    pub instance_id: ::prost::alloc::vec::Vec<u8>,
    /// App certificate
    #[prost(string, tag = "4")]
    #[serde(default)]
    pub app_cert: ::prost::alloc::string::String,
    /// TCB info
    #[prost(string, tag = "5")]
    #[serde(default)]
    pub tcb_info: ::prost::alloc::string::String,
    /// Device ID
    #[prost(bytes = "vec", tag = "6")]
    #[serde(default)]
    pub device_id: ::prost::alloc::vec::Vec<u8>,
}
/// IPv4/IPv6 address with prefix length.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct IpAddress {
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub address: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    #[serde(default)]
    pub prefix: u32,
}
/// Observability metrics for a single NIC inside the guest.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct Interface {
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    #[serde(default)]
    pub addresses: ::prost::alloc::vec::Vec<IpAddress>,
    #[prost(uint64, tag = "3")]
    #[serde(default)]
    pub rx_bytes: u64,
    #[prost(uint64, tag = "4")]
    #[serde(default)]
    pub tx_bytes: u64,
    #[prost(uint64, tag = "5")]
    #[serde(default)]
    pub rx_errors: u64,
    #[prost(uint64, tag = "6")]
    #[serde(default)]
    pub tx_errors: u64,
}
/// Default gateway entry advertised to the guest.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct Gateway {
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub address: ::prost::alloc::string::String,
}
/// Complete networking snapshot including WireGuard info.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct NetworkInformation {
    #[prost(string, repeated, tag = "1")]
    #[serde(default)]
    pub dns_servers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "2")]
    #[serde(default)]
    pub gateways: ::prost::alloc::vec::Vec<Gateway>,
    #[prost(message, repeated, tag = "3")]
    #[serde(default)]
    pub interfaces: ::prost::alloc::vec::Vec<Interface>,
    #[prost(string, tag = "4")]
    #[serde(default)]
    pub wg_info: ::prost::alloc::string::String,
}
/// Lists all containers currently scheduled in the guest.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct ListContainersResponse {
    #[prost(message, repeated, tag = "1")]
    #[serde(default)]
    pub containers: ::prost::alloc::vec::Vec<Container>,
}
/// Docker-compatible view of an application container.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct Container {
    /// The ID of this container
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub id: ::prost::alloc::string::String,
    /// The names that this container has been given
    #[prost(string, repeated, tag = "2")]
    #[serde(default)]
    pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The name of the image used when creating this container
    #[prost(string, tag = "3")]
    #[serde(default)]
    pub image: ::prost::alloc::string::String,
    /// The ID of the image that this container was created from
    #[prost(string, tag = "4")]
    #[serde(default)]
    pub image_id: ::prost::alloc::string::String,
    /// When the container was created
    #[prost(int64, tag = "6")]
    #[serde(default)]
    pub created: i64,
    /// The state of this container (e.g. Exited)
    #[prost(string, tag = "7")]
    #[serde(default)]
    pub state: ::prost::alloc::string::String,
    /// The status of this container (e.g. Exited)
    #[prost(string, tag = "8")]
    #[serde(default)]
    pub status: ::prost::alloc::string::String,
}
/// OS, kernel, and resource metrics for the guest worker.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SystemInfo {
    /// Operating system
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub os_name: ::prost::alloc::string::String,
    /// Operating system version
    #[prost(string, tag = "2")]
    #[serde(default)]
    pub os_version: ::prost::alloc::string::String,
    /// Kernel version
    #[prost(string, tag = "3")]
    #[serde(default)]
    pub kernel_version: ::prost::alloc::string::String,
    /// Cpu model
    #[prost(string, tag = "4")]
    #[serde(default)]
    pub cpu_model: ::prost::alloc::string::String,
    /// Number of logical CPUs
    #[prost(uint32, tag = "5")]
    #[serde(default)]
    pub num_cpus: u32,
    /// Total memory
    #[prost(uint64, tag = "6")]
    #[serde(default)]
    pub total_memory: u64,
    /// Available memory
    #[prost(uint64, tag = "7")]
    #[serde(default)]
    pub available_memory: u64,
    /// Used memory
    #[prost(uint64, tag = "8")]
    #[serde(default)]
    pub used_memory: u64,
    /// Free memory
    #[prost(uint64, tag = "9")]
    #[serde(default)]
    pub free_memory: u64,
    /// Total swap memory
    #[prost(uint64, tag = "10")]
    #[serde(default)]
    pub total_swap: u64,
    /// Used swap memory
    #[prost(uint64, tag = "11")]
    #[serde(default)]
    pub used_swap: u64,
    /// Free swap memory
    #[prost(uint64, tag = "12")]
    #[serde(default)]
    pub free_swap: u64,
    /// Uptime
    #[prost(uint64, tag = "13")]
    #[serde(default)]
    pub uptime: u64,
    /// Load average
    #[prost(uint32, tag = "14")]
    #[serde(default)]
    pub loadavg_one: u32,
    #[prost(uint32, tag = "15")]
    #[serde(default)]
    pub loadavg_five: u32,
    #[prost(uint32, tag = "16")]
    #[serde(default)]
    pub loadavg_fifteen: u32,
    /// Disks
    #[prost(message, repeated, tag = "17")]
    #[serde(default)]
    pub disks: ::prost::alloc::vec::Vec<DiskInfo>,
}
/// Disk usage metrics scoped per device or mount point.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct DiskInfo {
    /// Device name
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub name: ::prost::alloc::string::String,
    /// Mount point
    #[prost(string, tag = "2")]
    #[serde(default)]
    pub mount_point: ::prost::alloc::string::String,
    /// Total size
    #[prost(uint64, tag = "3")]
    #[serde(default)]
    pub total_size: u64,
    /// Free size
    #[prost(uint64, tag = "5")]
    #[serde(default)]
    pub free_size: u64,
}
/// Generated client implementations.
pub mod guest_api_client {
    /// Direct gRPC surface exposed by the in-guest agent.
    #[derive(Debug)]
    pub struct GuestApiClient<Client> {
        pub client: Client,
    }
    impl<Client> GuestApiClient<Client>
    where
        Client: ::prpc::client::RequestClient,
    {
        pub fn new(client: Client) -> Self {
            Self { client }
        }
        /// Returns attestation material and identifiers for the calling guest.
        pub async fn info(&self) -> Result<super::GuestInfo, ::prpc::client::Error> {
            let request = ();
            self.client.request("Info", request).await
        }
        /// Reports the guest's OS/kernel and resource statistics.
        pub async fn sys_info(&self) -> Result<super::SystemInfo, ::prpc::client::Error> {
            let request = ();
            self.client.request("SysInfo", request).await
        }
        /// Dumps NIC/Gateway configuration so operators can debug connectivity.
        pub async fn network_info(
            &self,
        ) -> Result<super::NetworkInformation, ::prpc::client::Error> {
            let request = ();
            self.client.request("NetworkInfo", request).await
        }
        /// Enumerates the containers running under the guest supervisor.
        pub async fn list_containers(
            &self,
        ) -> Result<super::ListContainersResponse, ::prpc::client::Error> {
            let request = ();
            self.client.request("ListContainers", request).await
        }
        /// Initiates a graceful shutdown inside the guest VM.
        pub async fn shutdown(&self) -> Result<(), ::prpc::client::Error> {
            let request = ();
            self.client.request("Shutdown", request).await
        }
    }
}
/// Generated client implementations.
pub mod proxied_guest_api_client {
    /// Same API surface as GuestApi but multiplexed by VM ID through VMM.
    #[derive(Debug)]
    pub struct ProxiedGuestApiClient<Client> {
        pub client: Client,
    }
    impl<Client> ProxiedGuestApiClient<Client>
    where
        Client: ::prpc::client::RequestClient,
    {
        pub fn new(client: Client) -> Self {
            Self { client }
        }
        pub async fn info(
            &self,
            request: super::Id,
        ) -> Result<super::GuestInfo, ::prpc::client::Error> {
            self.client.request("Info", request).await
        }
        pub async fn sys_info(
            &self,
            request: super::Id,
        ) -> Result<super::SystemInfo, ::prpc::client::Error> {
            self.client.request("SysInfo", request).await
        }
        pub async fn network_info(
            &self,
            request: super::Id,
        ) -> Result<super::NetworkInformation, ::prpc::client::Error> {
            self.client.request("NetworkInfo", request).await
        }
        pub async fn list_containers(
            &self,
            request: super::Id,
        ) -> Result<super::ListContainersResponse, ::prpc::client::Error> {
            self.client.request("ListContainers", request).await
        }
        pub async fn shutdown(&self, request: super::Id) -> Result<(), ::prpc::client::Error> {
            self.client.request("Shutdown", request).await
        }
    }
}
/// Generated server implementations.
pub mod guest_api_server {
    use alloc::vec::Vec;
    pub enum GuestApiMethod {
        Info,
        SysInfo,
        NetworkInfo,
        ListContainers,
        Shutdown,
    }
    impl GuestApiMethod {
        #[allow(clippy::should_implement_trait)]
        pub fn from_str(path: &str) -> Option<Self> {
            match path {
                "Info" => Some(Self::Info),
                "SysInfo" => Some(Self::SysInfo),
                "NetworkInfo" => Some(Self::NetworkInfo),
                "ListContainers" => Some(Self::ListContainers),
                "Shutdown" => Some(Self::Shutdown),
                _ => None,
            }
        }
    }
    ///Generated trait containing RPC methods that should be implemented for use with GuestApiServer.
    pub trait GuestApiRpc {
        /// Returns attestation material and identifiers for the calling guest.
        async fn info(self) -> ::anyhow::Result<super::GuestInfo>;
        /// Reports the guest's OS/kernel and resource statistics.
        async fn sys_info(self) -> ::anyhow::Result<super::SystemInfo>;
        /// Dumps NIC/Gateway configuration so operators can debug connectivity.
        async fn network_info(self) -> ::anyhow::Result<super::NetworkInformation>;
        /// Enumerates the containers running under the guest supervisor.
        async fn list_containers(self) -> ::anyhow::Result<super::ListContainersResponse>;
        /// Initiates a graceful shutdown inside the guest VM.
        async fn shutdown(self) -> ::anyhow::Result<()>;
    }
    /// Direct gRPC surface exposed by the in-guest agent.
    #[derive(Debug)]
    pub struct GuestApiServer<T: GuestApiRpc> {
        inner: T,
    }
    impl<T: GuestApiRpc> GuestApiServer<T> {
        pub fn new(inner: T) -> Self {
            Self { inner }
        }
        pub async fn dispatch_request(
            self,
            path: &str,
            _data: impl AsRef<[u8]>,
        ) -> Result<Vec<u8>, ::prpc::server::Error> {
            #![allow(clippy::let_unit_value)]
            match path {
                "Info" => {
                    let response = self.inner.info().await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "SysInfo" => {
                    let response = self.inner.sys_info().await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "NetworkInfo" => {
                    let response = self.inner.network_info().await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "ListContainers" => {
                    let response = self.inner.list_containers().await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "Shutdown" => {
                    let response = self.inner.shutdown().await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                _ => anyhow::bail!("Service not found: {path}"),
            }
        }
        pub async fn dispatch_json_request(
            self,
            path: &str,
            _data: impl AsRef<[u8]>,
            _query: bool,
        ) -> Result<Vec<u8>, ::prpc::server::Error> {
            #![allow(clippy::let_unit_value)]
            match path {
                "Info" => {
                    let response = self.inner.info().await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "SysInfo" => {
                    let response = self.inner.sys_info().await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "NetworkInfo" => {
                    let response = self.inner.network_info().await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "ListContainers" => {
                    let response = self.inner.list_containers().await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "Shutdown" => {
                    let response = self.inner.shutdown().await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                _ => anyhow::bail!("Service not found: {path}"),
            }
        }
        pub fn supported_methods() -> &'static [&'static str] {
            &[
                "Info",
                "SysInfo",
                "NetworkInfo",
                "ListContainers",
                "Shutdown",
            ]
        }
    }
    impl<T: GuestApiRpc> ::prpc::server::NamedService for GuestApiServer<T> {
        const NAME: &'static str = "GuestApi";
    }
    impl<T: GuestApiRpc> ::prpc::server::Service for GuestApiServer<T> {
        type Methods = &'static [&'static str];
        fn methods() -> Self::Methods {
            Self::supported_methods()
        }
        async fn dispatch_request(
            self,
            path: &str,
            data: impl AsRef<[u8]>,
            json: bool,
            query: bool,
        ) -> Result<Vec<u8>, ::prpc::server::Error> {
            if json {
                self.dispatch_json_request(path, data, query).await
            } else {
                self.dispatch_request(path, data).await
            }
        }
    }
    impl<T: GuestApiRpc> From<T> for GuestApiServer<T> {
        fn from(inner: T) -> Self {
            Self::new(inner)
        }
    }
}
/// Generated server implementations.
pub mod proxied_guest_api_server {
    use alloc::vec::Vec;
    pub enum ProxiedGuestApiMethod {
        Info,
        SysInfo,
        NetworkInfo,
        ListContainers,
        Shutdown,
    }
    impl ProxiedGuestApiMethod {
        #[allow(clippy::should_implement_trait)]
        pub fn from_str(path: &str) -> Option<Self> {
            match path {
                "Info" => Some(Self::Info),
                "SysInfo" => Some(Self::SysInfo),
                "NetworkInfo" => Some(Self::NetworkInfo),
                "ListContainers" => Some(Self::ListContainers),
                "Shutdown" => Some(Self::Shutdown),
                _ => None,
            }
        }
    }
    ///Generated trait containing RPC methods that should be implemented for use with ProxiedGuestApiServer.
    pub trait ProxiedGuestApiRpc {
        async fn info(self, request: super::Id) -> ::anyhow::Result<super::GuestInfo>;
        async fn sys_info(self, request: super::Id) -> ::anyhow::Result<super::SystemInfo>;
        async fn network_info(
            self,
            request: super::Id,
        ) -> ::anyhow::Result<super::NetworkInformation>;
        async fn list_containers(
            self,
            request: super::Id,
        ) -> ::anyhow::Result<super::ListContainersResponse>;
        async fn shutdown(self, request: super::Id) -> ::anyhow::Result<()>;
    }
    /// Same API surface as GuestApi but multiplexed by VM ID through VMM.
    #[derive(Debug)]
    pub struct ProxiedGuestApiServer<T: ProxiedGuestApiRpc> {
        inner: T,
    }
    impl<T: ProxiedGuestApiRpc> ProxiedGuestApiServer<T> {
        pub fn new(inner: T) -> Self {
            Self { inner }
        }
        pub async fn dispatch_request(
            self,
            path: &str,
            _data: impl AsRef<[u8]>,
        ) -> Result<Vec<u8>, ::prpc::server::Error> {
            #![allow(clippy::let_unit_value)]
            match path {
                "Info" => {
                    let input: super::Id = ::prpc::Message::decode(_data.as_ref())?;
                    let response = self.inner.info(input).await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "SysInfo" => {
                    let input: super::Id = ::prpc::Message::decode(_data.as_ref())?;
                    let response = self.inner.sys_info(input).await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "NetworkInfo" => {
                    let input: super::Id = ::prpc::Message::decode(_data.as_ref())?;
                    let response = self.inner.network_info(input).await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "ListContainers" => {
                    let input: super::Id = ::prpc::Message::decode(_data.as_ref())?;
                    let response = self.inner.list_containers(input).await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "Shutdown" => {
                    let input: super::Id = ::prpc::Message::decode(_data.as_ref())?;
                    let response = self.inner.shutdown(input).await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                _ => anyhow::bail!("Service not found: {path}"),
            }
        }
        pub async fn dispatch_json_request(
            self,
            path: &str,
            _data: impl AsRef<[u8]>,
            _query: bool,
        ) -> Result<Vec<u8>, ::prpc::server::Error> {
            #![allow(clippy::let_unit_value)]
            match path {
                "Info" => {
                    let data = _data.as_ref();
                    let input: super::Id = if data.is_empty() {
                        Default::default()
                    } else if _query {
                        ::prpc::serde_qs::from_bytes(data)?
                    } else {
                        ::prpc::serde_json::from_slice(data)?
                    };
                    let response = self.inner.info(input).await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "SysInfo" => {
                    let data = _data.as_ref();
                    let input: super::Id = if data.is_empty() {
                        Default::default()
                    } else if _query {
                        ::prpc::serde_qs::from_bytes(data)?
                    } else {
                        ::prpc::serde_json::from_slice(data)?
                    };
                    let response = self.inner.sys_info(input).await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "NetworkInfo" => {
                    let data = _data.as_ref();
                    let input: super::Id = if data.is_empty() {
                        Default::default()
                    } else if _query {
                        ::prpc::serde_qs::from_bytes(data)?
                    } else {
                        ::prpc::serde_json::from_slice(data)?
                    };
                    let response = self.inner.network_info(input).await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "ListContainers" => {
                    let data = _data.as_ref();
                    let input: super::Id = if data.is_empty() {
                        Default::default()
                    } else if _query {
                        ::prpc::serde_qs::from_bytes(data)?
                    } else {
                        ::prpc::serde_json::from_slice(data)?
                    };
                    let response = self.inner.list_containers(input).await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "Shutdown" => {
                    let data = _data.as_ref();
                    let input: super::Id = if data.is_empty() {
                        Default::default()
                    } else if _query {
                        ::prpc::serde_qs::from_bytes(data)?
                    } else {
                        ::prpc::serde_json::from_slice(data)?
                    };
                    let response = self.inner.shutdown(input).await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                _ => anyhow::bail!("Service not found: {path}"),
            }
        }
        pub fn supported_methods() -> &'static [&'static str] {
            &[
                "Info",
                "SysInfo",
                "NetworkInfo",
                "ListContainers",
                "Shutdown",
            ]
        }
    }
    impl<T: ProxiedGuestApiRpc> ::prpc::server::NamedService for ProxiedGuestApiServer<T> {
        const NAME: &'static str = "ProxiedGuestApi";
    }
    impl<T: ProxiedGuestApiRpc> ::prpc::server::Service for ProxiedGuestApiServer<T> {
        type Methods = &'static [&'static str];
        fn methods() -> Self::Methods {
            Self::supported_methods()
        }
        async fn dispatch_request(
            self,
            path: &str,
            data: impl AsRef<[u8]>,
            json: bool,
            query: bool,
        ) -> Result<Vec<u8>, ::prpc::server::Error> {
            if json {
                self.dispatch_json_request(path, data, query).await
            } else {
                self.dispatch_request(path, data).await
            }
        }
    }
    impl<T: ProxiedGuestApiRpc> From<T> for ProxiedGuestApiServer<T> {
        fn from(inner: T) -> Self {
            Self::new(inner)
        }
    }
}
