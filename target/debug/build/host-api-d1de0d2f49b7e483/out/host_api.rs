// This file is @generated by prost-build.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct HostInfo {
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    #[serde(default)]
    pub version: ::prost::alloc::string::String,
}
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct Notification {
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub event: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    #[serde(default)]
    pub payload: ::prost::alloc::string::String,
}
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetSealingKeyRequest {
    #[prost(bytes = "vec", tag = "1")]
    #[serde(default)]
    pub quote: ::prost::alloc::vec::Vec<u8>,
}
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetSealingKeyResponse {
    #[prost(bytes = "vec", tag = "1")]
    #[serde(default)]
    pub encrypted_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    #[serde(default)]
    pub provider_quote: ::prost::alloc::vec::Vec<u8>,
}
/// Generated client implementations.
pub mod host_api_client {
    #[derive(Debug)]
    pub struct HostApiClient<Client> {
        pub client: Client,
    }
    impl<Client> HostApiClient<Client>
    where
        Client: ::prpc::client::RequestClient,
    {
        pub fn new(client: Client) -> Self {
            Self { client }
        }
        pub async fn info(&self) -> Result<super::HostInfo, ::prpc::client::Error> {
            let request = ();
            self.client.request("Info", request).await
        }
        pub async fn notify(
            &self,
            request: super::Notification,
        ) -> Result<(), ::prpc::client::Error> {
            self.client.request("Notify", request).await
        }
        pub async fn get_sealing_key(
            &self,
            request: super::GetSealingKeyRequest,
        ) -> Result<super::GetSealingKeyResponse, ::prpc::client::Error> {
            self.client.request("GetSealingKey", request).await
        }
    }
}
/// Generated server implementations.
pub mod host_api_server {
    use alloc::vec::Vec;
    pub enum HostApiMethod {
        Info,
        Notify,
        GetSealingKey,
    }
    impl HostApiMethod {
        #[allow(clippy::should_implement_trait)]
        pub fn from_str(path: &str) -> Option<Self> {
            match path {
                "Info" => Some(Self::Info),
                "Notify" => Some(Self::Notify),
                "GetSealingKey" => Some(Self::GetSealingKey),
                _ => None,
            }
        }
    }
    ///Generated trait containing RPC methods that should be implemented for use with HostApiServer.
    pub trait HostApiRpc {
        async fn info(self) -> ::anyhow::Result<super::HostInfo>;
        async fn notify(self, request: super::Notification) -> ::anyhow::Result<()>;
        async fn get_sealing_key(
            self,
            request: super::GetSealingKeyRequest,
        ) -> ::anyhow::Result<super::GetSealingKeyResponse>;
    }
    #[derive(Debug)]
    pub struct HostApiServer<T: HostApiRpc> {
        inner: T,
    }
    impl<T: HostApiRpc> HostApiServer<T> {
        pub fn new(inner: T) -> Self {
            Self { inner }
        }
        pub async fn dispatch_request(
            self,
            path: &str,
            _data: impl AsRef<[u8]>,
        ) -> Result<Vec<u8>, ::prpc::server::Error> {
            #![allow(clippy::let_unit_value)]
            match path {
                "Info" => {
                    let response = self.inner.info().await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "Notify" => {
                    let input: super::Notification = ::prpc::Message::decode(_data.as_ref())?;
                    let response = self.inner.notify(input).await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "GetSealingKey" => {
                    let input: super::GetSealingKeyRequest =
                        ::prpc::Message::decode(_data.as_ref())?;
                    let response = self.inner.get_sealing_key(input).await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                _ => anyhow::bail!("Service not found: {path}"),
            }
        }
        pub async fn dispatch_json_request(
            self,
            path: &str,
            _data: impl AsRef<[u8]>,
            _query: bool,
        ) -> Result<Vec<u8>, ::prpc::server::Error> {
            #![allow(clippy::let_unit_value)]
            match path {
                "Info" => {
                    let response = self.inner.info().await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "Notify" => {
                    let data = _data.as_ref();
                    let input: super::Notification = if data.is_empty() {
                        Default::default()
                    } else if _query {
                        ::prpc::serde_qs::from_bytes(data)?
                    } else {
                        ::prpc::serde_json::from_slice(data)?
                    };
                    let response = self.inner.notify(input).await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "GetSealingKey" => {
                    let data = _data.as_ref();
                    let input: super::GetSealingKeyRequest = if data.is_empty() {
                        Default::default()
                    } else if _query {
                        ::prpc::serde_qs::from_bytes(data)?
                    } else {
                        ::prpc::serde_json::from_slice(data)?
                    };
                    let response = self.inner.get_sealing_key(input).await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                _ => anyhow::bail!("Service not found: {path}"),
            }
        }
        pub fn supported_methods() -> &'static [&'static str] {
            &["Info", "Notify", "GetSealingKey"]
        }
    }
    impl<T: HostApiRpc> ::prpc::server::NamedService for HostApiServer<T> {
        const NAME: &'static str = "HostApi";
    }
    impl<T: HostApiRpc> ::prpc::server::Service for HostApiServer<T> {
        type Methods = &'static [&'static str];
        fn methods() -> Self::Methods {
            Self::supported_methods()
        }
        async fn dispatch_request(
            self,
            path: &str,
            data: impl AsRef<[u8]>,
            json: bool,
            query: bool,
        ) -> Result<Vec<u8>, ::prpc::server::Error> {
            if json {
                self.dispatch_json_request(path, data, query).await
            } else {
                self.dispatch_request(path, data).await
            }
        }
    }
    impl<T: HostApiRpc> From<T> for HostApiServer<T> {
        fn from(inner: T) -> Self {
            Self::new(inner)
        }
    }
}
