/* automatically generated by rust-bindgen 0.71.1 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const __WORDSIZE: u32 = 64;
pub const __has_safe_buffers: u32 = 1;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &[u8; 14] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const __has_bounds_safety_attributes: u32 = 0;
pub const USE_CLANG_TYPES: u32 = 0;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const TDX_UUID_SIZE: u32 = 16;
pub const TDX_REPORT_DATA_SIZE: u32 = 64;
pub const TDX_REPORT_SIZE: u32 = 1024;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __mbstate_t"][::std::mem::size_of::<__mbstate_t>() - 128usize];
    ["Alignment of __mbstate_t"][::std::mem::align_of::<__mbstate_t>() - 8usize];
    ["Offset of field: __mbstate_t::__mbstate8"]
        [::std::mem::offset_of!(__mbstate_t, __mbstate8) - 0usize];
    ["Offset of field: __mbstate_t::_mbstateL"]
        [::std::mem::offset_of!(__mbstate_t, _mbstateL) - 0usize];
};
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_pthread_handler_rec"]
        [::std::mem::size_of::<__darwin_pthread_handler_rec>() - 24usize];
    ["Alignment of __darwin_pthread_handler_rec"]
        [::std::mem::align_of::<__darwin_pthread_handler_rec>() - 8usize];
    ["Offset of field: __darwin_pthread_handler_rec::__routine"]
        [::std::mem::offset_of!(__darwin_pthread_handler_rec, __routine) - 0usize];
    ["Offset of field: __darwin_pthread_handler_rec::__arg"]
        [::std::mem::offset_of!(__darwin_pthread_handler_rec, __arg) - 8usize];
    ["Offset of field: __darwin_pthread_handler_rec::__next"]
        [::std::mem::offset_of!(__darwin_pthread_handler_rec, __next) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_attr_t"][::std::mem::size_of::<_opaque_pthread_attr_t>() - 64usize];
    ["Alignment of _opaque_pthread_attr_t"]
        [::std::mem::align_of::<_opaque_pthread_attr_t>() - 8usize];
    ["Offset of field: _opaque_pthread_attr_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_attr_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_attr_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_attr_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_cond_t"][::std::mem::size_of::<_opaque_pthread_cond_t>() - 48usize];
    ["Alignment of _opaque_pthread_cond_t"]
        [::std::mem::align_of::<_opaque_pthread_cond_t>() - 8usize];
    ["Offset of field: _opaque_pthread_cond_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_cond_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_cond_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_cond_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_condattr_t"]
        [::std::mem::size_of::<_opaque_pthread_condattr_t>() - 16usize];
    ["Alignment of _opaque_pthread_condattr_t"]
        [::std::mem::align_of::<_opaque_pthread_condattr_t>() - 8usize];
    ["Offset of field: _opaque_pthread_condattr_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_condattr_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_condattr_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_condattr_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_mutex_t"][::std::mem::size_of::<_opaque_pthread_mutex_t>() - 64usize];
    ["Alignment of _opaque_pthread_mutex_t"]
        [::std::mem::align_of::<_opaque_pthread_mutex_t>() - 8usize];
    ["Offset of field: _opaque_pthread_mutex_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_mutex_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_mutex_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_mutex_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_mutexattr_t"]
        [::std::mem::size_of::<_opaque_pthread_mutexattr_t>() - 16usize];
    ["Alignment of _opaque_pthread_mutexattr_t"]
        [::std::mem::align_of::<_opaque_pthread_mutexattr_t>() - 8usize];
    ["Offset of field: _opaque_pthread_mutexattr_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_mutexattr_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_mutexattr_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_mutexattr_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_once_t"][::std::mem::size_of::<_opaque_pthread_once_t>() - 16usize];
    ["Alignment of _opaque_pthread_once_t"]
        [::std::mem::align_of::<_opaque_pthread_once_t>() - 8usize];
    ["Offset of field: _opaque_pthread_once_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_once_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_once_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_once_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_rwlock_t"]
        [::std::mem::size_of::<_opaque_pthread_rwlock_t>() - 200usize];
    ["Alignment of _opaque_pthread_rwlock_t"]
        [::std::mem::align_of::<_opaque_pthread_rwlock_t>() - 8usize];
    ["Offset of field: _opaque_pthread_rwlock_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_rwlock_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_rwlock_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_rwlock_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_rwlockattr_t"]
        [::std::mem::size_of::<_opaque_pthread_rwlockattr_t>() - 24usize];
    ["Alignment of _opaque_pthread_rwlockattr_t"]
        [::std::mem::align_of::<_opaque_pthread_rwlockattr_t>() - 8usize];
    ["Offset of field: _opaque_pthread_rwlockattr_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_rwlockattr_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_rwlockattr_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_rwlockattr_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_t"][::std::mem::size_of::<_opaque_pthread_t>() - 8192usize];
    ["Alignment of _opaque_pthread_t"][::std::mem::align_of::<_opaque_pthread_t>() - 8usize];
    ["Offset of field: _opaque_pthread_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_t::__cleanup_stack"]
        [::std::mem::offset_of!(_opaque_pthread_t, __cleanup_stack) - 8usize];
    ["Offset of field: _opaque_pthread_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_t, __opaque) - 16usize];
};
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub mod _tdx_attest_error_t {
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "< Success"]
    pub const TDX_ATTEST_SUCCESS: Type = 0;
    #[doc = "< Indicate min error to allow better translation."]
    pub const TDX_ATTEST_ERROR_MIN: Type = 1;
    #[doc = "< Unexpected error"]
    pub const TDX_ATTEST_ERROR_UNEXPECTED: Type = 1;
    #[doc = "< The parameter is incorrect"]
    pub const TDX_ATTEST_ERROR_INVALID_PARAMETER: Type = 2;
    #[doc = "< Not enough memory is available to complete this operation"]
    pub const TDX_ATTEST_ERROR_OUT_OF_MEMORY: Type = 3;
    #[doc = "< vsock related failure"]
    pub const TDX_ATTEST_ERROR_VSOCK_FAILURE: Type = 4;
    #[doc = "< Failed to get the TD Report"]
    pub const TDX_ATTEST_ERROR_REPORT_FAILURE: Type = 5;
    #[doc = "< Failed to extend rtmr"]
    pub const TDX_ATTEST_ERROR_EXTEND_FAILURE: Type = 6;
    #[doc = "< Request feature is not supported"]
    pub const TDX_ATTEST_ERROR_NOT_SUPPORTED: Type = 7;
    #[doc = "< Failed to get the TD Quote"]
    pub const TDX_ATTEST_ERROR_QUOTE_FAILURE: Type = 8;
    #[doc = "< The device driver return busy"]
    pub const TDX_ATTEST_ERROR_BUSY: Type = 9;
    #[doc = "< Failed to acess tdx attest device"]
    pub const TDX_ATTEST_ERROR_DEVICE_FAILURE: Type = 10;
    #[doc = "< Only supported RTMR index is 2 and 3"]
    pub const TDX_ATTEST_ERROR_INVALID_RTMR_INDEX: Type = 11;
    #[doc = "< The platform Quoting infrastructure does not support any of the keys described in att_key_id_list"]
    pub const TDX_ATTEST_ERROR_UNSUPPORTED_ATT_KEY_ID: Type = 12;
    pub const TDX_ATTEST_ERROR_MAX: Type = 13;
}
pub use self::_tdx_attest_error_t::Type as tdx_attest_error_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tdx_uuid_t {
    pub d: [u8; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _tdx_uuid_t"][::std::mem::size_of::<_tdx_uuid_t>() - 16usize];
    ["Alignment of _tdx_uuid_t"][::std::mem::align_of::<_tdx_uuid_t>() - 1usize];
    ["Offset of field: _tdx_uuid_t::d"][::std::mem::offset_of!(_tdx_uuid_t, d) - 0usize];
};
pub type tdx_uuid_t = _tdx_uuid_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tdx_report_data_t {
    pub d: [u8; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _tdx_report_data_t"][::std::mem::size_of::<_tdx_report_data_t>() - 64usize];
    ["Alignment of _tdx_report_data_t"][::std::mem::align_of::<_tdx_report_data_t>() - 1usize];
    ["Offset of field: _tdx_report_data_t::d"]
        [::std::mem::offset_of!(_tdx_report_data_t, d) - 0usize];
};
pub type tdx_report_data_t = _tdx_report_data_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tdx_report_t {
    pub d: [u8; 1024usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _tdx_report_t"][::std::mem::size_of::<_tdx_report_t>() - 1024usize];
    ["Alignment of _tdx_report_t"][::std::mem::align_of::<_tdx_report_t>() - 1usize];
    ["Offset of field: _tdx_report_t::d"][::std::mem::offset_of!(_tdx_report_t, d) - 0usize];
};
pub type tdx_report_t = _tdx_report_t;
#[repr(C, packed)]
pub struct _tdx_rtmr_event_t {
    pub version: u32,
    pub rtmr_index: u64,
    pub extend_data: [u8; 48usize],
    pub event_type: u32,
    pub event_data_size: u32,
    pub event_data: __IncompleteArrayField<u8>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _tdx_rtmr_event_t"][::std::mem::size_of::<_tdx_rtmr_event_t>() - 68usize];
    ["Alignment of _tdx_rtmr_event_t"][::std::mem::align_of::<_tdx_rtmr_event_t>() - 1usize];
    ["Offset of field: _tdx_rtmr_event_t::version"]
        [::std::mem::offset_of!(_tdx_rtmr_event_t, version) - 0usize];
    ["Offset of field: _tdx_rtmr_event_t::rtmr_index"]
        [::std::mem::offset_of!(_tdx_rtmr_event_t, rtmr_index) - 4usize];
    ["Offset of field: _tdx_rtmr_event_t::extend_data"]
        [::std::mem::offset_of!(_tdx_rtmr_event_t, extend_data) - 12usize];
    ["Offset of field: _tdx_rtmr_event_t::event_type"]
        [::std::mem::offset_of!(_tdx_rtmr_event_t, event_type) - 60usize];
    ["Offset of field: _tdx_rtmr_event_t::event_data_size"]
        [::std::mem::offset_of!(_tdx_rtmr_event_t, event_data_size) - 64usize];
    ["Offset of field: _tdx_rtmr_event_t::event_data"]
        [::std::mem::offset_of!(_tdx_rtmr_event_t, event_data) - 68usize];
};
pub type tdx_rtmr_event_t = _tdx_rtmr_event_t;
unsafe extern "C" {
    #[doc = " @brief Request a Quote of the calling TD.\n\n The caller provides data intended to be cryptographically bound to the\n resulting Quote. (This data should not require confidentiality protection.)\n The caller also provides information about the type of Quote signing that\n should be used.\n\n In general, a given platform can create Quotes using\n different cryptographic algorithms or using different vendors’ code/enclaves.\n The att_key_id_list parameter is related to this. It is a list of key IDs\n supported by the eventual verifier of the Quote. How the caller of this\n function obtains this list is outside the scope of the R3AAL.\n\n A default key ID is supported and will be used when att_key_id_list == NULL.\n In this case, the default key ID is returned via the p_att_key_id parameter.\n\n When the function returns successfully, p_quote will point to a buffer\n containing the Quote. This buffer is allocated by the function. Use\n tdx_att_free_quote to free this buffer.\n\n @param p_tdx_report_data [in] Pointer to data that the caller/TD wants to\n                               cryptographically bind to the Quote,\n                               typically a hash. Cannot be NULL.\n @param att_key_id_list [in] List (array) of the attestation key IDs supported\n                             by the Quote verifier. The function compares the\n                             key IDs in att_key_id_list to the key IDs that\n                             the platform supports and uses the first match.\n                             May be NULL. If NULL, the API will use the\n                             platform’s default key ID. The uuid_t\n                             corresponding to the key ID that’s used is\n                             pointed to by p_att_key_id when the function\n                             returns unless p_att_key_id == NULL.\n @param list_size [in] Size of att_key_id_list in entries.\n @param p_att_key_id [out] The selected attestation key ID when the function\n                           returns. May be NULL indicating the platform’s\n                           default key ID\n @param pp_quote [out] Pointer to a pointer that the function will set equal\n                       to the address of the buffer containing the Quote. The\n                       function also allocates this buffer. Use\n                       tdx_att_free_quote to free this buffe\n @param p_quote_size [out] This function will place the size of the Quote, in\n                           bytes, in the uint32_t pointed to by the\n                           p_quote_size parameter. May be NULL.\n @param flags [in] Reserved, must be zero.\n @return TDX_ATTEST_SUCCESS: Successfully generated the Quote.\n @return TDX_ATTEST_ERROR_UNEXPECTED: An unexpected internal error occurred.\n @return TDX_ATTEST_ERROR_INVALID_PARAMETER: The parameter is incorrect\n @return TDX_ATTEST_ERROR_DEVICE_FAILURE: Failed to acess tdx attest device.\n @return TDX_ATTEST_ERROR_REPORT_FAILURE: Failed to get TD report.\n @return TDX_ATTEST_ERROR_VSOCK_FAILURE: Failed read/write in vsock mode\n @return TDX_ATTEST_ERROR_QUOTE_FAILURE: Failed to get quote from QGS\n @return TDX_ATTEST_UNSUPPORTED_ATT_KEY_ID: The platform Quoting\n         infrastructure does not support any of the keys described in\n         att_key_id_list.\n @return TDX_ATTEST_OUT_OF_MEMORY: Heap memory allocation error in library or\n                                enclave."]
    pub fn tdx_att_get_quote(
        p_tdx_report_data: *const tdx_report_data_t,
        att_key_id_list: *const tdx_uuid_t,
        list_size: u32,
        p_att_key_id: *mut tdx_uuid_t,
        pp_quote: *mut *mut u8,
        p_quote_size: *mut u32,
        flags: u32,
    ) -> tdx_attest_error_t;
}
unsafe extern "C" {
    #[doc = " @brief Free the Quote buffer allocated by tdx_att_get_quote.\n\n @param p_quote [in] The value of *p_quote returned by tdx_att_get_quote.\n @return TDX_ATTEST_SUCCESS: Successfully freed the p_quote."]
    pub fn tdx_att_free_quote(p_quote: *mut u8) -> tdx_attest_error_t;
}
unsafe extern "C" {
    #[doc = " @brief Request a TDX Report of the calling TD.\n\n The caller provides data intended to be cryptographically bound to the\n resulting Report.\n\n @param p_tdx_report_data [in] Pointer to data that the caller/TD wants to\n                               cryptographically bind to the Quote, typically\n                               a hash. Cannot be NULL.\n @param p_tdx_report [out] Pointer to the buffer that will contain the\n                           generated TDX Report. Must not be NULL.\n @return TDX_ATTEST_SUCCESS: Successfully generated the Report.\n @return TDX_ATTEST_ERROR_INVALID_PARAMETER: p_tdx_report == NULL\n @return TDX_ATTEST_ERROR_DEVICE_FAILURE: Failed to acess tdx attest device.\n @return TDX_ATTEST_ERROR_REPORT_FAILURE: Failed to get TD report."]
    pub fn tdx_att_get_report(
        p_tdx_report_data: *const tdx_report_data_t,
        p_tdx_report: *mut tdx_report_t,
    ) -> tdx_attest_error_t;
}
unsafe extern "C" {
    #[doc = " @brief Extend one of the TDX runtime measurement registers (RTMRs).\n\n RTMR[rtmr_index] = SHA384(RTMR[rtmr_index] || extend_data)\n rtmr_index and extend_data are fields in the structure that is an input of\n this API.\n This API does not return either the new or old value of the specified RTMR.\n The tdx_att_get_report API may be used for this.\n The input to this API includes a description of the “extend data”. This is\n intended to facilitate reconstruction of the RTMR value. This, in turn,\n suggests maintenance of an event log by the callee. Currently, event_data is\n not supported.\n\n @param p_rtmr_event [in] Pointer to structure that contains the index of the\n                          RTMR to extend, the data with which to extend it and\n                          a description of the data.\n @return TDX_ATTEST_SUCCESS: Successfully extended the RTMR.\n @return TDX_ATTEST_ERROR_INVALID_PARAMETER: p_rtmr_event == NULL\n @return TDX_ATTEST_ERROR_UNEXPECTED: An unexpected internal error occurred.\n @return TDX_ATTEST_ERROR_DEVICE_FAILURE: Failed to acess tdx attest device.\n @return TDX_ATTEST_ERROR_EXTEND_FAILURE: Failed to extend data.\n @return TDX_ATTEST_ERROR_NOT_SUPPORTED: p_rtmr_event->event_data_size != 0"]
    pub fn tdx_att_extend(p_rtmr_event: *const tdx_rtmr_event_t) -> tdx_attest_error_t;
}
unsafe extern "C" {
    #[doc = " @brief Retrieve the list of attestation key IDs supported by the platform.\n\n Specify p_att_key_id_list = NULL to learn the number of entries in the list.\n\n @param p_att_key_id_list [out] List of the attestation key IDs that the\n                                platform supports. May be NULL. If NULL, the\n                                API will return the number of entries in the\n                                list in the uint32_t pointed to by p_list_size\n @param p_list_size [in/out] As input, pointer to a uint32_t specifying the\n                             size of p_att_key_id_list in entries. As output,\n                             this function will place the required size, in\n                             entries, in the uint32_t pointed to by the\n                             p_list_size parameter. If this value changes, the\n                             new value will be the required size\n @return TDX_ATTEST_SUCCESS: att_key_id_list populated and p_list_size points\n                             to a uint32_t that indicates the number of\n                             entries.\n @return TDX_ATTEST_ERROR_INVALID_PARAMETER: The parameter is incorrect"]
    pub fn tdx_att_get_supported_att_key_ids(
        p_att_key_id_list: *mut tdx_uuid_t,
        p_list_size: *mut u32,
    ) -> tdx_attest_error_t;
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
