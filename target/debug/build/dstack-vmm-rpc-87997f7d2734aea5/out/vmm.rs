// This file is @generated by prost-build.
/// Aggregates runtime and provisioning state for a single CVM.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct VmInfo {
    /// Unique identifier for the VM
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub id: ::prost::alloc::string::String,
    /// Name of the VM
    #[prost(string, tag = "2")]
    #[serde(default)]
    pub name: ::prost::alloc::string::String,
    /// Current status of the VM (e.g., running, stopped)
    #[prost(string, tag = "3")]
    #[serde(default)]
    pub status: ::prost::alloc::string::String,
    /// Uptime in human-readable format
    #[prost(string, tag = "4")]
    #[serde(default)]
    pub uptime: ::prost::alloc::string::String,
    /// URL to the guest agent dashboard
    #[prost(string, optional, tag = "5")]
    #[serde(default)]
    pub app_url: ::core::option::Option<::prost::alloc::string::String>,
    /// App ID
    #[prost(string, tag = "6")]
    #[serde(default)]
    pub app_id: ::prost::alloc::string::String,
    /// Instance ID
    #[prost(string, optional, tag = "7")]
    #[serde(default)]
    pub instance_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Configuration of the VM
    #[prost(message, optional, tag = "8")]
    #[serde(default)]
    pub configuration: ::core::option::Option<VmConfiguration>,
    /// Exit time
    #[prost(string, optional, tag = "9")]
    #[serde(default)]
    pub exited_at: ::core::option::Option<::prost::alloc::string::String>,
    /// Boot progress
    #[prost(string, tag = "10")]
    #[serde(default)]
    pub boot_progress: ::prost::alloc::string::String,
    /// Boot error
    #[prost(string, tag = "11")]
    #[serde(default)]
    pub boot_error: ::prost::alloc::string::String,
    /// Shutdown progress
    #[prost(string, tag = "12")]
    #[serde(default)]
    pub shutdown_progress: ::prost::alloc::string::String,
    /// Image version
    #[prost(string, tag = "13")]
    #[serde(default)]
    pub image_version: ::prost::alloc::string::String,
    /// Events
    #[prost(message, repeated, tag = "14")]
    #[serde(default)]
    pub events: ::prost::alloc::vec::Vec<GuestEvent>,
}
/// Structured log or lifecycle event emitted by the guest or runtime.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GuestEvent {
    /// Event type, e.g. "boot_progress" or "shutdown".
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub event: ::prost::alloc::string::String,
    /// Human readable payload describing the event.
    #[prost(string, tag = "2")]
    #[serde(default)]
    pub body: ::prost::alloc::string::String,
    /// Timestamp in milliseconds since Unix epoch
    #[prost(uint64, tag = "3")]
    #[serde(default)]
    pub timestamp: u64,
}
/// Wrapper around a VM identifier to keep RPC signatures consistent.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct Id {
    /// Unique identifier for the VM
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub id: ::prost::alloc::string::String,
}
/// Stable hash of a compose spec used to detect drift between client and VMM.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct ComposeHash {
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub hash: ::prost::alloc::string::String,
}
/// Full desired state for provisioning or re-provisioning a CVM instance.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct VmConfiguration {
    /// Name of the VM
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub name: ::prost::alloc::string::String,
    /// Image to be used for the VM
    #[prost(string, tag = "2")]
    #[serde(default)]
    pub image: ::prost::alloc::string::String,
    /// Compose file to be used for the VM
    #[prost(string, tag = "3")]
    #[serde(default)]
    pub compose_file: ::prost::alloc::string::String,
    /// Number of vCPUs
    #[prost(uint32, tag = "4")]
    #[serde(default)]
    pub vcpu: u32,
    /// Memory in MB
    #[prost(uint32, tag = "5")]
    #[serde(default)]
    pub memory: u32,
    /// Disk size in GB
    #[prost(uint32, tag = "6")]
    #[serde(default)]
    pub disk_size: u32,
    /// Port mapping
    #[prost(message, repeated, tag = "7")]
    #[serde(default)]
    pub ports: ::prost::alloc::vec::Vec<PortMapping>,
    /// Encrypted environment variables
    #[prost(bytes = "vec", tag = "8")]
    #[serde(default)]
    pub encrypted_env: ::prost::alloc::vec::Vec<u8>,
    /// App ID.
    /// If not provided, it assumes the app is newly created.
    /// If provided, and KMS is enabled, it assumes the app is upgraded from given app_id.
    /// If provided, and KMS is disabled, it must equal to the actual app_id computed from compose_file, or the VM will fail to start.
    #[prost(string, optional, tag = "9")]
    #[serde(default)]
    pub app_id: ::core::option::Option<::prost::alloc::string::String>,
    /// User config that would be put at /dstack/.user-config in the CVM.
    #[prost(string, tag = "10")]
    #[serde(default)]
    pub user_config: ::prost::alloc::string::String,
    /// Hugepages enabled
    #[prost(bool, tag = "11")]
    #[serde(default)]
    pub hugepages: bool,
    /// Pin NUMA enabled
    #[prost(bool, tag = "12")]
    #[serde(default)]
    pub pin_numa: bool,
    /// Gpu config
    #[prost(message, optional, tag = "13")]
    #[serde(default)]
    pub gpus: ::core::option::Option<GpuConfig>,
    /// KMS URLs
    #[prost(string, repeated, tag = "14")]
    #[serde(default)]
    pub kms_urls: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Gateway URLs
    #[prost(string, repeated, tag = "15")]
    #[serde(default)]
    pub gateway_urls: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The VM is stopped
    #[prost(bool, tag = "16")]
    #[serde(default)]
    pub stopped: bool,
    /// Disable confidential computing (fallback to non-TEE VM).
    #[prost(bool, tag = "17")]
    #[serde(default)]
    pub no_tee: bool,
}
/// Requested GPU layout for a CVM.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GpuConfig {
    /// GPUs
    #[prost(message, repeated, tag = "1")]
    #[serde(default)]
    pub gpus: ::prost::alloc::vec::Vec<GpuSpec>,
    /// Gpu attach mode
    #[prost(string, tag = "2")]
    #[serde(default)]
    pub attach_mode: ::prost::alloc::string::String,
}
/// Identifies a physical GPU on the host.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GpuSpec {
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub slot: ::prost::alloc::string::String,
}
/// Describes how host ports are forwarded into the CVM network namespace.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct PortMapping {
    /// Protocol
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub protocol: ::prost::alloc::string::String,
    /// Host port
    #[prost(uint32, tag = "2")]
    #[serde(default)]
    pub host_port: u32,
    /// VM port
    #[prost(uint32, tag = "3")]
    #[serde(default)]
    pub vm_port: u32,
    /// Host address
    #[prost(string, tag = "4")]
    #[serde(default)]
    pub host_address: ::prost::alloc::string::String,
}
/// Partial configuration used when mutating an existing VM.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct UpdateVmRequest {
    /// ID of the VM
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub id: ::prost::alloc::string::String,
    /// Compose file to be used for the VM
    #[prost(string, tag = "2")]
    #[serde(default)]
    pub compose_file: ::prost::alloc::string::String,
    /// Optional update encrypted environment variables. Leave empty to not update.
    #[prost(bytes = "vec", tag = "3")]
    #[serde(default)]
    pub encrypted_env: ::prost::alloc::vec::Vec<u8>,
    /// Optional update user config. Leave empty to not update.
    #[prost(string, tag = "4")]
    #[serde(default)]
    pub user_config: ::prost::alloc::string::String,
    /// Optional update port mapping.
    #[prost(bool, tag = "5")]
    #[serde(default)]
    pub update_ports: bool,
    /// Port mapping
    #[prost(message, repeated, tag = "7")]
    #[serde(default)]
    pub ports: ::prost::alloc::vec::Vec<PortMapping>,
    /// Optional update KMS URLs.
    #[prost(bool, tag = "8")]
    #[serde(default)]
    pub update_kms_urls: bool,
    #[prost(string, repeated, tag = "9")]
    #[serde(default)]
    pub kms_urls: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional update gateway URLs.
    #[prost(bool, tag = "10")]
    #[serde(default)]
    pub update_gateway_urls: bool,
    #[prost(string, repeated, tag = "11")]
    #[serde(default)]
    pub gateway_urls: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// gpus
    #[prost(message, optional, tag = "13")]
    #[serde(default)]
    pub gpus: ::core::option::Option<GpuConfig>,
    /// Optional compute resource updates. Leave unset to keep current configuration.
    #[prost(uint32, optional, tag = "14")]
    #[serde(default)]
    pub vcpu: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "15")]
    #[serde(default)]
    pub memory: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "16")]
    #[serde(default)]
    pub disk_size: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "17")]
    #[serde(default)]
    pub image: ::core::option::Option<::prost::alloc::string::String>,
    /// Disable or re-enable TEE for an existing VM.
    #[prost(bool, optional, tag = "18")]
    #[serde(default)]
    pub no_tee: ::core::option::Option<bool>,
}
/// Parameters for listing CVMs with pagination and keyword filtering.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct StatusRequest {
    /// List of VM IDs
    #[prost(string, repeated, tag = "1")]
    #[serde(default)]
    pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Brief (Don't include VM configuration)
    #[prost(bool, tag = "2")]
    #[serde(default)]
    pub brief: bool,
    /// Filter by keyword
    #[prost(string, tag = "3")]
    #[serde(default)]
    pub keyword: ::prost::alloc::string::String,
    /// Page number
    #[prost(uint32, tag = "4")]
    #[serde(default)]
    pub page: u32,
    /// Page size
    #[prost(uint32, tag = "5")]
    #[serde(default)]
    pub page_size: u32,
}
/// Summary of the current fleet status.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct StatusResponse {
    /// List of VMs
    #[prost(message, repeated, tag = "1")]
    #[serde(default)]
    pub vms: ::prost::alloc::vec::Vec<VmInfo>,
    /// Port mapping enabled
    #[prost(bool, tag = "2")]
    #[serde(default)]
    pub port_mapping_enabled: bool,
    /// Total number of VMs
    #[prost(uint32, tag = "3")]
    #[serde(default)]
    pub total: u32,
}
/// Available base images for the VMM to launch.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct ImageListResponse {
    #[prost(message, repeated, tag = "1")]
    #[serde(default)]
    pub images: ::prost::alloc::vec::Vec<ImageInfo>,
}
/// Metadata describing an OCI image published to the cluster.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct ImageInfo {
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    #[serde(default)]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    #[serde(default)]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    #[serde(default)]
    pub is_dev: bool,
}
/// App identifier used for encrypting env vars and routing telemetry.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct AppId {
    #[prost(bytes = "vec", tag = "1")]
    #[serde(default)]
    pub app_id: ::prost::alloc::vec::Vec<u8>,
}
/// Response with the KMS-backed public key used for env encryption plus audit signature.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct PublicKeyResponse {
    #[prost(bytes = "vec", tag = "1")]
    #[serde(default)]
    pub public_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    #[serde(default)]
    pub signature: ::prost::alloc::vec::Vec<u8>,
}
/// Optional VM info payload returned by GetInfo.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetInfoResponse {
    #[prost(bool, tag = "1")]
    #[serde(default)]
    pub found: bool,
    #[prost(message, optional, tag = "2")]
    #[serde(default)]
    pub info: ::core::option::Option<VmInfo>,
}
/// Input used when resizing compute or storage for a VM.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct ResizeVmRequest {
    /// Unique identifier for the VM
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub id: ::prost::alloc::string::String,
    /// Number of vCPUs
    #[prost(uint32, optional, tag = "2")]
    #[serde(default)]
    pub vcpu: ::core::option::Option<u32>,
    /// Memory in MB
    #[prost(uint32, optional, tag = "3")]
    #[serde(default)]
    pub memory: ::core::option::Option<u32>,
    /// Disk size in GB
    #[prost(uint32, optional, tag = "4")]
    #[serde(default)]
    pub disk_size: ::core::option::Option<u32>,
    /// Image name
    #[prost(string, optional, tag = "5")]
    #[serde(default)]
    pub image: ::core::option::Option<::prost::alloc::string::String>,
}
/// Tunables for the KMS integration.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct KmsSettings {
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub url: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    #[serde(default)]
    pub urls: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Details about the HTTP gateway that fronts the CVMs.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GatewaySettings {
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub url: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    #[serde(default)]
    pub base_domain: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    #[serde(default)]
    pub port: u32,
    #[prost(uint32, tag = "4")]
    #[serde(default)]
    pub agent_port: u32,
    #[prost(string, repeated, tag = "5")]
    #[serde(default)]
    pub urls: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Capacity caps enforced by the scheduler.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResourcesSettings {
    /// equals to the cid pool size.
    #[prost(uint32, tag = "1")]
    #[serde(default)]
    pub max_cvm_number: u32,
    #[prost(uint32, tag = "2")]
    #[serde(default)]
    pub max_allocable_vcpu: u32,
    /// in MB.
    #[prost(uint32, tag = "3")]
    #[serde(default)]
    pub max_allocable_memory_in_mb: u32,
}
/// Aggregated metadata exposed through GetMeta.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetMetaResponse {
    #[prost(message, optional, tag = "1")]
    #[serde(default)]
    pub kms: ::core::option::Option<KmsSettings>,
    #[prost(message, optional, tag = "2")]
    #[serde(default)]
    pub gateway: ::core::option::Option<GatewaySettings>,
    #[prost(message, optional, tag = "3")]
    #[serde(default)]
    pub resources: ::core::option::Option<ResourcesSettings>,
}
/// Build information for the running VMM binary.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct VersionResponse {
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub version: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    #[serde(default)]
    pub rev: ::prost::alloc::string::String,
}
/// Available GPUs and policy flags.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct ListGpusResponse {
    #[prost(message, repeated, tag = "1")]
    #[serde(default)]
    pub gpus: ::prost::alloc::vec::Vec<GpuInfo>,
    #[prost(bool, tag = "2")]
    #[serde(default)]
    pub allow_attach_all: bool,
}
/// Counts applied when reloading persistent VM state from disk.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReloadVmsResponse {
    /// Number of VMs that were loaded
    #[prost(uint32, tag = "1")]
    #[serde(default)]
    pub loaded: u32,
    /// Number of VMs that were updated
    #[prost(uint32, tag = "2")]
    #[serde(default)]
    pub updated: u32,
    /// Number of VMs that were removed
    #[prost(uint32, tag = "3")]
    #[serde(default)]
    pub removed: u32,
}
/// Metadata for a single GPU discovered on the host.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GpuInfo {
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub slot: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    #[serde(default)]
    pub product_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    #[serde(default)]
    pub description: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    #[serde(default)]
    pub is_free: bool,
}
/// Generated client implementations.
pub mod vmm_client {
    /// Exposes lifecycle and metadata management RPCs for dstack-vmm.
    #[derive(Debug)]
    pub struct VmmClient<Client> {
        pub client: Client,
    }
    impl<Client> VmmClient<Client>
    where
        Client: ::prpc::client::RequestClient,
    {
        pub fn new(client: Client) -> Self {
            Self { client }
        }
        /// RPC to create a VM
        pub async fn create_vm(
            &self,
            request: super::VmConfiguration,
        ) -> Result<super::Id, ::prpc::client::Error> {
            self.client.request("CreateVm", request).await
        }
        /// RPC to start a VM
        pub async fn start_vm(&self, request: super::Id) -> Result<(), ::prpc::client::Error> {
            self.client.request("StartVm", request).await
        }
        /// RPC to stop a VM
        pub async fn stop_vm(&self, request: super::Id) -> Result<(), ::prpc::client::Error> {
            self.client.request("StopVm", request).await
        }
        /// RPC to remove a VM
        pub async fn remove_vm(&self, request: super::Id) -> Result<(), ::prpc::client::Error> {
            self.client.request("RemoveVm", request).await
        }
        /// RPC to upgrade an app. Deprecated, use UpdateVm instead.
        pub async fn upgrade_app(
            &self,
            request: super::UpdateVmRequest,
        ) -> Result<super::Id, ::prpc::client::Error> {
            self.client.request("UpgradeApp", request).await
        }
        /// RPC to update a VM
        pub async fn update_vm(
            &self,
            request: super::UpdateVmRequest,
        ) -> Result<super::Id, ::prpc::client::Error> {
            self.client.request("UpdateVm", request).await
        }
        /// Shutdown a VM
        pub async fn shutdown_vm(&self, request: super::Id) -> Result<(), ::prpc::client::Error> {
            self.client.request("ShutdownVm", request).await
        }
        /// RPC to resize a VM. Deprecated, use UpdateVm instead.
        pub async fn resize_vm(
            &self,
            request: super::ResizeVmRequest,
        ) -> Result<(), ::prpc::client::Error> {
            self.client.request("ResizeVm", request).await
        }
        /// RPC to compute the compose hash, it's helpful for debugging & developing SDK.
        pub async fn get_compose_hash(
            &self,
            request: super::VmConfiguration,
        ) -> Result<super::ComposeHash, ::prpc::client::Error> {
            self.client.request("GetComposeHash", request).await
        }
        /// RPC to list all VMs
        pub async fn status(
            &self,
            request: super::StatusRequest,
        ) -> Result<super::StatusResponse, ::prpc::client::Error> {
            self.client.request("Status", request).await
        }
        /// RPC to list all available images
        pub async fn list_images(&self) -> Result<super::ImageListResponse, ::prpc::client::Error> {
            let request = ();
            self.client.request("ListImages", request).await
        }
        /// Get Env encrypt public key
        pub async fn get_app_env_encrypt_pub_key(
            &self,
            request: super::AppId,
        ) -> Result<super::PublicKeyResponse, ::prpc::client::Error> {
            self.client.request("GetAppEnvEncryptPubKey", request).await
        }
        /// Get VM info by ID
        pub async fn get_info(
            &self,
            request: super::Id,
        ) -> Result<super::GetInfoResponse, ::prpc::client::Error> {
            self.client.request("GetInfo", request).await
        }
        /// Get version info of the dstack-vmm
        pub async fn version(&self) -> Result<super::VersionResponse, ::prpc::client::Error> {
            let request = ();
            self.client.request("Version", request).await
        }
        /// Get version info of the dstack-vmm
        pub async fn get_meta(&self) -> Result<super::GetMetaResponse, ::prpc::client::Error> {
            let request = ();
            self.client.request("GetMeta", request).await
        }
        /// List GPUs
        pub async fn list_gpus(&self) -> Result<super::ListGpusResponse, ::prpc::client::Error> {
            let request = ();
            self.client.request("ListGpus", request).await
        }
        /// Reload VMs directory and sync with memory state
        pub async fn reload_vms(&self) -> Result<super::ReloadVmsResponse, ::prpc::client::Error> {
            let request = ();
            self.client.request("ReloadVms", request).await
        }
    }
}
/// Generated server implementations.
pub mod vmm_server {
    use alloc::vec::Vec;
    pub enum VmmMethod {
        CreateVm,
        StartVm,
        StopVm,
        RemoveVm,
        UpgradeApp,
        UpdateVm,
        ShutdownVm,
        ResizeVm,
        GetComposeHash,
        Status,
        ListImages,
        GetAppEnvEncryptPubKey,
        GetInfo,
        Version,
        GetMeta,
        ListGpus,
        ReloadVms,
    }
    impl VmmMethod {
        #[allow(clippy::should_implement_trait)]
        pub fn from_str(path: &str) -> Option<Self> {
            match path {
                "CreateVm" => Some(Self::CreateVm),
                "StartVm" => Some(Self::StartVm),
                "StopVm" => Some(Self::StopVm),
                "RemoveVm" => Some(Self::RemoveVm),
                "UpgradeApp" => Some(Self::UpgradeApp),
                "UpdateVm" => Some(Self::UpdateVm),
                "ShutdownVm" => Some(Self::ShutdownVm),
                "ResizeVm" => Some(Self::ResizeVm),
                "GetComposeHash" => Some(Self::GetComposeHash),
                "Status" => Some(Self::Status),
                "ListImages" => Some(Self::ListImages),
                "GetAppEnvEncryptPubKey" => Some(Self::GetAppEnvEncryptPubKey),
                "GetInfo" => Some(Self::GetInfo),
                "Version" => Some(Self::Version),
                "GetMeta" => Some(Self::GetMeta),
                "ListGpus" => Some(Self::ListGpus),
                "ReloadVms" => Some(Self::ReloadVms),
                _ => None,
            }
        }
    }
    ///Generated trait containing RPC methods that should be implemented for use with VmmServer.
    pub trait VmmRpc {
        /// RPC to create a VM
        async fn create_vm(self, request: super::VmConfiguration) -> ::anyhow::Result<super::Id>;
        /// RPC to start a VM
        async fn start_vm(self, request: super::Id) -> ::anyhow::Result<()>;
        /// RPC to stop a VM
        async fn stop_vm(self, request: super::Id) -> ::anyhow::Result<()>;
        /// RPC to remove a VM
        async fn remove_vm(self, request: super::Id) -> ::anyhow::Result<()>;
        /// RPC to upgrade an app. Deprecated, use UpdateVm instead.
        async fn upgrade_app(self, request: super::UpdateVmRequest) -> ::anyhow::Result<super::Id>;
        /// RPC to update a VM
        async fn update_vm(self, request: super::UpdateVmRequest) -> ::anyhow::Result<super::Id>;
        /// Shutdown a VM
        async fn shutdown_vm(self, request: super::Id) -> ::anyhow::Result<()>;
        /// RPC to resize a VM. Deprecated, use UpdateVm instead.
        async fn resize_vm(self, request: super::ResizeVmRequest) -> ::anyhow::Result<()>;
        /// RPC to compute the compose hash, it's helpful for debugging & developing SDK.
        async fn get_compose_hash(
            self,
            request: super::VmConfiguration,
        ) -> ::anyhow::Result<super::ComposeHash>;
        /// RPC to list all VMs
        async fn status(
            self,
            request: super::StatusRequest,
        ) -> ::anyhow::Result<super::StatusResponse>;
        /// RPC to list all available images
        async fn list_images(self) -> ::anyhow::Result<super::ImageListResponse>;
        /// Get Env encrypt public key
        async fn get_app_env_encrypt_pub_key(
            self,
            request: super::AppId,
        ) -> ::anyhow::Result<super::PublicKeyResponse>;
        /// Get VM info by ID
        async fn get_info(self, request: super::Id) -> ::anyhow::Result<super::GetInfoResponse>;
        /// Get version info of the dstack-vmm
        async fn version(self) -> ::anyhow::Result<super::VersionResponse>;
        /// Get version info of the dstack-vmm
        async fn get_meta(self) -> ::anyhow::Result<super::GetMetaResponse>;
        /// List GPUs
        async fn list_gpus(self) -> ::anyhow::Result<super::ListGpusResponse>;
        /// Reload VMs directory and sync with memory state
        async fn reload_vms(self) -> ::anyhow::Result<super::ReloadVmsResponse>;
    }
    /// Exposes lifecycle and metadata management RPCs for dstack-vmm.
    #[derive(Debug)]
    pub struct VmmServer<T: VmmRpc> {
        inner: T,
    }
    impl<T: VmmRpc> VmmServer<T> {
        pub fn new(inner: T) -> Self {
            Self { inner }
        }
        pub async fn dispatch_request(
            self,
            path: &str,
            _data: impl AsRef<[u8]>,
        ) -> Result<Vec<u8>, ::prpc::server::Error> {
            #![allow(clippy::let_unit_value)]
            match path {
                "CreateVm" => {
                    let input: super::VmConfiguration = ::prpc::Message::decode(_data.as_ref())?;
                    let response = self.inner.create_vm(input).await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "StartVm" => {
                    let input: super::Id = ::prpc::Message::decode(_data.as_ref())?;
                    let response = self.inner.start_vm(input).await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "StopVm" => {
                    let input: super::Id = ::prpc::Message::decode(_data.as_ref())?;
                    let response = self.inner.stop_vm(input).await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "RemoveVm" => {
                    let input: super::Id = ::prpc::Message::decode(_data.as_ref())?;
                    let response = self.inner.remove_vm(input).await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "UpgradeApp" => {
                    let input: super::UpdateVmRequest = ::prpc::Message::decode(_data.as_ref())?;
                    let response = self.inner.upgrade_app(input).await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "UpdateVm" => {
                    let input: super::UpdateVmRequest = ::prpc::Message::decode(_data.as_ref())?;
                    let response = self.inner.update_vm(input).await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "ShutdownVm" => {
                    let input: super::Id = ::prpc::Message::decode(_data.as_ref())?;
                    let response = self.inner.shutdown_vm(input).await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "ResizeVm" => {
                    let input: super::ResizeVmRequest = ::prpc::Message::decode(_data.as_ref())?;
                    let response = self.inner.resize_vm(input).await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "GetComposeHash" => {
                    let input: super::VmConfiguration = ::prpc::Message::decode(_data.as_ref())?;
                    let response = self.inner.get_compose_hash(input).await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "Status" => {
                    let input: super::StatusRequest = ::prpc::Message::decode(_data.as_ref())?;
                    let response = self.inner.status(input).await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "ListImages" => {
                    let response = self.inner.list_images().await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "GetAppEnvEncryptPubKey" => {
                    let input: super::AppId = ::prpc::Message::decode(_data.as_ref())?;
                    let response = self.inner.get_app_env_encrypt_pub_key(input).await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "GetInfo" => {
                    let input: super::Id = ::prpc::Message::decode(_data.as_ref())?;
                    let response = self.inner.get_info(input).await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "Version" => {
                    let response = self.inner.version().await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "GetMeta" => {
                    let response = self.inner.get_meta().await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "ListGpus" => {
                    let response = self.inner.list_gpus().await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "ReloadVms" => {
                    let response = self.inner.reload_vms().await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                _ => anyhow::bail!("Service not found: {path}"),
            }
        }
        pub async fn dispatch_json_request(
            self,
            path: &str,
            _data: impl AsRef<[u8]>,
            _query: bool,
        ) -> Result<Vec<u8>, ::prpc::server::Error> {
            #![allow(clippy::let_unit_value)]
            match path {
                "CreateVm" => {
                    let data = _data.as_ref();
                    let input: super::VmConfiguration = if data.is_empty() {
                        Default::default()
                    } else if _query {
                        ::prpc::serde_qs::from_bytes(data)?
                    } else {
                        ::prpc::serde_json::from_slice(data)?
                    };
                    let response = self.inner.create_vm(input).await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "StartVm" => {
                    let data = _data.as_ref();
                    let input: super::Id = if data.is_empty() {
                        Default::default()
                    } else if _query {
                        ::prpc::serde_qs::from_bytes(data)?
                    } else {
                        ::prpc::serde_json::from_slice(data)?
                    };
                    let response = self.inner.start_vm(input).await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "StopVm" => {
                    let data = _data.as_ref();
                    let input: super::Id = if data.is_empty() {
                        Default::default()
                    } else if _query {
                        ::prpc::serde_qs::from_bytes(data)?
                    } else {
                        ::prpc::serde_json::from_slice(data)?
                    };
                    let response = self.inner.stop_vm(input).await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "RemoveVm" => {
                    let data = _data.as_ref();
                    let input: super::Id = if data.is_empty() {
                        Default::default()
                    } else if _query {
                        ::prpc::serde_qs::from_bytes(data)?
                    } else {
                        ::prpc::serde_json::from_slice(data)?
                    };
                    let response = self.inner.remove_vm(input).await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "UpgradeApp" => {
                    let data = _data.as_ref();
                    let input: super::UpdateVmRequest = if data.is_empty() {
                        Default::default()
                    } else if _query {
                        ::prpc::serde_qs::from_bytes(data)?
                    } else {
                        ::prpc::serde_json::from_slice(data)?
                    };
                    let response = self.inner.upgrade_app(input).await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "UpdateVm" => {
                    let data = _data.as_ref();
                    let input: super::UpdateVmRequest = if data.is_empty() {
                        Default::default()
                    } else if _query {
                        ::prpc::serde_qs::from_bytes(data)?
                    } else {
                        ::prpc::serde_json::from_slice(data)?
                    };
                    let response = self.inner.update_vm(input).await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "ShutdownVm" => {
                    let data = _data.as_ref();
                    let input: super::Id = if data.is_empty() {
                        Default::default()
                    } else if _query {
                        ::prpc::serde_qs::from_bytes(data)?
                    } else {
                        ::prpc::serde_json::from_slice(data)?
                    };
                    let response = self.inner.shutdown_vm(input).await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "ResizeVm" => {
                    let data = _data.as_ref();
                    let input: super::ResizeVmRequest = if data.is_empty() {
                        Default::default()
                    } else if _query {
                        ::prpc::serde_qs::from_bytes(data)?
                    } else {
                        ::prpc::serde_json::from_slice(data)?
                    };
                    let response = self.inner.resize_vm(input).await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "GetComposeHash" => {
                    let data = _data.as_ref();
                    let input: super::VmConfiguration = if data.is_empty() {
                        Default::default()
                    } else if _query {
                        ::prpc::serde_qs::from_bytes(data)?
                    } else {
                        ::prpc::serde_json::from_slice(data)?
                    };
                    let response = self.inner.get_compose_hash(input).await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "Status" => {
                    let data = _data.as_ref();
                    let input: super::StatusRequest = if data.is_empty() {
                        Default::default()
                    } else if _query {
                        ::prpc::serde_qs::from_bytes(data)?
                    } else {
                        ::prpc::serde_json::from_slice(data)?
                    };
                    let response = self.inner.status(input).await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "ListImages" => {
                    let response = self.inner.list_images().await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "GetAppEnvEncryptPubKey" => {
                    let data = _data.as_ref();
                    let input: super::AppId = if data.is_empty() {
                        Default::default()
                    } else if _query {
                        ::prpc::serde_qs::from_bytes(data)?
                    } else {
                        ::prpc::serde_json::from_slice(data)?
                    };
                    let response = self.inner.get_app_env_encrypt_pub_key(input).await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "GetInfo" => {
                    let data = _data.as_ref();
                    let input: super::Id = if data.is_empty() {
                        Default::default()
                    } else if _query {
                        ::prpc::serde_qs::from_bytes(data)?
                    } else {
                        ::prpc::serde_json::from_slice(data)?
                    };
                    let response = self.inner.get_info(input).await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "Version" => {
                    let response = self.inner.version().await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "GetMeta" => {
                    let response = self.inner.get_meta().await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "ListGpus" => {
                    let response = self.inner.list_gpus().await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "ReloadVms" => {
                    let response = self.inner.reload_vms().await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                _ => anyhow::bail!("Service not found: {path}"),
            }
        }
        pub fn supported_methods() -> &'static [&'static str] {
            &[
                "CreateVm",
                "StartVm",
                "StopVm",
                "RemoveVm",
                "UpgradeApp",
                "UpdateVm",
                "ShutdownVm",
                "ResizeVm",
                "GetComposeHash",
                "Status",
                "ListImages",
                "GetAppEnvEncryptPubKey",
                "GetInfo",
                "Version",
                "GetMeta",
                "ListGpus",
                "ReloadVms",
            ]
        }
    }
    impl<T: VmmRpc> ::prpc::server::NamedService for VmmServer<T> {
        const NAME: &'static str = "Vmm";
    }
    impl<T: VmmRpc> ::prpc::server::Service for VmmServer<T> {
        type Methods = &'static [&'static str];
        fn methods() -> Self::Methods {
            Self::supported_methods()
        }
        async fn dispatch_request(
            self,
            path: &str,
            data: impl AsRef<[u8]>,
            json: bool,
            query: bool,
        ) -> Result<Vec<u8>, ::prpc::server::Error> {
            if json {
                self.dispatch_json_request(path, data, query).await
            } else {
                self.dispatch_request(path, data).await
            }
        }
    }
    impl<T: VmmRpc> From<T> for VmmServer<T> {
        fn from(inner: T) -> Self {
            Self::new(inner)
        }
    }
}
