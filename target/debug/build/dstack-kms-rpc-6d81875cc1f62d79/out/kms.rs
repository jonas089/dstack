// This file is @generated by prost-build.
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetAppKeyRequest {
    #[prost(uint32, tag = "1")]
    #[serde(default)]
    pub api_version: u32,
    #[prost(string, tag = "2")]
    #[serde(default)]
    pub vm_config: ::prost::alloc::string::String,
}
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct AppId {
    #[prost(bytes = "vec", tag = "1")]
    #[serde(default)]
    pub app_id: ::prost::alloc::vec::Vec<u8>,
}
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct PublicKeyResponse {
    #[prost(bytes = "vec", tag = "1")]
    #[serde(default)]
    pub public_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    #[serde(default)]
    pub signature: ::prost::alloc::vec::Vec<u8>,
}
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct AppKeyResponse {
    /// TLS CA certificate which is used as the trust anchor for all HTTPS RPCs in the system.
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub ca_cert: ::prost::alloc::string::String,
    /// Disk encryption key used as the key phrase for the App's full disk encryption.
    #[prost(bytes = "vec", tag = "2")]
    #[serde(default)]
    pub disk_crypt_key: ::prost::alloc::vec::Vec<u8>,
    /// X25519 key for decrypting secret environment variables.
    #[prost(bytes = "vec", tag = "3")]
    #[serde(default)]
    pub env_crypt_key: ::prost::alloc::vec::Vec<u8>,
    /// ECDSA key for app's Ethereum-compatible signing operations.
    #[prost(bytes = "vec", tag = "4")]
    #[serde(default)]
    pub k256_key: ::prost::alloc::vec::Vec<u8>,
    /// Signature of the k256 key signed by the root k256 key.
    #[prost(bytes = "vec", tag = "5")]
    #[serde(default)]
    pub k256_signature: ::prost::alloc::vec::Vec<u8>,
    /// Reverse proxy app ID from DstackKms contract. (Deprecated. For backward compatibility)
    #[prost(string, tag = "6")]
    #[serde(default)]
    pub tproxy_app_id: ::prost::alloc::string::String,
    /// Reverse proxy app ID from DstackKms contract.
    #[prost(string, tag = "7")]
    #[serde(default)]
    pub gateway_app_id: ::prost::alloc::string::String,
    /// OS Image hash
    #[prost(bytes = "vec", tag = "8")]
    #[serde(default)]
    pub os_image_hash: ::prost::alloc::vec::Vec<u8>,
}
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetMetaResponse {
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub ca_cert: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    #[serde(default)]
    pub allow_any_upgrade: bool,
    #[prost(bytes = "vec", tag = "3")]
    #[serde(default)]
    pub k256_pubkey: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "4")]
    #[serde(default)]
    pub bootstrap_info: ::core::option::Option<BootstrapResponse>,
    #[prost(bool, tag = "5")]
    #[serde(default)]
    pub is_dev: bool,
    #[prost(string, optional, tag = "6")]
    #[serde(default)]
    pub gateway_app_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "7")]
    #[serde(default)]
    pub kms_contract_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "8")]
    #[serde(default)]
    pub chain_id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "9")]
    #[serde(default)]
    pub app_auth_implementation: ::core::option::Option<::prost::alloc::string::String>,
}
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetKmsKeyRequest {
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub vm_config: ::prost::alloc::string::String,
}
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct KmsKeys {
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub ca_key: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    #[serde(default)]
    pub k256_key: ::prost::alloc::vec::Vec<u8>,
}
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct KmsKeyResponse {
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub temp_ca_key: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    #[serde(default)]
    pub keys: ::prost::alloc::vec::Vec<KmsKeys>,
}
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetTempCaCertResponse {
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub temp_ca_cert: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    #[serde(default)]
    pub temp_ca_key: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    #[serde(default)]
    pub ca_cert: ::prost::alloc::string::String,
}
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SignCertRequest {
    #[prost(uint32, tag = "1")]
    #[serde(default)]
    pub api_version: u32,
    #[prost(bytes = "vec", tag = "2")]
    #[serde(default)]
    pub csr: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    #[serde(default)]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "4")]
    #[serde(default)]
    pub vm_config: ::prost::alloc::string::String,
}
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SignCertResponse {
    #[prost(string, repeated, tag = "1")]
    #[serde(default)]
    pub certificate_chain: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct ClearImageCacheRequest {
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub token: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    #[serde(default)]
    pub image_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    #[serde(default)]
    pub config_hash: ::prost::alloc::string::String,
}
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct BootstrapRequest {
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub domain: ::prost::alloc::string::String,
}
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct BootstrapResponse {
    #[prost(bytes = "vec", tag = "1")]
    #[serde(default)]
    pub ca_pubkey: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    #[serde(default)]
    pub k256_pubkey: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    #[serde(default)]
    pub quote: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "4")]
    #[serde(default)]
    pub eventlog: ::prost::alloc::vec::Vec<u8>,
}
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct OnboardRequest {
    #[prost(string, tag = "1")]
    #[serde(default)]
    pub source_url: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    #[serde(default)]
    pub domain: ::prost::alloc::string::String,
}
#[::prpc::serde_helpers::prpc_serde_bytes]
#[derive(::serde::Serialize, ::serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct OnboardResponse {}
/// Generated client implementations.
pub mod kms_client {
    /// The kms public RPC service.
    #[derive(Debug)]
    pub struct KmsClient<Client> {
        pub client: Client,
    }
    impl<Client> KmsClient<Client>
    where
        Client: ::prpc::client::RequestClient,
    {
        pub fn new(client: Client) -> Self {
            Self { client }
        }
        /// Request the app key given the app id and tdx quote
        pub async fn get_app_key(
            &self,
            request: super::GetAppKeyRequest,
        ) -> Result<super::AppKeyResponse, ::prpc::client::Error> {
            self.client.request("GetAppKey", request).await
        }
        /// KMS key handover
        pub async fn get_kms_key(
            &self,
            request: super::GetKmsKeyRequest,
        ) -> Result<super::KmsKeyResponse, ::prpc::client::Error> {
            self.client.request("GetKmsKey", request).await
        }
        /// Request the app environment encryption public key given the app id
        pub async fn get_app_env_encrypt_pub_key(
            &self,
            request: super::AppId,
        ) -> Result<super::PublicKeyResponse, ::prpc::client::Error> {
            self.client.request("GetAppEnvEncryptPubKey", request).await
        }
        /// Request the KMS instance metadata for use as a probe and health check.
        pub async fn get_meta(&self) -> Result<super::GetMetaResponse, ::prpc::client::Error> {
            let request = ();
            self.client.request("GetMeta", request).await
        }
        /// Request the temporary CA certificate and key
        pub async fn get_temp_ca_cert(
            &self,
        ) -> Result<super::GetTempCaCertResponse, ::prpc::client::Error> {
            let request = ();
            self.client.request("GetTempCaCert", request).await
        }
        /// Sign a certificate
        pub async fn sign_cert(
            &self,
            request: super::SignCertRequest,
        ) -> Result<super::SignCertResponse, ::prpc::client::Error> {
            self.client.request("SignCert", request).await
        }
        /// Clear the image cache
        pub async fn clear_image_cache(
            &self,
            request: super::ClearImageCacheRequest,
        ) -> Result<(), ::prpc::client::Error> {
            self.client.request("ClearImageCache", request).await
        }
    }
}
/// Generated client implementations.
pub mod onboard_client {
    /// The Onboard RPC service.
    #[derive(Debug)]
    pub struct OnboardClient<Client> {
        pub client: Client,
    }
    impl<Client> OnboardClient<Client>
    where
        Client: ::prpc::client::RequestClient,
    {
        pub fn new(client: Client) -> Self {
            Self { client }
        }
        /// Bootstrap a new KMS
        pub async fn bootstrap(
            &self,
            request: super::BootstrapRequest,
        ) -> Result<super::BootstrapResponse, ::prpc::client::Error> {
            self.client.request("Bootstrap", request).await
        }
        /// Onboard from existing KMS
        pub async fn onboard(
            &self,
            request: super::OnboardRequest,
        ) -> Result<super::OnboardResponse, ::prpc::client::Error> {
            self.client.request("Onboard", request).await
        }
        /// Finish onboarding
        pub async fn finish(&self) -> Result<(), ::prpc::client::Error> {
            let request = ();
            self.client.request("Finish", request).await
        }
    }
}
/// Generated server implementations.
pub mod kms_server {
    use alloc::vec::Vec;
    pub enum KMSMethod {
        GetAppKey,
        GetKmsKey,
        GetAppEnvEncryptPubKey,
        GetMeta,
        GetTempCaCert,
        SignCert,
        ClearImageCache,
    }
    impl KMSMethod {
        #[allow(clippy::should_implement_trait)]
        pub fn from_str(path: &str) -> Option<Self> {
            match path {
                "GetAppKey" => Some(Self::GetAppKey),
                "GetKmsKey" => Some(Self::GetKmsKey),
                "GetAppEnvEncryptPubKey" => Some(Self::GetAppEnvEncryptPubKey),
                "GetMeta" => Some(Self::GetMeta),
                "GetTempCaCert" => Some(Self::GetTempCaCert),
                "SignCert" => Some(Self::SignCert),
                "ClearImageCache" => Some(Self::ClearImageCache),
                _ => None,
            }
        }
    }
    ///Generated trait containing RPC methods that should be implemented for use with KmsServer.
    pub trait KmsRpc {
        /// Request the app key given the app id and tdx quote
        async fn get_app_key(
            self,
            request: super::GetAppKeyRequest,
        ) -> ::anyhow::Result<super::AppKeyResponse>;
        /// KMS key handover
        async fn get_kms_key(
            self,
            request: super::GetKmsKeyRequest,
        ) -> ::anyhow::Result<super::KmsKeyResponse>;
        /// Request the app environment encryption public key given the app id
        async fn get_app_env_encrypt_pub_key(
            self,
            request: super::AppId,
        ) -> ::anyhow::Result<super::PublicKeyResponse>;
        /// Request the KMS instance metadata for use as a probe and health check.
        async fn get_meta(self) -> ::anyhow::Result<super::GetMetaResponse>;
        /// Request the temporary CA certificate and key
        async fn get_temp_ca_cert(self) -> ::anyhow::Result<super::GetTempCaCertResponse>;
        /// Sign a certificate
        async fn sign_cert(
            self,
            request: super::SignCertRequest,
        ) -> ::anyhow::Result<super::SignCertResponse>;
        /// Clear the image cache
        async fn clear_image_cache(
            self,
            request: super::ClearImageCacheRequest,
        ) -> ::anyhow::Result<()>;
    }
    /// The kms public RPC service.
    #[derive(Debug)]
    pub struct KmsServer<T: KmsRpc> {
        inner: T,
    }
    impl<T: KmsRpc> KmsServer<T> {
        pub fn new(inner: T) -> Self {
            Self { inner }
        }
        pub async fn dispatch_request(
            self,
            path: &str,
            _data: impl AsRef<[u8]>,
        ) -> Result<Vec<u8>, ::prpc::server::Error> {
            #![allow(clippy::let_unit_value)]
            match path {
                "GetAppKey" => {
                    let input: super::GetAppKeyRequest = ::prpc::Message::decode(_data.as_ref())?;
                    let response = self.inner.get_app_key(input).await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "GetKmsKey" => {
                    let input: super::GetKmsKeyRequest = ::prpc::Message::decode(_data.as_ref())?;
                    let response = self.inner.get_kms_key(input).await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "GetAppEnvEncryptPubKey" => {
                    let input: super::AppId = ::prpc::Message::decode(_data.as_ref())?;
                    let response = self.inner.get_app_env_encrypt_pub_key(input).await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "GetMeta" => {
                    let response = self.inner.get_meta().await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "GetTempCaCert" => {
                    let response = self.inner.get_temp_ca_cert().await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "SignCert" => {
                    let input: super::SignCertRequest = ::prpc::Message::decode(_data.as_ref())?;
                    let response = self.inner.sign_cert(input).await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "ClearImageCache" => {
                    let input: super::ClearImageCacheRequest =
                        ::prpc::Message::decode(_data.as_ref())?;
                    let response = self.inner.clear_image_cache(input).await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                _ => anyhow::bail!("Service not found: {path}"),
            }
        }
        pub async fn dispatch_json_request(
            self,
            path: &str,
            _data: impl AsRef<[u8]>,
            _query: bool,
        ) -> Result<Vec<u8>, ::prpc::server::Error> {
            #![allow(clippy::let_unit_value)]
            match path {
                "GetAppKey" => {
                    let data = _data.as_ref();
                    let input: super::GetAppKeyRequest = if data.is_empty() {
                        Default::default()
                    } else if _query {
                        ::prpc::serde_qs::from_bytes(data)?
                    } else {
                        ::prpc::serde_json::from_slice(data)?
                    };
                    let response = self.inner.get_app_key(input).await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "GetKmsKey" => {
                    let data = _data.as_ref();
                    let input: super::GetKmsKeyRequest = if data.is_empty() {
                        Default::default()
                    } else if _query {
                        ::prpc::serde_qs::from_bytes(data)?
                    } else {
                        ::prpc::serde_json::from_slice(data)?
                    };
                    let response = self.inner.get_kms_key(input).await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "GetAppEnvEncryptPubKey" => {
                    let data = _data.as_ref();
                    let input: super::AppId = if data.is_empty() {
                        Default::default()
                    } else if _query {
                        ::prpc::serde_qs::from_bytes(data)?
                    } else {
                        ::prpc::serde_json::from_slice(data)?
                    };
                    let response = self.inner.get_app_env_encrypt_pub_key(input).await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "GetMeta" => {
                    let response = self.inner.get_meta().await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "GetTempCaCert" => {
                    let response = self.inner.get_temp_ca_cert().await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "SignCert" => {
                    let data = _data.as_ref();
                    let input: super::SignCertRequest = if data.is_empty() {
                        Default::default()
                    } else if _query {
                        ::prpc::serde_qs::from_bytes(data)?
                    } else {
                        ::prpc::serde_json::from_slice(data)?
                    };
                    let response = self.inner.sign_cert(input).await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "ClearImageCache" => {
                    let data = _data.as_ref();
                    let input: super::ClearImageCacheRequest = if data.is_empty() {
                        Default::default()
                    } else if _query {
                        ::prpc::serde_qs::from_bytes(data)?
                    } else {
                        ::prpc::serde_json::from_slice(data)?
                    };
                    let response = self.inner.clear_image_cache(input).await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                _ => anyhow::bail!("Service not found: {path}"),
            }
        }
        pub fn supported_methods() -> &'static [&'static str] {
            &[
                "GetAppKey",
                "GetKmsKey",
                "GetAppEnvEncryptPubKey",
                "GetMeta",
                "GetTempCaCert",
                "SignCert",
                "ClearImageCache",
            ]
        }
    }
    impl<T: KmsRpc> ::prpc::server::NamedService for KmsServer<T> {
        const NAME: &'static str = "Kms";
    }
    impl<T: KmsRpc> ::prpc::server::Service for KmsServer<T> {
        type Methods = &'static [&'static str];
        fn methods() -> Self::Methods {
            Self::supported_methods()
        }
        async fn dispatch_request(
            self,
            path: &str,
            data: impl AsRef<[u8]>,
            json: bool,
            query: bool,
        ) -> Result<Vec<u8>, ::prpc::server::Error> {
            if json {
                self.dispatch_json_request(path, data, query).await
            } else {
                self.dispatch_request(path, data).await
            }
        }
    }
    impl<T: KmsRpc> From<T> for KmsServer<T> {
        fn from(inner: T) -> Self {
            Self::new(inner)
        }
    }
}
/// Generated server implementations.
pub mod onboard_server {
    use alloc::vec::Vec;
    pub enum OnboardMethod {
        Bootstrap,
        Onboard,
        Finish,
    }
    impl OnboardMethod {
        #[allow(clippy::should_implement_trait)]
        pub fn from_str(path: &str) -> Option<Self> {
            match path {
                "Bootstrap" => Some(Self::Bootstrap),
                "Onboard" => Some(Self::Onboard),
                "Finish" => Some(Self::Finish),
                _ => None,
            }
        }
    }
    ///Generated trait containing RPC methods that should be implemented for use with OnboardServer.
    pub trait OnboardRpc {
        /// Bootstrap a new KMS
        async fn bootstrap(
            self,
            request: super::BootstrapRequest,
        ) -> ::anyhow::Result<super::BootstrapResponse>;
        /// Onboard from existing KMS
        async fn onboard(
            self,
            request: super::OnboardRequest,
        ) -> ::anyhow::Result<super::OnboardResponse>;
        /// Finish onboarding
        async fn finish(self) -> ::anyhow::Result<()>;
    }
    /// The Onboard RPC service.
    #[derive(Debug)]
    pub struct OnboardServer<T: OnboardRpc> {
        inner: T,
    }
    impl<T: OnboardRpc> OnboardServer<T> {
        pub fn new(inner: T) -> Self {
            Self { inner }
        }
        pub async fn dispatch_request(
            self,
            path: &str,
            _data: impl AsRef<[u8]>,
        ) -> Result<Vec<u8>, ::prpc::server::Error> {
            #![allow(clippy::let_unit_value)]
            match path {
                "Bootstrap" => {
                    let input: super::BootstrapRequest = ::prpc::Message::decode(_data.as_ref())?;
                    let response = self.inner.bootstrap(input).await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "Onboard" => {
                    let input: super::OnboardRequest = ::prpc::Message::decode(_data.as_ref())?;
                    let response = self.inner.onboard(input).await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                "Finish" => {
                    let response = self.inner.finish().await?;
                    Ok(::prpc::codec::encode_message_to_vec(&response))
                }
                _ => anyhow::bail!("Service not found: {path}"),
            }
        }
        pub async fn dispatch_json_request(
            self,
            path: &str,
            _data: impl AsRef<[u8]>,
            _query: bool,
        ) -> Result<Vec<u8>, ::prpc::server::Error> {
            #![allow(clippy::let_unit_value)]
            match path {
                "Bootstrap" => {
                    let data = _data.as_ref();
                    let input: super::BootstrapRequest = if data.is_empty() {
                        Default::default()
                    } else if _query {
                        ::prpc::serde_qs::from_bytes(data)?
                    } else {
                        ::prpc::serde_json::from_slice(data)?
                    };
                    let response = self.inner.bootstrap(input).await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "Onboard" => {
                    let data = _data.as_ref();
                    let input: super::OnboardRequest = if data.is_empty() {
                        Default::default()
                    } else if _query {
                        ::prpc::serde_qs::from_bytes(data)?
                    } else {
                        ::prpc::serde_json::from_slice(data)?
                    };
                    let response = self.inner.onboard(input).await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                "Finish" => {
                    let response = self.inner.finish().await?;
                    Ok(serde_json::to_vec(&response)?)
                }
                _ => anyhow::bail!("Service not found: {path}"),
            }
        }
        pub fn supported_methods() -> &'static [&'static str] {
            &["Bootstrap", "Onboard", "Finish"]
        }
    }
    impl<T: OnboardRpc> ::prpc::server::NamedService for OnboardServer<T> {
        const NAME: &'static str = "Onboard";
    }
    impl<T: OnboardRpc> ::prpc::server::Service for OnboardServer<T> {
        type Methods = &'static [&'static str];
        fn methods() -> Self::Methods {
            Self::supported_methods()
        }
        async fn dispatch_request(
            self,
            path: &str,
            data: impl AsRef<[u8]>,
            json: bool,
            query: bool,
        ) -> Result<Vec<u8>, ::prpc::server::Error> {
            if json {
                self.dispatch_json_request(path, data, query).await
            } else {
                self.dispatch_request(path, data).await
            }
        }
    }
    impl<T: OnboardRpc> From<T> for OnboardServer<T> {
        fn from(inner: T) -> Self {
            Self::new(inner)
        }
    }
}
